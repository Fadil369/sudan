
Help me to build a massive scale government digital unified system that brings together all about the the country from identity till export in one platform that uniquely identifies everything with unique OID  root 
https://oid-base.com/get/1.3.6.1.4.1.61026
 with leaf 1 taken for places Sudan

I understand you're asking about building a comprehensive government digital system for Sudan. This is a complex undertaking that requires careful planning, legal compliance, and ethical considerations.
 
Here's a high-level framework for such a system:
 
System Architecture Overview
 
1. Core Identity Layer
National ID System: Digital identity for all citizens/residents
Biometric Database: Secure storage of fingerprints, facial recognition
OID Structure: 
Root: 1.3.6.1.4.1.61026.1 (Sudan places)
Extend for: 1.3.6.1.4.1.61026.2 (citizens), 1.3.6.1.4.1.61026.3 (organizations), etc.
 
2. Data Integration Framework
text
text
Government Services → Unified API Gateway → Central Data Lake
    ↓                    ↓                        ↓
Citizen Portal    Business Portal      Analytics & Reporting
 
3. Key Components to Develop
 
A. Identity & Registration Module
Birth/death registration
Citizenship management
Family/household registry
 
B. Economic Module
Business registration
Tax identification
Export/import licensing
Supply chain tracking
 
C. Governance Module
Land registry
Vehicle registration
Public service access
Voting system integration
 
D. Infrastructure
Cloud-based architecture (consider hybrid for data sovereignty)
API-first design for interoperability
Blockchain for audit trails (optional but recommended)
Mobile-first interfaces for accessibility
 
Implementation Considerations
 
Technical Stack
Backend: Microservices architecture (Node.js/Python/Java)
Database: Distributed SQL (PostgreSQL) + NoSQL for documents
Frontend: Progressive Web Apps for broad accessibility
Integration: RESTful APIs with OAuth 2.0 security
OID Management: Custom OID resolver and registry
 
Data Governance
Clear data ownership and access policies
Privacy-by-design (GDPR-like principles)
Data encryption at rest and in transit
Regular security audits
 
Legal & Compliance Framework
Digital signature laws
Data protection regulations
Cybersecurity standards
Inter-agency data sharing agreements
 
Development Approach
 
Phase 1: Foundation (6-12 months)
1.Legal framework establishment
2.Core identity system pilot
3.Basic OID infrastructure
4.Secure data center setup
 
Phase 2: Integration (12-18 months)
1.Connect 3-5 key agencies
2.Develop citizen portal
3.Implement business registration
4.Mobile application launch
 
Phase 3: Expansion (18-24 months)
1.Scale to all government services
2.Advanced analytics implementation
3.Cross-border integration (export/import)
4.AI/ML for fraud detection
 
Critical Success Factors
 
1.Political Will & Stakeholder Buy-in
2.Adequate Funding & Resources
3.Cybersecurity Expertise
4.Change Management & Training
5.Public Awareness Campaigns
6.Phased Rollout Strategy
 
Potential Challenges to Address
 
Digital Divide: Ensure rural access
Data Privacy: Balance transparency with protection
Legacy Systems: Integration with existing databases
Capacity Building: Training government staff
Interoperability: Standardizing data formats
 
Recommended Next Steps
 
1.Feasibility Study: Assess current digital infrastructure
2.Stakeholder Workshops: Engage all government agencies
3.Pilot Project: Start with 2-3 services in one region
4.International Partnerships: Seek technical assistance from organizations like UNDP, World Bank
5.Budget Planning: Secure multi-year funding commitment
 
Would you like me to elaborate on any specific aspect of this framework, such as the technical architecture, legal requirements, or implementation strategy for a particular module?
Agree to proceed for all recommended next steps

Excellent. Let's move forward with a structured implementation plan. I'll outline the immediate actionable steps for each recommended next step.
 
Immediate Action Plan (Next 6 Months)
 
1. Feasibility Study & Assessment (Month 1-2)
 
A. Digital Infrastructure Audit
Team: 5-member technical assessment team (local + international experts)
Tasks: 
Map existing government databases (health, education, land, etc.)
Assess internet connectivity across states (Khartoum, Darfur, Kordofan, etc.)
Evaluate current cybersecurity posture
Document legacy systems integration points
Output: Digital Infrastructure Baseline Report
 
B. Legal Framework Analysis
Team: Legal advisory committee (3 lawyers + 2 policy experts)
Tasks: 
Review existing digital laws (Electronic Transactions Act, 2007)
Analyze data protection requirements
Study international standards (ISO 27001, GDPR principles)
Identify necessary legislative amendments
Output: Legal Gap Analysis & Recommendations
 
C. Stakeholder Mapping
Tasks: 
Identify 25+ key government agencies
Map private sector partners (telecoms, banks, tech companies)
Engage civil society organizations
Output: Stakeholder Matrix with engagement strategy
 
2. Stakeholder Workshops (Month 2-3)
 
Workshop Series Structure:
 
Week 1-2: Leadership Alignment
Participants: Minister-level officials (Interior, Finance, ICT, Justice)
Focus: Vision alignment, resource commitment, governance structure
Deliverable: Signed Memorandum of Understanding (MoU)
 
Week 3-4: Technical Working Groups
Group 1: Identity & Registration (Ministry of Interior, Civil Registry)
Group 2: Economic Systems (Ministry of Trade, Tax Authority, Customs)
Group 3: Infrastructure & Security (Ministry of Communications, National Security)
Deliverable: Technical requirements document
 
Week 5-6: Citizen & Business Focus Groups
Locations: Khartoum, Port Sudan, Nyala, El Obeid
Participants: Business associations, community leaders, youth groups
Deliverable: User needs assessment report
 
3. Pilot Project Design (Month 3-4)
 
Pilot Selection Criteria:
High impact, low complexity
Existing digital foundation
Clear success metrics
 
Recommended Pilot 1: Business Registration + Export Licensing
Scope: Single window for business registration, tax ID, export permits
Location: Khartoum State + Port Sudan Free Zone
Timeline: 6-month development, 3-month testing
Success Metrics: 50% reduction in processing time, 30% increase in formal registrations
 
Recommended Pilot 2: Citizen Digital Identity
Scope: Digital ID for new births in Khartoum hospitals
Integration: Civil Registry, Health Ministry, Education Ministry
Technology: Mobile-based verification
Success Metrics: 95% accuracy, 80% adoption rate
 
Pilot Architecture:
text
text
Pilot System → OID Registry → Central Database
    ↓              ↓              ↓
Business Portal  1.3.6.1.4.1.61026.2  Encrypted Storage
Citizen Portal   1.3.6.1.4.1.61026.3  Access Logs
 
4. International Partnerships (Month 4-5)
 
Priority Partnerships:
1.UNDP Sudan: Digital transformation program funding
2.World Bank: Digital Development Partnership (DDP) technical assistance
3.Estonia: e-Government expertise (via UNDP)
4.India: Aadhaar system experience (UIDAI)
5.UAE: Smart city infrastructure knowledge
 
Partnership Framework:
Technical Assistance: 6-month embedded experts
Funding: Grant applications ($2-5M initial)
Knowledge Transfer: Study visits to Estonia/India
Vendor Partnerships: Microsoft, Oracle, or local tech firms
 
5. Budget Planning (Month 5-6)
 
Phased Budget Structure:
 
Phase 1 (Year 1): Foundation - $15-20M
text
text
Infrastructure: $6M (data centers, network)
Software Development: $5M
Personnel: $4M (local team + international experts)
Legal/Consulting: $2M
Contingency: $3M
 
Funding Sources:
1.Government allocation (30%)
2.International development grants (40%)
3.Public-private partnerships (20%)
4.Technical assistance (10%)
 
Governance Structure:
Steering Committee: Ministers (Chair: Prime Minister's Office)
Technical Committee: CTOs from key ministries
Project Management Office: Dedicated team reporting quarterly
 
Immediate Next Steps (This Week)
 
1.Draft Project Charter (I can help create this)
2.Identify Pilot Project Team Leader
3.Schedule Initial Legal Consultation
4.Prepare Stakeholder Contact List
 
Critical Success Factors to Maintain
 
Transparency: Public dashboard for project progress
Inclusivity: Ensure rural and marginalized communities are included
Security: Cybersecurity review at every phase
Adaptability: Regular review cycles (monthly)
 
Potential Roadblocks & Mitigation
 
Political Transition: Secure multi-party support
Funding Delays: Start with minimal viable pilot
Technical Skills Gap: Invest in local training programs
Resistance to Change: Continuous communication and training
 
Would you like me to:
1.Draft a detailed Project Charter for the pilot phase?
2.Create a Stakeholder Engagement Plan with specific agencies?
3.Develop a Technical Architecture Blueprint for the OID system?
4.Prepare a Funding Proposal template for international partners?
 
I recommend starting with the Project Charter to formalize the initiative. Shall I proceed with that?
Yes please

PROJECT CHARTER
Sudan Government Digital Unified System (SGDUS)
Version: 1.0 Date: February 26, 2026 Project ID: SGDUS-2026-001
 
 
1. PROJECT TITLE
Sudan Government Digital Unified System (SGDUS) - Pilot Phase 1
 
2. PROJECT PURPOSE & JUSTIFICATION
 
Purpose
To establish a secure, integrated digital identity and service delivery platform that uniquely identifies all citizens, businesses, and government entities in Sudan through a unified OID-based system, enabling seamless access to government services from identity registration to export licensing.
 
Justification
Current Challenges: Fragmented government services, manual processes, limited digital access, and inefficient resource allocation
Economic Impact: Estimated 15-20% reduction in administrative costs, increased formal economy participation
Social Impact: Improved service delivery to 45 million citizens, especially in remote areas
Strategic Alignment: Supports Sudan's Digital Transformation Strategy 2025-2030 and Sustainable Development Goals
 
3. PROJECT OBJECTIVES (SMART)
 
Primary Objectives
1.Identity Foundation: Establish digital identity for 500,000 citizens in Khartoum State within 12 months
2.Service Integration: Integrate 5 key government services (Civil Registry, Business Registration, Tax, Export Licensing, Land Registry) by Month 9
3.OID System: Implement OID structure 1.3.6.1.4.1.61026 with sub-identifiers for places, citizens, businesses, and services
4.Accessibility: Achieve 70% mobile penetration and 40% internet access among registered users
5.Security: Achieve ISO 27001 certification for core infrastructure within 18 months
 
Secondary Objectives
Reduce business registration time from 15 days to 3 days
Increase formal business registrations by 25% in pilot areas
Establish interoperability standards for future government systems
Train 200 government staff in digital system management
 
4. KEY DELIVERABLES
 
Technical Deliverables
1.
Core System Platform
OID Registry Service (1.3.6.1.4.1.61026)
Identity Management Module (Citizen & Business)
API Gateway for service integration
Mobile Application (Android/iOS/USSD for basic phones)
Web Portal for citizens and businesses
2.
Data Infrastructure
Secure cloud infrastructure (hybrid model)
Centralized database with encryption
Backup and disaster recovery system
Audit logging system
3.
Integration Components
5 government agency connectors (APIs)
Data mapping and transformation tools
Legacy system adapters (where applicable)
 
Process Deliverables
1.
Governance Framework
Data Sharing Agreements (5 agencies)
Privacy Impact Assessment
Cybersecurity Policy
Incident Response Plan
2.
Operational Documentation
System Architecture Document
User Manuals (Citizen, Business, Admin)
Training Materials (200 staff)
Service Level Agreements
 
Pilot-Specific Deliverables
1.
Khartoum Business Registration Pilot
Digital business registration portal
Integrated tax ID generation
Export license application module
Success metrics dashboard
2.
Citizen Digital ID Pilot
Birth registration integration (5 hospitals)
Family registry module
Mobile ID verification system
 
5. PROJECT SCOPE
 
INCLUSIONS
Geographic: Khartoum State (with potential expansion to Port Sudan)
Services: Civil Registry, Business Registration, Tax ID, Export Licensing, Land Registry
Users: Citizens (adults), businesses (SMEs), government employees
Technology: Cloud-based platform, mobile apps, USSD for basic phones
OID System: Full implementation of 1.3.6.1.4.1.61026 with sub-identifiers
 
EXCLUSIONS
National security systems (separate secure network)
Military and intelligence agency systems
Full-scale national rollout (Phase 1 only)
Hardware distribution (focus on software/platform)
Political decision-making systems
International border control systems (except export/import modules)
 
6. PROJECT TIMELINE (PHASE 1 - 12 MONTHS)
 
Phase 1: Foundation (Months 1-3)
Month 1: Team formation, legal framework, requirements finalization
Month 2: Infrastructure setup, OID system design, stakeholder agreements
Month 3: Core system architecture, pilot design, training program development
 
Phase 2: Development & Integration (Months 4-9)
Months 4-6: Core platform development, identity module, OID implementation
Months 7-8: Integration with 3 agencies (Civil Registry, Business Registration, Tax)
Month 9: Testing, security audit, user acceptance testing
 
Phase 3: Pilot Launch & Evaluation (Months 10-12)
Month 10: Soft launch with 1,000 users, feedback collection
Month 11: Full pilot launch (500,000 target), marketing campaign
Month 12: Evaluation, lessons learned, Phase 2 planning
 
7. BUDGET ESTIMATE (PHASE 1)
 
Category	Amount (USD)	Percentage	Notes
Infrastructure	$4,000,000	25%	Cloud services, servers, network
Software Development	$3,500,000	22%	Custom development, integration
Personnel	$3,000,000	19%	Local team (30) + international experts (5)
Legal & Compliance	$1,200,000	7.5%	Legal review, data protection, contracts
Training & Capacity Building	$1,000,000	6.25%	Staff training, change management
Marketing & Outreach	$800,000	5%	Public awareness, user adoption
Contingency (15%)	$2,400,000	15%	Risk mitigation buffer
TOTAL	$15,900,000	100%	
 
Funding Sources:
Government allocation: $4.8M (30%)
International grants (UNDP/World Bank): $6.36M (40%)
Public-private partnerships: $3.18M (20%)
Technical assistance: $1.59M (10%)
 
8. PROJECT TEAM & KEY STAKEHOLDERS
 
Project Team Structure
text
text
Project Sponsor: Minister of Communications & IT
Project Director: [To be appointed - experienced in digital transformation]
Technical Lead: [To be appointed - 10+ years experience]
 
Core Team (35 members)
Project Management Office (5)
Technical Team (20): Developers, architects, security experts
Business Analysis (5): Requirements, process mapping
Training & Change Management (5)
 
Key Stakeholders
Stakeholder	Role	Involvement
Prime Minister's Office	Executive Sponsor	Monthly steering committee
Ministry of Communications & IT	Technical Oversight	Weekly coordination
Ministry of Interior (Civil Registry)	Data Provider	Bi-weekly meetings
Ministry of Trade & Industry	Business Services	Bi-weekly meetings
Tax Authority	Data Provider	Bi-weekly meetings
Customs Authority	Export/Import Module	Monthly reviews
Ministry of Land & Housing	Land Registry	Monthly reviews
UNDP Sudan	Funding Partner	Quarterly reviews
World Bank	Technical Assistance	Quarterly reviews
Telecom Providers	Infrastructure Partners	Technical working groups
Civil Society Organizations	User Advocacy	User testing sessions
 
9. GOVERNANCE STRUCTURE
 
Steering Committee (Monthly)
Chair: Prime Minister's Office representative
Members: Ministers (Communications, Interior, Trade, Finance), UNDP representative, World Bank representative
Authority: Budget approval, scope changes, risk escalation
 
Technical Committee (Bi-weekly)
Chair: Project Director
Members: Ministry CTOs, Technical Lead, Security Officer
Authority: Technical decisions, integration priorities
 
Project Management Office (Weekly)
Chair: Project Director
Members: Core team leads
Authority: Day-to-day execution, progress tracking
 
Escalation Path
1.Team Level → PMO (within 24 hours)
2.PMO → Technical Committee (within 48 hours)
3.Technical Committee → Steering Committee (within 72 hours)
4.Steering Committee → Cabinet (if required)
 
10. SUCCESS CRITERIA
 
Quantitative Metrics
User Adoption: 500,000 registered citizens by Month 12
Service Efficiency: 50% reduction in processing time for integrated services
System Performance: 99.5% uptime, response time < 2 seconds
Security: Zero critical vulnerabilities, ISO 27001 certification
Economic Impact: 25% increase in formal business registrations
 
Qualitative Metrics
User satisfaction score > 80% (quarterly surveys)
Government agency satisfaction > 75%
Media sentiment analysis positive
International recognition (awards/recognition)
 
Milestone Success Criteria
1.Month 3: Legal framework approved, 100% of team hired
2.Month 6: Core platform alpha version, 3 agency integration agreements signed
3.Month 9: Beta version ready, security audit passed
4.Month 12: Pilot launched, 500,000 users, evaluation report completed
 
11. RISKS & ASSUMPTIONS
 
Key Risks & Mitigation
Risk	Probability	Impact	Mitigation
Political instability	Medium	High	Multi-party support, phased approach
Funding delays	Medium	High	Diversified funding sources, contingency
Technical skills gap	High	Medium	Training program, international experts
Resistance to change	Medium	Medium	Change management program, champions
Cybersecurity threats	High	High	Security-first design, regular audits
Legal/regulatory hurdles	Medium	Medium	Early legal engagement, regulatory sandbox
 
Key Assumptions
1.Government commitment remains stable throughout project
2.Internet connectivity in pilot areas will support digital services
3.Stakeholders will provide timely data and access
4.International partners will deliver technical assistance as agreed
5.Civil society will support user adoption efforts
 
12. APPROVALS
 
Prepared By:
[Project Director Name]Date: February 26, 2026 Signature: _________________________
 
Recommended By:
[Technical Lead Name]Date: February 26, 2026 Signature: _________________________
 
Approved By (Steering Committee):
[Prime Minister's Office Representative]Date: _________________________ Signature: _________________________
 
[Minister of Communications & IT]Date: _________________________ Signature: _________________________
 
[UNDP Sudan Representative]Date: _________________________ Signature: _________________________
 
 
APPENDICES
 
Appendix A: OID Structure Specification
text
text
1.3.6.1.4.1.61026 - Sudan Government Digital System
├── 1 - Places (States, Districts, Localities)
├── 2 - Citizens (Individuals)
├── 3 - Businesses (Legal Entities)
├── 4 - Government Entities (Agencies, Departments)
├── 5 - Services (Digital Services)
└── 6 - Documents (Digital Certificates, Licenses)
 
Appendix B: Glossary
OID: Object Identifier - Unique hierarchical identification system
SGDUS: Sudan Government Digital Unified System
USSD: Unstructured Supplementary Service Data (for basic phones)
API: Application Programming Interface
ISO 27001: International standard for information security management
 
Appendix C: Change Control Process
1.Change request submitted via portal
2.Impact assessment by PMO (3 days)
3.Technical Committee review (5 days)
4.Steering Committee approval (for significant changes)
5.Implementation and documentation
 
 
Document Control:
Version: 1.0
Status: Draft for Approval
Next Review: After Steering Committee approval
Distribution: Steering Committee, Core Team, Key Stakeholders
 
 
NEXT STEPS IMMEDIATELY FOLLOWING APPROVAL
 
1.Week 1: Formal project kickoff meeting
2.Week 2: Team onboarding and initial training
3.Week 3: Detailed requirements workshop with agencies
4.Week 4: Infrastructure procurement and setup begins
 
 
This Project Charter establishes the foundation for Sudan's digital transformation. Upon approval, the project will proceed to detailed planning and execution.
 
END OF PROJECT CHARTER
 
 
Would you like me to proceed with any of the following next steps?
1.Detailed Work Breakdown Structure (WBS) for Phase 1
2.Stakeholder Engagement Plan with specific communication strategies
3.Risk Register with detailed mitigation plans
4.Technical Architecture Blueprint for the OID system
5.Funding Proposal Template for international partners
 
I recommend creating the Stakeholder Engagement Plan next to ensure all agencies and partners are properly coordinated. Shall I proceed with that?
All the following please, one by one: Detailed Work Breakdown Structure (WBS) for Phase 1
2.Stakeholder Engagement Plan with specific communication strategies
3.Risk Register with detailed mitigation plans
4.Technical Architecture Blueprint for the OID system
5.Funding Proposal Template for international partners

1. DETAILED WORK BREAKDOWN STRUCTURE (WBS) FOR PHASE 1
 
WBS HIERARCHY
 
1.0 PROJECT INITIATION & PLANNING (Month 1-2)
text
text
1.1 Project Setup
    1.1.1 Finalize Project Charter (1 week)
    1.1.2 Establish Project Management Office (PMO) (2 weeks)
    1.1.3 Set up project collaboration tools (1 week)
    1.1.4 Develop project communication plan (2 weeks)

1.2 Team Formation
    1.2.1 Recruit Project Director (2 weeks)
    1.2.2 Recruit Technical Lead (2 weeks)
    1.2.3 Hire Core Team members (4 weeks)
    1.2.4 Onboard international experts (2 weeks)
    1.2.5 Conduct team training on project methodology (1 week)

1.3 Legal & Governance Framework
    1.3.1 Legal gap analysis (2 weeks)
    1.3.2 Draft data protection policy (3 weeks)
    1.3.3 Develop data sharing agreements (4 weeks)
    1.3.4 Establish steering committee (1 week)
    1.3.5 Create project governance charter (2 weeks)
 
2.0 INFRASTRUCTURE SETUP (Month 1-3)
text
text
2.1 Cloud Infrastructure
    2.1.1 Select cloud provider (2 weeks)
    2.1.2 Design hybrid cloud architecture (3 weeks)
    2.1.3 Set up development environment (2 weeks)
    2.1.4 Configure security baseline (3 weeks)
    2.1.5 Establish backup and recovery systems (2 weeks)

2.2 Network & Connectivity
    2.2.1 Assess existing government network (2 weeks)
    2.2.2 Design secure network architecture (3 weeks)
    2.2.3 Establish VPN for agency connections (2 weeks)
    2.2.4 Set up monitoring and alerting (2 weeks)

2.3 Development Environment
    2.3.1 Set up version control (Git) (1 week)
    2.3.2 Configure CI/CD pipeline (2 weeks)
    2.3.3 Establish development testing environment (2 weeks)
    2.3.4 Set up security scanning tools (2 weeks)
 
3.0 REQUIREMENTS & DESIGN (Month 2-3)
text
text
3.1 Requirements Gathering
    3.1.1 Conduct agency workshops (4 weeks)
    3.1.2 Document business processes (3 weeks)
    3.1.3 Define user stories (3 weeks)
    3.1.4 Prioritize requirements (2 weeks)

3.2 System Design
    3.2.1 Develop high-level architecture (2 weeks)
    3.2.2 Design OID system structure (3 weeks)
    3.2.3 Design data models (3 weeks)
    3.2.4 Design API specifications (2 weeks)
    3.2.5 Create UI/UX prototypes (3 weeks)

3.3 Integration Planning
    3.3.1 Map agency data sources (3 weeks)
    3.3.2 Design integration interfaces (3 weeks)
    3.3.3 Plan legacy system adapters (2 weeks)
    3.3.4 Develop data migration strategy (2 weeks)
 
4.0 CORE SYSTEM DEVELOPMENT (Month 4-9)
text
text
4.1 OID System Development
    4.1.1 Implement OID registry service (3 weeks)
    4.1.2 Develop OID resolver (2 weeks)
    4.1.3 Create OID management interface (3 weeks)
    4.1.4 Implement OID validation rules (2 weeks)
    4.1.5 Develop OID audit logging (2 weeks)

4.2 Identity Management Module
    4.2.1 Develop citizen registration API (4 weeks)
    4.2.2 Implement business registration API (4 weeks)
    4.2.3 Create biometric integration module (6 weeks)
    4.2.4 Develop verification services (3 weeks)
    4.2.5 Implement de-duplication engine (4 weeks)

4.3 API Gateway & Security
    4.3.1 Implement API gateway (3 weeks)
    4.3.2 Develop authentication service (4 weeks)
    4.3.3 Implement authorization framework (3 weeks)
    4.3.4 Create rate limiting and throttling (2 weeks)
    4.3.5 Develop API documentation (3 weeks)

4.4 Frontend Development
    4.4.1 Develop citizen portal (6 weeks)
    4.4.2 Develop business portal (6 weeks)
    4.4.3 Create admin dashboard (5 weeks)
    4.4.4 Develop USSD interface (4 weeks)
    4.4.5 Build mobile applications (8 weeks)
 
5.0 INTEGRATION & DATA MIGRATION (Month 6-9)
text
text
5.1 Agency Integration
    5.1.1 Civil Registry integration (4 weeks)
    5.1.2 Business Registration integration (4 weeks)
    5.1.3 Tax Authority integration (4 weeks)
    5.1.4 Customs/Export integration (4 weeks)
    5.1.5 Land Registry integration (4 weeks)

5.2 Data Migration
    5.2.1 Data assessment and mapping (3 weeks)
    5.2.2 Develop ETL pipelines (4 weeks)
    5.2.3 Perform pilot data migration (3 weeks)
    5.2.4 Validate migrated data (2 weeks)
    5.2.5 Create data reconciliation process (2 weeks)

5.3 Legacy System Adapters
    5.3.1 Assess legacy systems (2 weeks)
    5.3.2 Develop adapter components (4 weeks)
    5.3.3 Test adapter functionality (2 weeks)
    5.3.4 Deploy adapters to test environment (1 week)
 
6.0 TESTING & SECURITY (Month 8-10)
text
text
6.1 System Testing
    6.1.1 Unit testing (4 weeks)
    6.1.2 Integration testing (4 weeks)
    6.1.3 System testing (3 weeks)
    6.1.4 Performance testing (3 weeks)
    6.1.5 User acceptance testing (4 weeks)

6.2 Security Testing
    6.2.1 Vulnerability assessment (3 weeks)
    6.2.2 Penetration testing (3 weeks)
    6.2.3 Security code review (3 weeks)
    6.2.4 Compliance audit (ISO 27001) (4 weeks)
    6.2.5 Incident response testing (2 weeks)

6.3 Quality Assurance
    6.3.1 Develop test plans (2 weeks)
    6.3.2 Create test cases (3 weeks)
    6.3.3 Automate testing (4 weeks)
    6.3.4 Perform regression testing (2 weeks)
    6.3.5 Prepare test reports (2 weeks)
 
7.0 PILOT IMPLEMENTATION (Month 10-12)
text
text
7.1 Pilot Preparation
    7.1.1 Select pilot locations (1 week)
    7.1.2 Recruit pilot users (2 weeks)
    7.1.3 Prepare pilot infrastructure (2 weeks)
    7.1.4 Develop pilot training materials (3 weeks)
    7.1.5 Create pilot support plan (2 weeks)

7.2 Pilot Launch
    7.2.1 Soft launch (1,000 users) (1 week)
    7.2.2 Monitor and collect feedback (2 weeks)
    7.2.3 Full pilot launch (500,000 users) (2 weeks)
    7.2.4 Provide user support (ongoing)
    7.2.5 Conduct user surveys (ongoing)

7.3 Pilot Evaluation
    7.3.1 Collect performance metrics (ongoing)
    7.3.2 Analyze user feedback (2 weeks)
    7.3.3 Evaluate success criteria (2 weeks)
    7.3.4 Document lessons learned (2 weeks)
    7.3.5 Prepare Phase 2 recommendations (2 weeks)
 
8.0 TRAINING & CAPACITY BUILDING (Month 2-12)
text
text
8.1 Staff Training
    8.1.1 Develop training curriculum (4 weeks)
    8.1.2 Train project team (4 weeks)
    8.1.3 Train agency staff (6 weeks)
    8.1.4 Train support staff (4 weeks)
    8.1.5 Conduct train-the-trainer sessions (3 weeks)

8.2 Change Management
    8.2.1 Develop change management plan (3 weeks)
    8.2.2 Create communication materials (4 weeks)
    8.2.3 Conduct stakeholder awareness sessions (6 weeks)
    8.2.4 Establish change champions network (4 weeks)
    8.2.5 Monitor adoption and address resistance (ongoing)

8.3 Public Awareness
    8.3.1 Develop public awareness campaign (4 weeks)
    8.3.2 Create educational materials (4 weeks)
    8.3.3 Launch media campaign (4 weeks)
    8.3.4 Conduct community outreach (6 weeks)
    8.3.5 Monitor public sentiment (ongoing)
 
9.0 GOVERNANCE & REPORTING (Month 1-12)
text
text
9.1 Project Management
    9.1.1 Weekly progress reporting (ongoing)
    9.1.2 Monthly steering committee meetings (ongoing)
    9.1.3 Budget tracking and reporting (ongoing)
    9.1.4 Risk management activities (ongoing)
    9.1.5 Quality assurance reviews (ongoing)

9.2 Stakeholder Management
    9.2.1 Agency coordination meetings (bi-weekly)
    9.2.2 International partner updates (monthly)
    9.2.3 Public communications (monthly)
    9.2.4 Issue tracking and resolution (ongoing)

9.3 Documentation
    9.3.1 Technical documentation (ongoing)
    9.3.2 User manuals (ongoing)
    9.3.3 Process documentation (ongoing)
    9.3.4 Knowledge base creation (ongoing)
    9.3.5 Archive project artifacts (ongoing)
 
10.0 INTERNATIONAL PARTNERSHIPS (Month 3-12)
text
text
10.1 Partnership Development
    10.1.1 Identify and prioritize partners (2 weeks)
    10.1.2 Develop partnership proposals (3 weeks)
    10.1.3 Negotiate agreements (4 weeks)
    10.1.4 Establish partnership governance (2 weeks)

10.2 Technical Assistance
    10.2.1 Engage international experts (4 weeks)
    10.2.2 Conduct knowledge transfer sessions (ongoing)
    10.2.3 Arrange study visits (6 weeks)
    10.2.4 Establish vendor partnerships (4 weeks)

10.3 Funding Acquisition
    10.3.1 Develop funding proposals (4 weeks)
    10.3.2 Submit grant applications (4 weeks)
    10.3.3 Track funding commitments (ongoing)
    10.3.4 Report on fund utilization (monthly)
 
WBS CODE STRUCTURE
text
text
1.0 - Project Initiation & Planning
2.0 - Infrastructure Setup
3.0 - Requirements & Design
4.0 - Core System Development
5.0 - Integration & Data Migration
6.0 - Testing & Security
7.0 - Pilot Implementation
8.0 - Training & Capacity Building
9.0 - Governance & Reporting
10.0 - International Partnerships
 
CRITICAL PATH ITEMS
1.Project Charter Approval (Month 1)
2.Core Team Hiring (Month 1-2)
3.Infrastructure Setup (Month 1-3)
4.OID System Development (Month 4-6)
5.Agency Integration (Month 6-9)
6.Pilot Launch (Month 10)
7.Pilot Evaluation (Month 12)
 
RESOURCE ALLOCATION PER WORK PACKAGE
text
text
Total FTEs: 35 (core team) + 5 (international experts) = 40 FTEs
- Infrastructure: 8 FTEs
- Development: 18 FTEs
- Integration: 10 FTEs
- Testing: 6 FTEs
- Training: 5 FTEs
- Governance: 3 FTEs
 
END OF WBS SECTION
 
 
2. STAKEHOLDER ENGAGEMENT PLAN
 
STAKEHOLDER IDENTIFICATION & ANALYSIS
 
Stakeholder Matrix
Stakeholder	Interest	Influence	Engagement Level	Strategy
Prime Minister's Office	High	Very High	Executive Sponsor	Monthly steering committee, direct briefings
Minister of Communications & IT	High	Very High	Project Sponsor	Weekly coordination, decision authority
Minister of Interior	High	High	Data Provider	Bi-weekly technical meetings
Minister of Trade	High	High	Service User	Bi-weekly workshops, user testing
Tax Authority	High	High	Data Provider	Weekly integration meetings
Customs Authority	Medium	Medium	Service User	Monthly review, pilot participation
Ministry of Land	Medium	Medium	Data Provider	Monthly integration meetings
UNDP Sudan	High	High	Funding Partner	Quarterly reviews, milestone approvals
World Bank	High	High	Technical Partner	Quarterly reviews, technical oversight
Telecom Providers	Medium	Medium	Infrastructure Partner	Technical working groups, SLA management
Civil Society Organizations	High	Medium	User Advocates	User testing, feedback collection
Private Sector (SMEs)	High	Low	End Users	Focus groups, pilot participation
Citizens (General)	High	Low	End Users	Public awareness, community outreach
International Donors	Medium	Medium	Potential Funders	Proposal presentations, relationship building
 
COMMUNICATION STRATEGIES BY STAKEHOLDER GROUP
 
A. Executive Stakeholders (Prime Minister, Ministers)
Objective: Secure commitment, provide oversight, resolve escalations
text
text
1. Monthly Steering Committee Meetings
   - Format: In-person (Khartoum) with virtual option
   - Agenda: Progress review, decisions, risk escalation
   - Deliverables: Minutes, action items, decisions log
   - Timing: First Monday of each month, 9 AM - 12 PM

2. Executive Briefings
   - Format: Concise 10-slide deck + 30-minute discussion
   - Frequency: Bi-weekly for active issues
   - Content: Progress, risks, decisions needed
   - Delivery: Secure email + in-person presentation

3. Decision Request System
   - Platform: Secure portal with 48-hour response requirement
   - Process: Clear decision request form with impact analysis
   - Escalation: 24-hour reminder, then direct to sponsor
 
B. Agency Stakeholders (Government Ministries)
Objective: Ensure cooperation, data sharing, system adoption
text
text
1. Technical Working Groups (Bi-weekly)
   - Structure: 5 working groups (one per integrated service)
   - Format: 2-hour meetings with action items
   - Participants: Agency CTOs, data owners, IT staff
   - Deliverables: Integration plans, data maps, test results

2. Agency Champion Program
   - Selection: 2 champions per agency (1 technical, 1 business)
   - Training: 5-day intensive program
   - Responsibilities: Internal coordination, feedback collection
   - Incentives: Recognition, career development

3. Data Sharing Workshops
   - Frequency: Monthly per agency
   - Format: Hands-on data mapping sessions
   - Tools: Data dictionaries, transformation rules
   - Output: Signed data sharing agreements

4. Integration Progress Dashboard
   - Platform: Real-time dashboard accessible to all agencies
   - Metrics: Data quality, integration status, issues
   - Reporting: Automated weekly reports to agency heads
 
C. International Partners (UNDP, World Bank, Donors)
Objective: Maintain funding, technical support, accountability
text
text
1. Quarterly Review Meetings
   - Format: Hybrid (virtual + in-person option)
   - Agenda: Milestone review, financial reporting, risk assessment
   - Deliverables: Quarterly reports, financial statements
   - Timing: Last week of each quarter

2. Technical Assistance Coordination
   - Platform: Shared workspace (e.g., Microsoft Teams)
   - Meetings: Weekly technical sync with embedded experts
   - Documentation: Technical decisions log, architecture reviews
   - Reporting: Monthly technical progress reports

3. Funding Reporting
   - Frequency: Monthly financial reports, quarterly impact reports
   - Format: Standardized templates (UNDP/World Bank formats)
   - Process: Finance team review → Agency validation → Submission
   - Timeline: 5 business days after month end

4. Study Visits & Knowledge Exchange
   - Planning: 3 months advance notice
   - Content: Specific technical or governance topics
   - Participants: 5-10 Sudanese staff + international experts
   - Output: Implementation plan for learned practices
 
D. Civil Society & Private Sector
Objective: Build trust, gather feedback, ensure inclusivity
text
text
1. User Advisory Council
   - Composition: 15 members (5 businesses, 5 NGOs, 5 citizens)
   - Meetings: Monthly (rotating locations)
   - Role: User experience feedback, design input
   - Output: Prioritized improvement list

2. Public Awareness Campaign
   - Channels: Radio, TV, social media, community meetings
   - Content: Simple explanations, benefits, how-to guides
   - Frequency: Weekly during pilot, monthly thereafter
   - Languages: Arabic, English, local languages (as needed)

3. Pilot User Support
   - Help Desk: 24/7 call center + WhatsApp support
   - Training: In-person sessions at registration centers
   - Feedback Mechanism: In-app feedback, SMS surveys
   - Response Time: 24 hours for critical issues

4. Business Engagement
   - Chambers of Commerce: Monthly meetings
   - SME Workshops: Quarterly training sessions
   - Pilot Incentives: Fee waivers for early adopters
   - Success Stories: Public recognition of champions
 
E. General Public
Objective: Awareness, adoption, feedback
text
text
1. Multi-Channel Communication Strategy
   - Digital: Social media (Facebook, Twitter), SMS campaigns
   - Traditional: Radio programs, community meetings
   - Print: Newspaper ads, posters in public spaces
   - Timing: Continuous during pilot, quarterly thereafter

2. Community Outreach Program
   - Locations: Khartoum, Port Sudan, Nyala, El Obeid
   - Frequency: Monthly in each location
   - Activities: Demos, Q&A, registration assistance
   - Partners: Local leaders, religious institutions

3. Feedback Collection
   - Channels: USSD survey, SMS, hotline, in-person
   - Incentives: Airtime credit for completed surveys
   - Analysis: Monthly sentiment analysis
   - Response: Public acknowledgment of feedback
 
COMMUNICATION CALENDAR (MONTH 1-12)
 
Month	Executive	Agencies	Partners	Public
1	Charter approval meeting	Kickoff workshop	Proposal submission	Awareness campaign launch
2	Monthly steering	TWG meetings begin	Partnership negotiations	Community meetings
3	Monthly steering	Data sharing workshops	Quarterly review	Radio program launch
4	Monthly steering	Integration planning	Technical assistance start	Social media campaign
5	Monthly steering	Progress reviews	Funding proposal updates	Success story collection
6	Monthly steering	Integration testing	Quarterly review	Pilot user recruitment
7	Monthly steering	UAT coordination	Technical review	Pilot awareness campaign
8	Monthly steering	Security audit	Funding status update	User training sessions
9	Monthly steering	Final integration	Quarterly review	Pilot launch events
10	Monthly steering	Pilot support	Technical assistance	Public demonstrations
11	Monthly steering	Evaluation input	Progress reporting	Feedback collection
12	Review & planning	Lessons learned	Next phase planning	Success celebration
 
ESCALATION MATRIX
 
Issue Resolution Path
text
text
Level 1: Team → PMO (24 hours)
Level 2: PMO → Technical Committee (48 hours)
Level 3: Technical Committee → Steering Committee (72 hours)
Level 4: Steering Committee → Cabinet (5 days)
 
Escalation Triggers
1.Technical: System downtime > 4 hours, security breach
2.Financial: Budget variance > 10%, funding delay > 30 days
3.Resource: Key personnel departure, skill gap impact
4.Political: Stakeholder resistance, policy change
5.External: Regulatory change, natural disaster
 
MEASUREMENT & EVALUATION
 
Success Metrics for Engagement
1.Meeting Effectiveness: 90% attendance rate, action item completion > 85%
2.Stakeholder Satisfaction: Quarterly survey score > 4.0/5.0
3.Communication Timeliness: 95% of reports delivered on schedule
4.Issue Resolution: 90% of issues resolved within SLA
5.Adoption Rate: Agency participation > 80% in required activities
 
Feedback Mechanisms
1.Monthly Pulse Surveys: 3-question survey to all stakeholders
2.Quarterly Deep Dive: 1-hour interview with key stakeholders
3.Annual Stakeholder Conference: Full-day review and planning
4.Anonymous Feedback Portal: Continuous input collection
 
RISK MITIGATION IN ENGAGEMENT
 
Potential Risks & Mitigation
Risk	Mitigation Strategy
Stakeholder fatigue	Rotate meeting leaders, vary formats, celebrate wins
Conflicting priorities	Executive mandate, clear benefits communication
Communication breakdown	Multiple channels, confirmation of receipt, escalation
Cultural/language barriers	Local translators, culturally appropriate materials
Resource constraints	Phased engagement, prioritize high-impact stakeholders
 
BUDGET FOR STAKEHOLDER ENGAGEMENT
text
text
Total: $800,000 (from Phase 1 budget)
- Meetings & Workshops: $200,000 (venue, travel, materials)
- Communication Materials: $150,000 (design, production, distribution)
- Training & Capacity Building: $300,000 (programs, materials, incentives)
- Public Awareness: $100,000 (media, community events)
- Contingency: $50,000
 
END OF STAKEHOLDER ENGAGEMENT PLAN
 
 
3. RISK REGISTER WITH DETAILED MITIGATION PLANS
 
RISK IDENTIFICATION & SCORING
 
Risk Scoring Matrix
Probability: 1 (Rare) to 5 (Almost Certain)
Impact: 1 (Negligible) to 5 (Catastrophic)
Risk Score: Probability × Impact (1-25)
Risk Level: Low (1-5), Medium (6-12), High (13-25)
 
COMPREHENSIVE RISK REGISTER
 
CATEGORY 1: POLITICAL & GOVERNANCE RISKS
 
Risk ID	Risk Description	Prob.	Impact	Score	Owner	Mitigation Strategy	Contingency Plan
POL-01	Government transition or instability	3	5	15	Project Sponsor	1. Secure multi-party support
2. Build bipartisan champions
3. Phase implementation to show quick wins	Activate emergency governance committee; pause non-critical work
POL-02	Policy/regulatory changes affecting project	4	4	16	Legal Lead	1. Regular regulatory monitoring
2. Engage regulators early
3. Design flexible architecture	Legal review and adaptation; temporary workarounds
POL-03	Inter-agency conflicts or resistance	4	4	16	Project Director	1. Executive mandate from PMO
2. Clear benefit communication
3. Incentive alignment	Escalate to steering committee; consider phased integration
POL-04	Budget reallocation or cuts	3	5	15	Finance Lead	1. Diversified funding sources
2. Phased funding requests
3. Contingency fund (15%)	Scale down scope; prioritize critical features
 
CATEGORY 2: TECHNICAL & INFRASTRUCTURE RISKS
 
Risk ID	Risk Description	Prob.	Impact	Score	Owner	Mitigation Strategy	Contingency Plan
TECH-01	Legacy system integration failure	4	4	16	Technical Lead	1. Detailed legacy assessment
2. Develop robust adapters
3. Parallel run testing	Manual workaround; extend timeline; consider replacement
TECH-02	Cybersecurity breach or data loss	2	5	10	Security Officer	1. Security-by-design approach
2. Regular penetration testing
3. Encryption at rest/transit	Incident response plan; system isolation; communication protocol
TECH-03	Scalability/performance issues	3	4	12	Architect	1. Load testing from early stages
2. Cloud auto-scaling
3. Performance monitoring	Emergency capacity increase; optimize code; caching
TECH-04	OID system design flaws	3	4	12	OID Architect	1. Expert review (international)
2. Pilot testing
3. Flexible OID structure	Schema migration; dual system during transition
TECH-05	Mobile/USSD compatibility issues	4	3	12	Mobile Lead	1. Test on wide range of devices
2. Progressive enhancement
3. Multiple access channels	Simplified SMS/USSD fallback; feature phones support
 
CATEGORY 3: RESOURCE & CAPABILITY RISKS
 
Risk ID	Risk Description	Prob.	Impact	Score	Owner	Mitigation Strategy	Contingency Plan
RES-01	Skills gap in local team	4	3	12	HR Lead	1. Intensive training program
2. International expert pairing
3. Phased responsibility transfer	Additional contractors; knowledge transfer workshops
RES-02	Key personnel departure	3	4	12	Project Director	1. Succession planning
2. Knowledge documentation
3. Competitive compensation	Interim experts; redistribute work; hire replacements
RES-03	Vendor/partner failure	3	4	12	Procurement Lead	1. Rigorous vendor selection
2. SLAs with penalties
3. Regular performance reviews	Alternative vendors; bring critical functions in-house
RES-04	Training adoption resistance	4	3	12	Training Lead	1. Change champions program
2. Incentive structures
3. Hands-on training	Executive mandate; performance metrics tied to training
 
CATEGORY 4: FINANCIAL & RESOURCE RISKS
 
Risk ID	Risk Description	Prob.	Impact	Score	Owner	Mitigation Strategy	Contingency Plan
FIN-01	Currency fluctuation affecting costs	3	3	9	Finance Lead	1. Hedging strategy
2. Local currency procurement
3. Multi-currency budgeting	Budget reallocation; scope adjustment
FIN-02	Inflation increasing costs	4	3	12	Finance Lead	1. Fixed-price contracts
2. Regular cost reviews
3. Contingency buffer	Value engineering; phased delivery
FIN-03	International funding delays	3	4	12	Finance Lead	1. Multiple funding sources
2. Advance payment terms
3. Government bridge funding	Scale down scope; prioritize paid activities
 
CATEGORY 5: EXTERNAL & ENVIRONMENTAL RISKS
 
Risk ID	Risk Description	Prob.	Impact	Score	Owner	Mitigation Strategy	Contingency Plan
EXT-01	Infrastructure/power failures	3	4	12	Infrastructure Lead	1. UPS and generators
2. Multiple data centers
3. Cloud redundancy	Manual processes; temporary offline solutions
EXT-02	Internet connectivity issues	4	3	12	Infrastructure Lead	1. Multiple ISPs
2. Offline-capable apps
3. USSD/SMS alternatives	Extended offline functionality; community access points
EXT-03	Natural disasters (floods, etc.)	2	5	10	Business Continuity Lead	1. Disaster recovery plan
2. Off-site backups
3. Geographic redundancy	Activate DR plan; relocate operations
EXT-04	Public health crises (pandemics)	2	4	8	Business Continuity Lead	1. Remote work capabilities
2. Virtual collaboration tools
3. Supply chain diversification	Remote operations; revised timelines
 
CATEGORY 6: USER & ADOPTION RISKS
 
Risk ID	Risk Description	Prob.	Impact	Score	Owner	Mitigation Strategy	Contingency Plan
USER-01	Low digital literacy	5	3	15	Training Lead	1. Simplified interfaces
2. Multilingual support
3. Community training centers	Extended support; phone assistance; agent network
USER-02	Privacy concerns	4	4	16	Privacy Officer	1. Transparent privacy policy
2. Consent mechanisms
3. Data minimization	Enhanced controls; opt-out options; independent oversight
USER-03	Resistance to change	4	3	12	Change Lead	1. Strong communication
2. Early wins demonstration
3. Incentives for adoption	Mandatory rollout with grace period; leadership enforcement
USER-04	Digital divide (rural/urban)	5	4	20	Accessibility Lead	1. Multiple access channels
2. Community access points
3. Offline capabilities	Mobile registration vans; paper-based alternatives
 
CATEGORY 7: INTEGRATION & DATA RISKS
 
Risk ID	Risk Description	Prob.	Impact	Score	Owner	Mitigation Strategy	Contingency Plan
INT-01	Data quality issues	4	4	16	Data Architect	1. Data quality rules
2. Validation at source
3. Cleansing routines	Manual data correction; exclusion of poor-quality data
INT-02	Data standardization conflicts	4	3	12	Data Architect	1. Data governance framework
2. Master data management
3. Reference data management	Transformation rules; data mapping exceptions
INT-03	Cross-agency data sharing disputes	3	4	12	Legal Lead	1. Clear data sharing agreements
2. Legal review process
3. Data ownership clarification	Escalation to steering committee; limited data sharing
 
RISK MONITORING & CONTROL
 
Risk Review Schedule
Weekly: Risk review in PMO meetings
Monthly: Detailed risk assessment with owners
Quarterly: Comprehensive risk review with steering committee
Trigger-based: Immediate review when risk score changes > 3 points
 
Risk Metrics Dashboard
text
text
Key Risk Indicators (KRIs):
1. Number of High Risks (Target: < 3)
2. Risk Exposure Score (Target: < 50)
3. Mitigation Effectiveness (Target: > 80%)
4. New Risks Identified (Target: < 2 per month)
5. Risk Resolution Rate (Target: > 75% on time)
 
Risk Escalation Protocol
text
text
Level 1: Team identifies risk → Document in risk register → Owner develops mitigation
Level 2: Risk score increases or mitigation fails → Escalate to PMO
Level 3: High risk (score >15) or unresolved → Escalate to Technical Committee
Level 4: Critical risk (score >20) or project-threatening → Escalate to Steering Committee
Level 5: Existential risk → Escalate to Cabinet/Prime Minister's Office
 
CONTINGENCY FUND ALLOCATION
 
Total Contingency: 
2.4
M
(
15
2.4M(1516M)
text
text
Category                    Allocation     Percentage
Technical Contingency      $800,000       33%
Resource Contingency       $600,000       25%
Political Risk Buffer      $500,000       21%
External/Environmental     $300,000       13%
Unallocated Reserve        $200,000       8%
 
Contingency Release Process
1.Request: Risk owner submits contingency request with justification
2.Review: PMO reviews within 48 hours
3.Approval: Up to 
50
K
b
y
P
r
o
j
e
c
t
D
i
r
e
c
t
o
r
;
50KbyProjectDirector;50K-
200
K
b
y
T
e
c
h
n
i
c
a
l
C
o
m
m
i
t
t
e
e
;
>
200KbyTechnicalCommittee;>200K by Steering Committee
4.Tracking: All contingency use tracked and reported monthly
 
RISK MITIGATION SUCCESS METRICS
 
Targets for Year 1
Risk Identification: 100% of high risks identified by Month 3
Mitigation Implementation: 90% of mitigations implemented within 30 days of identification
Risk Reduction: 50% reduction in high-risk items by Month 9
Contingency Utilization: < 80% of contingency fund used
Zero Critical Incidents: No security breaches or system failures > 24 hours
 
Risk Culture Development
1.Training: All team members trained in risk management (Month 2)
2.Recognition: Monthly risk champion awards
3.Transparency: Public risk dashboard (anonymized)
4.Continuous Improvement: Quarterly risk process review
 
END OF RISK REGISTER
 
 
4. TECHNICAL ARCHITECTURE BLUEPRINT FOR OID SYSTEM
 
OVERALL ARCHITECTURE PRINCIPLES
 
Core Design Principles
1.Security First: Zero-trust architecture, encryption everywhere
2.Scalability: Horizontal scaling, microservices architecture
3.Interoperability: Standards-based APIs, open protocols
4.Resilience: Redundancy, failover, disaster recovery
5.Compliance: GDPR-like privacy, ISO 27001 security
6.Accessibility: Multi-channel access (web, mobile, USSD)
7.Maintainability: Modular design, comprehensive documentation
 
SYSTEM ARCHITECTURE DIAGRAM
 
text
text
┌─────────────────────────────────────────────────────────────────────┐
│                        PRESENTATION LAYER                           │
├─────────────────────────────────────────────────────────────────────┤
│  Citizen Portal  │  Business Portal  │  Admin Dashboard  │  USSD    │
│  (Web/Mobile)    │  (Web/Mobile)     │  (Web)            │  Gateway │
└─────────────────┬───────────────────┬───────────────────┬───────────┘
                  │                   │                   │
                  ▼                   ▼                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      API GATEWAY & SECURITY LAYER                   │
├─────────────────────────────────────────────────────────────────────┤
│  API Gateway │  Authentication │  Authorization │  Rate Limiting   │
│  (Kong/Nginx)│  (OAuth 2.0)    │  (RBAC)        │  (Throttling)    │
└─────────────────┬───────────────────┬───────────────────┬───────────┘
                  │                   │                   │
                  ▼                   ▼                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│                    CORE BUSINESS LOGIC LAYER                        │
├─────────────────────────────────────────────────────────────────────┤
│  Identity Service  │  OID Service  │  Verification   │  Audit       │
│  (Citizen/Biz)     │  (Resolver)   │  (Biometric)    │  Service     │
└─────────────────┬───────────────────┬───────────────────┬───────────┘
                  │                   │                   │
                  ▼                   ▼                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│                    DATA ACCESS & INTEGRATION LAYER                  │
├─────────────────────────────────────────────────────────────────────┤
│  Data Mapper  │  Integration Adapters │  ETL Pipeline │  Cache      │
│  (Agency APIs)│  (Legacy Systems)     │  (Data Sync)  │  (Redis)    │
└─────────────────┬───────────────────┬───────────────────┬───────────┘
                  │                   │                   │
                  ▼                   ▼                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│                       DATA STORAGE LAYER                            │
├─────────────────────────────────────────────────────────────────────┤
│  Identity DB  │  OID Registry DB  │  Audit DB  │  Document Store   │
│  (PostgreSQL) │  (PostgreSQL)     │  (MongoDB) │  (S3 Compatible)  │
└─────────────────────────────────────────────────────────────────────┘
 
OID SYSTEM SPECIFICATION
 
OID Structure Definition
text
text
Root: 1.3.6.1.4.1.61026 (Sudan Government Digital System)

Full OID Hierarchy:
1.3.6.1.4.1.61026.1 - Places (Geographical Entities)
   ├── 1.3.6.1.4.1.61026.1.1 - States
   │   ├── 1.3.6.1.4.1.61026.1.1.1 - Khartoum State
   │   ├── 1.3.6.1.4.1.61026.1.1.2 - North Kordofan
   │   └── ... (all 18 states)
   ├── 1.3.6.1.4.1.61026.1.2 - Districts
   └── 1.3.6.1.4.1.61026.1.3 - Localities

1.3.6.1.4.1.61026.2 - Citizens (Individuals)
   ├── 1.3.6.1.4.1.61026.2.1 - Adults
   ├── 1.3.6.1.4.1.61026.2.2 - Minors
   └── 1.3.6.1.4.1.61026.2.3 - Special Categories

1.3.6.1.4.1.61026.3 - Businesses (Legal Entities)
   ├── 1.3.6.1.4.1.61026.3.1 - Sole Proprietorship
   ├── 1.3.6.1.4.1.61026.3.2 - Partnership
   ├── 1.3.6.1.4.1.61026.3.3 - Limited Company
   └── 1.3.6.1.4.1.61026.3.4 - Foreign Entity

1.3.6.1.4.1.61026.4 - Government Entities
   ├── 1.3.6.1.4.1.61026.4.1 - Ministries
   ├── 1.3.6.1.4.1.61026.4.2 - Agencies
   ├── 1.3.6.1.4.1.61026.4.3 - Local Governments
   └── 1.3.6.1.4.1.61026.4.4 - Public Enterprises

1.3.6.1.4.1.61026.5 - Digital Services
   ├── 1.3.6.1.4.1.61026.5.1 - Identity Services
   ├── 1.3.6.1.4.1.61026.5.2 - Business Services
   ├── 1.3.6.1.4.1.61026.5.3 - Tax Services
   ├── 1.3.6.1.4.1.61026.5.4 - Customs Services
   └── 1.3.6.1.4.1.61026.5.5 - Land Services

1.3.6.1.4.1.61026.6 - Documents & Certificates
   ├── 1.3.6.1.4.1.61026.6.1 - Identity Documents
   ├── 1.3.6.1.4.1.61026.6.2 - Business Licenses
   ├── 1.3.6.1.4.1.61026.6.3 - Tax Certificates
   ├── 1.3.6.1.4.1.61026.6.4 - Export/Import Documents
   └── 1.3.6.1.4.1.61026.6.5 - Property Documents
 
OID Assignment Process
text
text
1. Registration Request → 2. Validation → 3. OID Generation → 4. Publication → 5. Monitoring
 
OID Schema Design
sql
sql
CREATE TABLE oid_registry (
    oid VARCHAR(255) PRIMARY KEY,  -- Full OID string
    parent_oid VARCHAR(255),       -- Parent OID
    oid_type VARCHAR(50),          -- citizen, business, place, etc.
    entity_id VARCHAR(100),        -- Internal entity ID
    display_name VARCHAR(255),     -- Human-readable name
    metadata JSONB,                -- Additional attributes
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    status VARCHAR(20) DEFAULT 'active',
    INDEX idx_parent (parent_oid),
    INDEX idx_type (oid_type),
    INDEX idx_entity (entity_id)
);

CREATE TABLE oid_resolution (
    oid VARCHAR(255) PRIMARY KEY,
    resolution_data JSONB,         -- Resolved entity data
    last_resolved TIMESTAMP,
    resolution_count BIGINT DEFAULT 0,
    ttl_hours INTEGER DEFAULT 24   -- Cache TTL
);
 
TECHNOLOGY STACK
 
Backend Services
text
text
Microservices Framework: Spring Boot (Java) / Node.js
API Gateway: Kong / Nginx Plus
Service Discovery: Consul / Eureka
Message Queue: Apache Kafka / RabbitMQ
Container Orchestration: Kubernetes / Docker Swarm
 
Database Layer
text
text
Primary Database: PostgreSQL 14+ (ACID compliance)
Document Store: MongoDB (for audit logs)
Cache: Redis Cluster (session, OID resolution)
Object Storage: MinIO / AWS S3 (documents, backups)
 
Security Layer
text
text
Identity Provider: Keycloak / Auth0
Encryption: TLS 1.3, AES-256 for data at rest
Key Management: HashiCorp Vault
Security Scanning: SonarQube, OWASP ZAP
 
Monitoring & Observability
text
text
Logging: ELK Stack (Elasticsearch, Logstash, Kibana)
Metrics: Prometheus + Grafana
Tracing: Jaeger / Zipkin
Uptime Monitoring: UptimeRobot / Pingdom
 
DETAILED COMPONENT ARCHITECTURE
 
1. OID Registry Service
text
text
Purpose: Central repository for OID assignments and resolution
Components:
  - OID Generator: Creates unique OIDs based on hierarchy
  - OID Resolver: Translates OID to entity data
  - OID Validator: Ensures OID compliance
  - OID Manager: CRUD operations on OID tree

API Endpoints:
  POST /api/v1/oid/register - Register new OID
  GET /api/v1/oid/{oid} - Resolve OID
  GET /api/v1/oid/{oid}/metadata - Get metadata
  PUT /api/v1/oid/{oid}/status - Update status
  GET /api/v1/oid/search - Search OIDs

Performance: 10,000 OID resolutions/second
Availability: 99.99% (multi-region replication)
 
2. Identity Management Service
text
text
Purpose: Manage citizen and business identities
Components:
  - Registration Engine: Handles new registrations
  - Verification Engine: Biometric and document verification
  - De-duplication Engine: Prevents duplicate identities
  - Lifecycle Manager: Status changes (active, suspended, archived)

Data Model:
  Citizen:
    - OID (linked to 1.3.6.1.4.1.61026.2.*)
    - Biometric hashes (fingerprint, face)
    - Demographics (name, DOB, gender, address)
    - Family relationships (parent, spouse, children)

  Business:
    - OID (linked to 1.3.6.1.4.1.61026.3.*)
    - Registration details
    - Tax ID
    - Shareholder information
    - Operational status
 
3. API Gateway & Security
text
text
Authentication: OAuth 2.0 + OpenID Connect
Authorization: RBAC (Role-Based Access Control)
Rate Limiting: Per-user and per-service limits
Request Validation: Schema validation, input sanitization
CORS Management: Controlled cross-origin access
 
4. Integration Layer
text
text
Adapter Pattern for Agency Systems:
  - Civil Registry Adapter: SOAP/REST integration
  - Tax Authority Adapter: File-based integration (CSV/XML)
  - Customs Adapter: EDI messages
  - Land Registry Adapter: Database connector

Data Transformation:
  - ETL Pipeline: Apache NiFi / Airflow
  - Data Mapping: Custom transformation rules
  - Validation: Business rules engine
  - Scheduling: Cron-based or event-driven
 
5. Audit & Compliance Service
text
text
Purpose: Comprehensive audit trail for all operations
Components:
  - Audit Logger: All CRUD operations
  - Access Tracker: Who accessed what, when
  - Change Tracker: Data modifications history
  - Compliance Checker: Policy enforcement

Storage: Immutable log storage (WORM - Write Once Read Many)
Retention: 7 years minimum
Access: Read-only for auditors, restricted for others
 
SECURITY ARCHITECTURE
 
Zero-Trust Implementation
text
text
1. Identity Verification: Every request authenticated
2. Least Privilege: Minimal required permissions
3. Micro-segmentation: Network isolation between services
4. Continuous Monitoring: Real-time threat detection
5. Encryption: End-to-end encryption for sensitive data
 
Data Protection Measures
text
text
Encryption:
  - At Rest: AES-256 with customer-managed keys
  - In Transit: TLS 1.3 with perfect forward secrecy
  - Field-level: For PII (Personally Identifiable Information)

Access Controls:
  - Multi-factor authentication for admin access
  - Time-based access for sensitive operations
  - Geographic restrictions for high-risk operations

Privacy by Design:
  - Data minimization (collect only what's needed)
  - Purpose limitation (use only for stated purpose)
  - Retention policies (automatic deletion after period)
 
SCALABILITY & PERFORMANCE
 
Load Distribution
text
text
Expected Load (Year 1):
- Concurrent users: 10,000 (peak)
- Daily registrations: 5,000 citizens, 500 businesses
- API calls: 1 million/day
- OID resolutions: 500,000/day

Scaling Strategy:
- Horizontal scaling: Auto-scaling groups
- Database sharding: By state/region
- Caching: Redis for frequent OID resolutions
- CDN: For static assets (mobile apps, documents)
 
Performance Targets
text
text
Response Times:
- OID Resolution: < 50ms (cached), < 200ms (uncached)
- Identity Verification: < 2 seconds
- API Gateway: < 100ms
- Page Load (Mobile): < 3 seconds

Availability:
- Core Services: 99.99%
- API Gateway: 99.99%
- Database: 99.95%
- Overall System: 99.9%
 
DISASTER RECOVERY & BUSINESS CONTINUITY
 
Recovery Objectives
text
text
RTO (Recovery Time Objective): 4 hours for critical systems
RPO (Recovery Point Objective): 15 minutes data loss maximum

Backup Strategy:
- Real-time replication: Cross-region database replication
- Daily backups: Full system backups to off-site storage
- Hourly transaction logs: For point-in-time recovery
- Weekly cold storage: Archived for compliance
 
Failover Mechanisms
text
text
1. Database: PostgreSQL streaming replication (1 primary, 2 replicas)
2. Application: Kubernetes auto-healing pods
3. Network: Multiple ISP connections with BGP failover
4. Data Center: Active-passive with 100km separation
5. CDN: Multi-CDN for static content
 
DEPLOYMENT ARCHITECTURE
 
Environment Strategy
text
text
Development: Feature branches, automated testing
Staging: Mirror of production, UAT environment
Production: Multi-region deployment (Khartoum + Port Sudan)

Deployment Pipeline:
1. Code commit → 2. Automated tests → 3. Build → 4. Security scan → 5. Deploy to staging → 6. UAT → 7. Production deploy (blue-green)
 
Infrastructure as Code
text
text
Tools: Terraform for infrastructure, Ansible for configuration
Cloud Provider: Multi-cloud (AWS + Azure for redundancy)
Container Registry: Private registry with vulnerability scanning
 
INTEGRATION STANDARDS
 
API Standards
text
text
Protocol: RESTful APIs with JSON
Authentication: OAuth 2.0 (JWT tokens)
Versioning: URL versioning (v1, v2)
Documentation: OpenAPI 3.0 / Swagger
Rate Limiting: X-RateLimit headers
Error Handling: Standard error responses (HTTP status codes + JSON)
 
Data Exchange Formats
text
text
Internal: JSON for APIs, Protocol Buffers for high-performance
External: XML for legacy systems, CSV for bulk data
Standards: UN/EDIFACT for customs, ISO 20022 for financial
 
MOBILE & ACCESSIBILITY ARCHITECTURE
 
Multi-Channel Access
text
text
Web Portal: Responsive design (Bootstrap), PWA capabilities
Mobile App: React Native (iOS/Android)
USSD: For basic phones (*123# style menu)
SMS: For notifications and verification
Voice: IVR system for illiterate users
 
Offline Capability
text
text
Progressive Web App: Service workers for offline functionality
Local Storage: Encrypted local storage for sensitive data
Sync Strategy: Conflict-free replicated data types (CRDTs)
 
IMPLEMENTATION ROADMAP
 
Phase 1: Foundation (Months 1-3)
OID registry service (MVP)
Basic identity management
API gateway setup
Security baseline
 
Phase 2: Core (Months 4-6)
Full OID system implementation
Integration with 2 agencies
Mobile application
Audit system
 
Phase 3: Integration (Months 7-9)
All 5 agency integrations
Advanced verification (biometric)
Performance optimization
Disaster recovery setup
 
Phase 4: Optimization (Months 10-12)
Scaling improvements
Advanced analytics
Security hardening
Production readiness
 
END OF TECHNICAL ARCHITECTURE BLUEPRINT
 
 
5. FUNDING PROPOSAL TEMPLATE FOR INTERNATIONAL PARTNERS
 
PROPOSAL COVER PAGE
 
Project Title
Sudan Government Digital Unified System (SGDUS) - Phase 1: Foundation & Pilot Implementation
 
Submission Date
[Date]
 
Submitted To
[Partner Organization Name] [Department/Program Name] [Address]
 
Submitted By
Project Title: Sudan Government Digital Unified System (SGDUS) Implementing Agency: [Ministry of Communications & IT, Sudan] Project Director: [Name, Contact] Partnership Coordinator: [Name, Contact]
 
EXECUTIVE SUMMARY
 
Project Overview
The Sudan Government Digital Unified System (SGDUS) is a transformative initiative to create an integrated digital identity and service delivery platform that will uniquely identify all citizens, businesses, and government entities in Sudan through a unified OID-based system. Phase 1 will establish the foundational infrastructure and pilot key services in Khartoum State.
 
Funding Request
Total Phase 1 Budget:
15
,
900
,
000
∗
∗
R
e
q
u
e
s
t
t
o
[
P
a
r
t
n
e
r
]
:
∗
∗
15,900,000∗∗Requestto[Partner]:∗∗[Amount] ([Percentage]% of total) Project Duration: 12 months Expected Impact:
500,000 citizens registered digitally
25% increase in formal business registrations
50% reduction in service processing time
Foundation for nationwide digital transformation
 
Alignment with Partner Priorities
Digital Development: Directly supports digital economy growth
Governance Reform: Enhances transparency and efficiency
Economic Inclusion: Brings informal sector into formal economy
SDG Alignment: Supports SDGs 8, 9, 16, and 17
 
1. PROJECT BACKGROUND & RATIONALE
 
Current Situation Analysis
Challenges:
Fragmented government systems (30+ agencies with separate databases)
Manual processes requiring 15+ days for business registration
Limited digital access (40% internet penetration, urban-rural divide)
Identity fraud and duplication issues
Inefficient resource allocation due to poor data
 
Opportunities:
Young population (70% under 30) with increasing digital literacy
Mobile penetration exceeding 70%
Political commitment to digital transformation
Successful models from Estonia, India, UAE for adaptation
 
Project Justification
Economic Impact:
Reduce administrative costs by 15-20% ($50M+ annual savings)
Increase formal economy participation by 25%
Improve business environment ranking (currently 187/190 in World Bank Ease of Doing Business)
 
Social Impact:
Improved service delivery to 45 million citizens
Enhanced transparency and reduced corruption
Better targeting of social programs
Empowerment through digital access
 
2. PROJECT OBJECTIVES & EXPECTED OUTCOMES
 
Primary Objectives
1.Digital Identity Foundation: Establish secure digital identity for 500,000 citizens in Khartoum
2.Service Integration: Integrate 5 key government services (Civil Registry, Business Registration, Tax, Export, Land)
3.OID System: Implement unique identification system using OID standard 1.3.6.1.4.1.61026
4.Capacity Building: Train 200 government staff in digital system management
5.Scalability: Design system for nationwide expansion
 
Expected Outcomes
Short-term (12 months):
500,000 citizens with digital identity
5,000 businesses registered digitally
50% reduction in processing time for integrated services
70% user satisfaction rate
 
Medium-term (24 months):
Nationwide rollout to 5 states
5 million digital identities
10 integrated government services
ISO 27001 certification
 
Long-term (36 months):
Full national coverage
20+ integrated services
Digital economy contribution of 3% to GDP
Regional leadership in digital government
 
3. IMPLEMENTATION STRATEGY
 
Phased Approach
Phase 1: Foundation (Months 1-3)
Team formation, legal framework, requirements
Infrastructure setup, OID system design
Stakeholder engagement, partnership development
 
Phase 2: Development & Integration (Months 4-9)
Core platform development
Integration with 3 agencies
Pilot design and preparation
 
Phase 3: Pilot Launch & Evaluation (Months 10-12)
Soft launch (1,000 users)
Full pilot (500,000 users)
Evaluation and Phase 2 planning
 
Key Strategies
1.Agile Development: 2-week sprints with continuous feedback
2.User-Centric Design: Co-design with citizens and businesses
3.Open Standards: Use international standards for interoperability
4.Security by Design: Incorporate security at every layer
5.Change Management: Comprehensive training and communication
 
4. TECHNICAL APPROACH
 
System Architecture
Core Components:
OID Registry Service (unique identification)
Identity Management Module
API Gateway for integration
Multi-channel access (web, mobile, USSD)
Secure cloud infrastructure (hybrid model)
 
Technology Stack
Backend: Microservices (Java/Node.js)
Database: PostgreSQL (primary), MongoDB (audit)
Security: OAuth 2.0, encryption, zero-trust
Mobile: React Native (iOS/Android)
Monitoring: Prometheus, Grafana, ELK Stack
 
Innovation Elements
1.OID-based Identification: Unique hierarchical identifiers
2.Biometric Integration: Fingerprint and facial recognition
3.Offline Capability: USSD and SMS for low-connectivity areas
4.Blockchain for Audit: Immutable transaction logs
5.AI/ML for Fraud Detection: Pattern recognition algorithms
 
5. BUDGET & FINANCIAL PLAN
 
Detailed Budget Breakdown
 
Category	Amount (USD)	Percentage	Partner Contribution	Government Contribution
Infrastructure	$4,000,000	25%	$1,600,000	$2,400,000
Software Development	$3,500,000	22%	$1,400,000	$2,100,000
Personnel	$3,000,000	19%	$1,200,000	$1,800,000
Legal & Compliance	$1,200,000	7.5%	$480,000	$720,000
Training & Capacity	$1,000,000	6.25%	$400,000	$600,000
Marketing & Outreach	$800,000	5%	$320,000	$480,000
Contingency (15%)	$2,400,000	15%	$960,000	$1,440,000
TOTAL	$15,900,000	100%	$6,360,000 (40%)	$9,540,000 (60%)
 
Funding Sources
1.
Government of Sudan: $9.54M (60%)
Ministry of Communications & IT: $4M
Other ministries: $3M
In-kind contributions (office space, staff): $2.54M
2.
International Partners: $6.36M (40%)
UNDP: $2M
World Bank: $2M
Other donors: $2.36M
 
Expenditure Schedule
text
text
Quarter 1: $3M (20%) - Planning, team, infrastructure
Quarter 2: $5M (31%) - Development, design
Quarter 3: $4.5M (28%) - Integration, testing
Quarter 4: $3.4M (21%) - Pilot, evaluation
 
6. GOVERNANCE & MANAGEMENT STRUCTURE
 
Project Governance
text
text
Steering Committee (Monthly)
├── Chair: Prime Minister's Office
├── Members: Ministers (Communications, Interior, Trade, Finance)
├── International Partners: UNDP, World Bank
└── Authority: Budget approval, scope changes

Technical Committee (Bi-weekly)
├── Chair: Project Director
├── Members: Ministry CTOs, Technical Lead
└── Authority: Technical decisions

Project Management Office (Weekly)
├── Chair: Project Director
├── Members: Core team leads
└── Authority: Day-to-day execution
 
Risk Management
Key Risks & Mitigation:
1.Political Instability: Multi-party support, phased approach
2.Funding Delays: Diversified sources, contingency fund
3.Technical Challenges: International experts, agile development
4.Adoption Resistance: Change management, incentives
5.Security Threats: Security-by-design, regular audits
 
Monitoring & Evaluation
KPIs:
User registration numbers
Service processing times
System uptime (99.9% target)
User satisfaction scores
Cost per registration
 
Reporting:
Monthly progress reports
Quarterly financial reports
Mid-term review (Month 6)
Final evaluation (Month 12)
 
7. SUSTAINABILITY & EXIT STRATEGY
 
Sustainability Plan
Financial Sustainability:
Fee structure for premium services (business registrations)
Government budget allocation for ongoing operations
Public-private partnerships for maintenance
Cost recovery through efficiency gains
 
Institutional Sustainability:
Dedicated agency for digital government (proposed)
Career development paths for trained staff
Integration with national ICT strategy
Regional cooperation for knowledge sharing
 
Technical Sustainability:
Open-source components where possible
Local vendor partnerships
Regular system updates and upgrades
Disaster recovery capabilities
 
Exit Strategy
Phase 1 Exit (Month 12):
Handover to operational team
Documentation and training completion
Evaluation report and Phase 2 recommendations
 
Phase 2 Transition:
Gradual scaling to other states
Reduced donor dependency
Full government ownership
 
8. PARTNERSHIP VALUE PROPOSITION
 
For the Partner Organization
1.Demonstrable Impact: Clear metrics and outcomes
2.Model for Replication: Potential for other countries
3.Capacity Building: Transfer of knowledge and skills
4.Strategic Alignment: Direct contribution to SDGs
5.Recognition: Co-branding and visibility
 
For Sudan
1.Digital Transformation: Foundation for modern government
2.Economic Growth: Improved business environment
3.Social Inclusion: Better service delivery
4.Capacity Building: Local expertise development
5.Regional Leadership: Potential for knowledge export
 
Mutual Benefits
Knowledge Exchange: Learning from Sudan's context
Innovation Testing: New approaches in challenging environment
Network Building: Regional digital government community
Long-term Partnership: Foundation for future collaboration
 
9. IMPLEMENTATION TIMELINE
 
Gantt Chart Summary
text
text
Month 1-2: Project setup, team formation, legal framework
Month 3: Infrastructure, OID design, stakeholder workshops
Month 4-6: Core development, identity module
Month 7-8: Agency integration (3 agencies)
Month 9: Testing, security audit, UAT
Month 10: Soft launch (1,000 users)
Month 11: Full pilot launch (500,000 users)
Month 12: Evaluation, lessons learned, Phase 2 planning
 
Milestones & Deliverables
1.Month 3: Project charter approved, team in place
2.Month 6: Core platform alpha, integration agreements
3.Month 9: Beta version ready, security audit passed
4.Month 12: Pilot launched, 500,000 users, evaluation report
 
10. ANNEXES
 
Annex A: Detailed Budget Breakdown
[Attach spreadsheet with line items]
 
Annex B: Logical Framework (LogFrame)
Narrative Summary	Indicators	Means of Verification	Assumptions
Goal: Enhanced digital government services	500,000 citizens with digital ID	Registration database	Political stability
Outcomes: Integrated services, trained staff	5 services integrated, 200 staff trained	Service logs, training records	Agency cooperation
Outputs: System developed, pilot launched	System operational, pilot metrics	System logs, pilot report	Technical feasibility
 
Annex C: Team CVs
[Key personnel profiles]
 
Annex D: Letters of Support
[From government agencies, civil society]
 
Annex E: Legal Framework Analysis
[Current laws, required amendments]
 
Annex F: Risk Assessment Matrix
[Detailed risk register]
 
Annex G: Sustainability Plan
[Detailed financial and institutional sustainability]
 
11. SUBMISSION CHECKLIST
 
 Executive Summary
 Project Background & Rationale
 Objectives & Expected Outcomes
 Implementation Strategy
 Technical Approach
 Budget & Financial Plan
 Governance Structure
 Sustainability Plan
 Partnership Value Proposition
 Implementation Timeline
 All Annexes
 Letters of Support
 Organizational Capacity Statement
 
12. CONTACT INFORMATION
 
Project Director: [Name] Email: [Email] Phone: [Phone] Address: [Ministry of Communications & IT, Khartoum, Sudan]
 
Partnership Coordinator: [Name] Email: [Email] Phone: [Phone]
 
For technical inquiries: [Technical Lead Name, Email] For financial inquiries: [Finance Lead Name, Email]
 
 
SUBMISSION INSTRUCTIONS
 
1.Format: PDF document with searchable text
2.Language: English and Arabic versions
3.Deadline: [Date]
4.Submission Method: [Email/Portal/Physical]
5.Follow-up: Will be available for questions and clarifications
 
 
END OF FUNDING PROPOSAL TEMPLATE
 
 
SUMMARY OF DELIVERABLES PROVIDED
 
I have now provided all five requested deliverables:
 
1.Detailed Work Breakdown Structure (WBS) - Comprehensive 3-level structure for Phase 1
2.Stakeholder Engagement Plan - With specific communication strategies by group
3.Risk Register - Comprehensive risk identification and mitigation plans
4.Technical Architecture Blueprint - Detailed OID system architecture
5.Funding Proposal Template - Complete template for international partners
 
Each deliverable is designed to be immediately actionable and aligned with the Project Charter created earlier. They provide a complete foundation for executing the Sudan Government Digital Unified System (SGDUS) project.
 
Next Steps:
1.Review and customize each document with specific Sudanese context
2.Present to Steering Committee for approval
3.Begin implementation of Phase 1 activities
4.Seek specific funding from identified partners
 
Would you like me to elaborate on any specific section or provide additional details on any of these deliverables?
Yes please all one by one: Review and customize each document with specific Sudanese context
2.Present to Steering Committee for approval
3.Begin implementation of Phase 1 activities
4.Seek specific funding from identified partners

STEP 1: REVIEW AND CUSTOMIZE EACH DOCUMENT WITH SPECIFIC SUDANESE CONTEXT
 
CUSTOMIZATION FRAMEWORK FOR ALL DOCUMENTS
 
A. Sudan-Specific Legal & Regulatory Context
 
1. Current Legal Framework to Incorporate
text
text
Existing Laws to Reference:
- Electronic Transactions Act, 2007 (Amended 2018)
- National Civil Registry Act, 1994
- Business Registration Act, 2015
- Tax Administration Act, 2018
- Data Protection Act (Under development - reference UNDP support)
- Cybersecurity Act (Draft stage)

Required Amendments for Project:
1. Digital Identity Recognition Law
2. Inter-Agency Data Sharing Framework
3. Digital Signature and Authentication Law
4. Privacy and Data Protection Regulation
 
2. Sudanese Administrative Structure to Map
text
text
Geographic Hierarchy:
- 18 States (including Khartoum, Port Sudan, Darfur states)
- 133 Localities (districts)
- 425+ Counties (sub-districts)

Government Structure:
- Federal level (Khartoum)
- State level (18 states)
- Local level (localities, counties)

Key Agencies for Integration:
1. Ministry of Interior (Civil Registry Department)
2. Ministry of Trade and Industry (Business Registration)
3. National Tax Authority
4. Customs Authority (Port Sudan)
5. Ministry of Land and Housing
6. Ministry of Health (for birth registration)
7. Ministry of Education (for student IDs)
 
B. Cultural & Social Context Integration
 
1. Language Considerations
text
text
Primary Languages:
- Arabic (official language, used in all documents)
- English (technical documents, international communications)
- Local Languages (Dinka, Nuer, Fur, etc.) for community outreach

Translation Strategy:
- All citizen-facing materials in Arabic
- Technical documents in English and Arabic
- USSD menus in Arabic and English
- Mobile apps: Arabic first, with English option
 
2. Digital Literacy & Access Patterns
text
text
Current Statistics (as of 2025):
- Internet penetration: ~40% (higher in urban areas)
- Mobile penetration: ~75%
- Smartphone penetration: ~45%
- Digital literacy: ~35% of adult population
- Rural-urban divide: 30% rural vs 60% urban internet access

Adaptation Strategy:
- Multi-channel approach (USSD, SMS, mobile apps, web)
- Community access points in rural areas
- Partnership with telecom providers for zero-rated services
- Voice-based interfaces for low-literacy users
 
3. Business Environment Context
text
text
Sudanese Business Landscape:
- Dominated by SMEs (80% of businesses)
- Significant informal sector (estimated 50% of economy)
- Key sectors: Agriculture, trade, services, manufacturing
- Challenges: Bureaucracy, limited digital access, currency issues

Customization for Business Portal:
- Simplified registration for small businesses
- Arabic language support for all forms
- Integration with traditional business associations
- Mobile-friendly for traders and small business owners
 
C. Document-Specific Customization
 
1. Project Charter Customization
text
text
Add Sudan-Specific Elements:
- Reference to Sudan's Digital Transformation Strategy 2025-2030
- Alignment with Sudan's Vision 2030
- Inclusion of Sudanese public holidays and working calendar
- Use of Sudanese currency (Sudanese Pound - SDG) in budget
- Reference to specific Sudanese ministries and agencies

Key Customizations:
- Project Name: Keep as "Sudan Government Digital Unified System (SGDUS)"
- Location: Specify Khartoum State + Port Sudan pilot
- Stakeholders: List actual Sudanese ministers and agency heads
- Budget: Convert USD to SDG using current exchange rate (approx 1 SDG = 0.0017 USD)
 
2. WBS Customization
text
text
Sudan-Specific Work Packages:
1.1.5: Establish Sudanese public holiday schedule for project timeline
2.1.2: Design for Sudan's limited fiber optic infrastructure
3.1.1: Conduct workshops in Sudanese Arabic dialect
4.2.3: Integrate with Sudan's existing biometric systems (if any)
5.1.1: Map to Sudan's 18 states and 133 localities
8.2.3: Engage Sudanese tribal and community leaders
10.1.3: Partner with Sudanese telecom providers (MTN, Zain, Sudani)

Sudan-Specific Milestones:
- Month 1: Eid al-Fitr holiday adjustment
- Month 3: Ramadan considerations for working hours
- Month 6: Eid al-Adha holiday
- Month 9: Independence Day (January 1) - potential launch date
 
3. Stakeholder Engagement Plan Customization
text
text
Sudanese Stakeholder Map:
- Executive: Prime Minister (currently Mr. Osman Hussein)
- Minister of Communications & IT (current: Mr. Talal Ahmed)
- Minister of Interior (current: Mr. Ali Karti)
- Minister of Trade (current: Mr. Ahmed Sadiq)
- UNDP Sudan: Country Director (current: Dr. Aida M. Al-Amin)
- World Bank: Country Manager (current: Mr. Hervé L. B. Lemoine)

Sudanese Communication Channels:
- Traditional: Radio (Sudan Radio, local stations), TV (Sudan TV)
- Digital: Facebook (widely used), WhatsApp, Telegram
- Community: Mosques, churches, community centers
- Government: State radio, local administration offices

Sudanese Engagement Calendar (2026):
- January: Independence Day activities
- April: Ramadan (reduced working hours)
- May: Eid al-Fitr
- July: Eid al-Adha
- September: Islamic New Year
- November: Prophet's Birthday
 
4. Risk Register Customization
text
text
Sudan-Specific Risks:
1. **Political Transition Risk**: High (ongoing transitional government)
   - Mitigation: Engage multiple political factions, ensure bipartisan support

2. **Infrastructure Challenges**: High (limited electricity, internet)
   - Mitigation: Solar-powered community access points, offline-first design

3. **Currency Instability**: High (inflation, exchange rate volatility)
   - Mitigation: USD-denominated contracts, quarterly budget reviews

4. **Regional Security Issues**: Medium (Darfur, South Kordofan)
   - Mitigation: Phased rollout starting with stable states

5. **Digital Divide**: Very High (rural-urban, gender)
   - Mitigation: Mobile-first, USSD-based, women-focused training

6. **Data Sovereignty Concerns**: Medium
   - Mitigation: On-premise servers for sensitive data, hybrid cloud
 
5. Technical Architecture Customization
text
text
Sudan-Specific Technical Adaptations:
1. **Connectivity**: Design for intermittent connectivity
   - USSD/SMS as primary channels in rural areas
   - Offline-capable mobile apps
   - Sync when connection available

2. **Infrastructure**: Hybrid approach
   - Cloud for scalability (consider UAE/Saudi providers for regional compliance)
   - On-premise for sensitive data (Sudanese government servers)
   - Edge computing for remote areas

3. **Biometric Systems**: Integration with existing systems
   - Check if Sudan has existing biometric systems (e.g., voter registration)
   - Use standardized formats (ISO/IEC 19794) for interoperability

4. **OID Implementation**:
   - Root: 1.3.6.1.4.1.61026 (already assigned)
   - State-level OIDs: 1.3.6.1.4.1.61026.1.1.[state code]
   - Example: Khartoum State = 1.3.6.1.4.1.61026.1.1.1
   - Port Sudan = 1.3.6.1.4.1.61026.1.1.2
 
6. Funding Proposal Customization
text
text
Sudan-Specific Funding Strategy:
1. **Government Contribution**:
   - Ministry of Communications & IT budget allocation
   - In-kind contributions: Office space, existing infrastructure
   - Staff secondments from ministries

2. **International Partners**:
   - UNDP Sudan: Existing digital governance programs
   - World Bank: Digital Development Partnership
   - African Development Bank: Infrastructure support
   - Islamic Development Bank: Sharia-compliant financing
   - UAE/Saudi Arabia: Regional development funds

3. **Private Sector**:
   - Telecom providers: Network access, USSD channels
   - Banks: Financial inclusion, digital payments
   - Local tech companies: Development partners

Sudan-Specific Value Proposition:
- Alignment with Sudan's post-conflict reconstruction
- Support for economic sanctions relief through transparency
- Job creation for youth (70% population under 30)
- Enhanced revenue collection (critical for fiscal stability)
 
D. Implementation of Customization
 
1. Document Review Process
text
text
Week 1-2: Sudanese Context Workshop
- Participants: Local experts, government officials, civil society
- Output: Context analysis report

Week 3-4: Document Customization
- Team: Project team + Sudanese advisors
- Tools: Collaborative editing platform
- Review: Legal review by Sudanese lawyers

Week 5-6: Validation
- Stakeholder review: Key agencies and partners
- Feedback incorporation
- Final version preparation
 
2. Quality Assurance
text
text
Checklist for Customization:
- [ ] All documents reference Sudanese laws and regulations
- [ ] Currency converted to Sudanese Pound (SDG) with USD equivalent
- [ ] Sudanese holidays and working calendar incorporated
- [ ] Local language considerations addressed
- [ ] Cultural norms respected (gender considerations, tribal structures)
- [ ] Infrastructure constraints acknowledged
- [ ] Political context appropriately handled
- [ ] Local partnerships identified and integrated
 
END OF STEP 1 CUSTOMIZATION GUIDE
 
 
STEP 2: PRESENT TO STEERING COMMITTEE FOR APPROVAL
 
STEERING COMMITTEE PRESENTATION STRUCTURE
 
A. Pre-Meeting Preparation
 
1. Committee Composition
text
text
Proposed Steering Committee (Sudan Context):
Chair: Prime Minister's Office Representative (or Deputy PM)
Members:
1. Minister of Communications & IT (Project Sponsor)
2. Minister of Interior (Civil Registry)
3. Minister of Trade and Industry (Business Services)
4. Minister of Finance (Budget Oversight)
5. Minister of Justice (Legal Framework)
6. UNDP Sudan Country Director (International Partner)
7. World Bank Country Manager (Technical Partner)
8. 2 Private Sector Representatives (Chambers of Commerce)
9. Civil Society Representative (Transparency Sudan)

Observers:
- Project Director (non-voting)
- Technical Lead (non-voting)
- International Experts (non-voting)
 
2. Pre-Meeting Engagement
text
text
30 Days Before Meeting:
- Individual briefings with each minister
- Written summaries sent to all members
- Pre-read package (Project Charter, Business Case, Budget)
- One-on-one meetings with UNDP and World Bank

15 Days Before Meeting:
- Circulate draft agenda
- Collect preliminary questions and concerns
- Adjust presentation based on feedback

7 Days Before Meeting:
- Final presentation package distributed
- Rehearsal with project team
- Logistics confirmation (venue, translation, technology)
 
B. Presentation Agenda (Half-Day Workshop)
 
Session 1: Opening & Context (30 minutes)
text
text
09:00-09:15: Welcome & Opening Remarks
- Chair (PMO Representative)
- Acknowledge importance of digital transformation
- Reference Sudan's Vision 2030 and Digital Strategy

09:15-09:30: Project Context & Urgency
- Current state of government services in Sudan
- Economic and social impact of digital divide
- Success stories from similar countries (Estonia, India, UAE)
- Sudan's opportunity to leapfrog
 
Session 2: Project Presentation (60 minutes)
text
text
09:30-10:00: Project Overview & Objectives
- Vision: Unified digital identity and services
- Scope: Phase 1 - Khartoum + Port Sudan pilot
- Objectives: 500,000 citizens, 5 services integrated
- Timeline: 12 months, 3 phases

10:00-10:30: Technical Solution & OID System
- OID structure (1.3.6.1.4.1.61026) explanation
- Multi-channel access (USSD, mobile, web)
- Security and privacy approach
- Integration with existing systems

10:30-11:00: Budget & Resources
- Total budget: $15.9M (SDG equivalent: ~9.35 billion SDG)
- Funding sources: Government 60%, Partners 40%
- Phased expenditure: $3M Q1, $5M Q2, etc.
- Contingency: 15% ($2.4M)
 
Session 3: Sudanese Context & Customization (45 minutes)
text
text
11:00-11:30: Sudan-Specific Adaptations
- Legal framework alignment (Electronic Transactions Act, etc.)
- Infrastructure considerations (connectivity, power)
- Cultural and social adaptations (language, literacy)
- Risk mitigation for Sudanese context

11:30-11:45: Implementation Plan
- Phase 1 activities (WBS summary)
- Key milestones (Month 3, 6, 9, 12)
- Critical success factors
- Exit strategy and sustainability
 
Session 4: Discussion & Decision (45 minutes)
text
text
11:45-12:15: Q&A and Clarifications
- Address specific concerns
- Discuss risks and mitigations
- Review budget breakdown
- Discuss governance structure

12:15-12:30: Approval Process
- Formal motion for approval
- Voting procedure
- Next steps if approved
- Action items if deferred
 
C. Presentation Materials
 
1. Executive Summary (2 pages)
markdown
markdown
# SGDUS Phase 1: Executive Summary for Steering Committee

## 1. Project Essence
A unified digital platform that will give every Sudanese citizen and business a unique digital identity, enabling access to all government services through a single system.

## 2. Sudanese Context
- 45 million citizens, 40% digital access
- 15+ days for business registration currently
- Opportunity to leapfrog digital divide

## 3. Phase 1 (12 months)
- Pilot: Khartoum + Port Sudan
- 500,000 citizens registered
- 5 services integrated
- Budget: $15.9M (60% government, 40% partners)

## 4. Key Benefits
- Economic: 15-20% cost reduction, 25% more formal businesses
- Social: Better services, transparency, inclusion
- Strategic: Foundation for digital economy

## 5. Approval Requested
- Project Charter approval
- Budget allocation ($9.54M government share)
- Agency commitments for data sharing
- Nomination of Steering Committee members
 
2. Visual Aids
text
text
Slide 1: Sudan's Digital Opportunity
- Map of Sudan with connectivity gaps
- Statistics: Internet penetration, mobile access
- Comparison with regional neighbors

Slide 2: Project Vision
- Infographic of unified system
- Citizen journey: from birth to business
- OID structure visualization

Slide 3: Phase 1 Pilot Areas
- Khartoum State (map with districts)
- Port Sudan (map with free zone)
- Population coverage: 500,000 target

Slide 4: Budget Breakdown (SDG)
- Visual pie chart with SDG amounts
- Government vs. partner contribution
- Quarterly expenditure

Slide 5: Governance Structure
- Organizational chart
- Decision-making flow
- Agency responsibilities

Slide 6: Risk Mitigation (Sudan-specific)
- High risks and mitigation strategies
- Contingency plans
- Success metrics
 
3. Decision Package
text
text
For Committee Members:
1. Project Charter (15 pages)
2. Business Case (10 pages)
3. Budget Breakdown (5 pages + spreadsheet)
4. Risk Register (5 pages)
5. Implementation Timeline (Gantt chart)
6. Letters of Support (from agencies)
7. Legal Opinion (on framework)
8. Technical Architecture Summary (3 pages)

Decision Forms:
- Approval Form (with signature lines)
- Action Items Form
- Budget Release Form
- Agency Commitment Form
 
D. Presentation Strategy
 
1. Stakeholder-Specific Messaging
text
text
For Prime Minister's Office:
- National impact and legacy
- Regional leadership potential
- Alignment with national priorities

For Ministry of Communications:
- Technical achievement
- International recognition
- Capacity building for staff

For Ministry of Interior:
- Civil registry modernization
- Reduced fraud
- Improved service delivery

For Ministry of Trade:
- Business environment improvement
- Increased tax base
- Ease of doing business ranking

For Ministry of Finance:
- Cost savings
- Revenue enhancement
- Budget efficiency

For UNDP/World Bank:
- SDG alignment (8, 9, 16, 17)
- Replicability potential
- Capacity development
 
2. Addressing Potential Concerns
text
text
Common Concerns & Responses:
1. "Cost is too high"
   - Response: Compare to current inefficiencies, ROI analysis
   - Data: Current administrative costs, potential savings

2. "Technical complexity"
   - Response: Phased approach, international expertise, proven models
   - Examples: Estonia, India, UAE

3. "Political instability"
   - Response: Multi-party support, bipartisan approach, short-term wins
   - Strategy: Start with non-controversial services

4. "Digital divide"
   - Response: Multi-channel access, USSD for basic phones, community points
   - Plan: Phased expansion to rural areas

5. "Data privacy concerns"
   - Response: Privacy-by-design, legal framework, independent oversight
   - Measures: Encryption, access controls, audit trails
 
E. Post-Meeting Actions
 
1. Immediate Follow-up (Within 24 hours)
text
text
1. Distribute meeting minutes with decisions
2. Send thank-you notes to all participants
3. Update project documents based on feedback
4. Begin preparation for Phase 1 kick-off
 
2. If Approved
text
text
Formal Approval Package:
1. Signed Project Charter
2. Budget Release Authorization
3. Agency Commitment Letters
4. Steering Committee Terms of Reference
5. Communication plan for public announcement

Next Steps:
1. Project Kick-off Meeting (within 2 weeks)
2. Team Formation (within 4 weeks)
3. Legal Framework Finalization (within 6 weeks)
4. Infrastructure Procurement (within 8 weeks)
 
3. If Deferred or Rejected
text
text
1. Request specific feedback and concerns
2. Address each concern with evidence and solutions
3. Resubmit revised proposal within 30 days
4. Consider pilot approach with smaller scope
5. Seek additional stakeholder support
 
F. Success Metrics for Presentation
 
1. Approval Metrics
text
text
Primary Success:
- Unanimous or majority approval
- Budget authorization released
- Agency commitments signed

Secondary Success:
- Positive media coverage
- Public announcement by PMO
- International partner commitment confirmed
 
2. Influence Metrics
text
text
- Number of follow-up meetings requested
- Quality of questions asked (shows engagement)
- Additional stakeholders expressing support
- Media interest and coverage
 
END OF STEP 2 PRESENTATION GUIDE
 
 
STEP 3: BEGIN IMPLEMENTATION OF PHASE 1 ACTIVITIES
 
PHASE 1 IMPLEMENTATION ROADMAP (MONTHS 1-12)
 
A. Month 1: Project Launch & Team Setup
 
Week 1-2: Official Launch
text
text
Day 1-2: Project Announcement
- Press conference with PMO and Minister of Communications
- Media release (Arabic and English)
- Social media campaign launch
- Internal announcement to all ministries

Day 3-5: Kick-off Workshop
- Participants: All steering committee members, agency heads, project team
- Agenda: Review project charter, establish working norms, assign roles
- Output: Signed commitment letters from agencies

Day 6-10: Team Onboarding
- Physical office setup (Khartoum)
- IT equipment and access
- Security clearances for team
- Initial training on project methodology
 
Week 3-4: Core Team Formation
text
text
Recruitment Priorities:
1. Project Director (local, 10+ years experience)
2. Technical Lead (local/international)
3. Legal Advisor (Sudanese lawyer with digital experience)
4. Finance Manager (experienced in donor-funded projects)
5. Change Management Lead (Sudanese, community engagement experience)

Hiring Strategy:
- Local recruitment through professional networks
- International experts through UNDP/World Bank mechanisms
- Secondments from ministries (15% time commitment)
- Consultants for specialized skills

Onboarding Plan:
- Week 1: Project introduction, Sudanese context
- Week 2: Technical training, tool setup
- Week 3: Stakeholder mapping, agency introductions
- Week 4: Initial task assignments
 
B. Month 2: Legal Framework & Infrastructure
 
Week 5-6: Legal Framework Development
text
text
Key Activities:
1. Legal Gap Analysis
   - Review existing laws (Electronic Transactions Act, etc.)
   - Identify required amendments
   - Draft digital identity recognition law
   - Develop data sharing agreements template

2. Regulatory Engagement
   - Meet with Ministry of Justice
   - Consult with National Intelligence and Security Service (NISS) on security
   - Engage with telecommunications regulator (NTRA)

3. Legal Documentation
   - Data Protection Policy (aligned with international standards)
   - Privacy Impact Assessment
   - Terms of Service for citizens and businesses
   - Agency Data Sharing Agreements (5 agencies)
 
Week 7-8: Infrastructure Procurement
text
text
Cloud Infrastructure:
- Evaluate providers: AWS, Azure, Google Cloud (regional presence)
- Consider hybrid model: Cloud + on-premise in Sudan
- Procurement process: International tender (UNDP can assist)
- Timeline: 6-8 weeks for contract and setup

Local Infrastructure:
- Office space in Khartoum (secure, with backup power)
- Network connectivity (multiple ISPs)
- Security systems (access control, surveillance)
- Backup power (generators, UPS)

Development Environment:
- Set up development servers (local or cloud)
- Configure version control (Git)
- Establish CI/CD pipeline
- Security scanning tools
 
C. Month 3: Requirements & Design
 
Week 9-10: Requirements Workshops
text
text
Civil Registry Workshop (Khartoum):
- Participants: Ministry of Interior, Civil Registry Department
- Focus: Birth registration process, family structure, existing data
- Output: Data dictionary, integration requirements

Business Registration Workshop (Khartoum):
- Participants: Ministry of Trade, Business Registration Office
- Focus: Current process (15 days), documents required, fees
- Output: Business registration workflow, integration points

Tax Authority Workshop:
- Participants: National Tax Authority
- Focus: Tax ID generation, existing tax system
- Output: Tax integration requirements, data formats

Customs Workshop (Port Sudan):
- Participants: Customs Authority, Port Sudan Free Zone
- Focus: Export/import process, documentation
- Output: Customs integration requirements

Land Registry Workshop:
- Participants: Ministry of Land and Housing
- Focus: Property registration, existing system
- Output: Land registry integration requirements
 
Week 11-12: System Design
text
text
Technical Design Sessions:
1. OID System Design
   - Finalize OID hierarchy for Sudan
   - Design OID assignment algorithm
   - Create OID resolution service architecture

2. Identity System Design
   - Citizen data model (Sudanese demographics)
   - Business data model (SME-focused)
   - Biometric integration (fingerprint, facial)

3. API Design
   - RESTful API specifications
   - Authentication/authorization design
   - Error handling and logging

4. UI/UX Design
   - Citizen portal (mobile-first)
   - Business portal (web and mobile)
   - Admin dashboard (Arabic interface)
   - USSD menu design (Arabic and English)
 
D. Months 4-6: Core Development
 
Development Sprints (2-week cycles)
text
text
Sprint 1 (Month 4):
- OID Registry Service (MVP)
- Basic identity registration API
- API Gateway setup
- Security baseline implementation

Sprint 2 (Month 4-5):
- Citizen registration module
- Business registration module
- Basic verification services
- Audit logging system

Sprint 3 (Month 5):
- Biometric integration (fingerprint)
- De-duplication engine
- USSD interface development
- Mobile app (Android first)

Sprint 4 (Month 5-6):
- API Gateway enhancements
- Rate limiting and throttling
- Performance optimization
- Security hardening

Sprint 5 (Month 6):
- Integration with Civil Registry (API)
- Integration with Business Registration (API)
- Data mapping and transformation
- Initial testing

Sprint 6 (Month 6):
- Integration with Tax Authority (file-based)
- Integration with Customs (EDI)
- User acceptance testing preparation
- Documentation updates
 
Development Team Structure
text
text
Squad 1: OID & Identity Core (6 developers)
Squad 2: API & Integration (5 developers)
Squad 3: Frontend & Mobile (5 developers)
Squad 4: Security & DevOps (4 developers)
Squad 5: QA & Testing (3 testers)

Daily Stand-ups: 15 minutes (9:00 AM)
Sprint Planning: Every 2 weeks
Sprint Review: Every 2 weeks
Retrospective: Every 2 weeks
 
E. Months 7-9: Integration & Testing
 
Integration Strategy
text
text
Phased Integration Approach:
Phase A (Month 7): Civil Registry + Business Registration
Phase B (Month 8): Tax Authority + Customs
Phase C (Month 9): Land Registry + Final Integration

Integration Methodology:
1. Agency Workshops (technical teams)
2. API Specification Finalization
3. Development of Adapters
4. Testing in Sandbox Environment
5. Production Deployment (staged)
6. Monitoring and Validation
 
Testing Strategy
text
text
Testing Phases:
1. Unit Testing (ongoing): Code-level testing
2. Integration Testing (Month 7-8): Agency system integration
3. System Testing (Month 8): End-to-end workflows
4. Performance Testing (Month 8): Load and stress testing
5. Security Testing (Month 9): Penetration testing, vulnerability assessment
6. User Acceptance Testing (Month 9): Real users in controlled environment

Sudan-Specific Testing Considerations:
- Test on low-bandwidth connections
- Test USSD functionality with major telecom providers
- Test with different mobile devices (feature phones, smartphones)
- Test with Arabic text (right-to-left display)
- Test with Sudanese names and address formats
 
F. Months 10-12: Pilot Launch & Evaluation
 
Pilot Preparation (Month 10)
text
text
Week 1-2: Pilot Design
- Select 5 hospitals in Khartoum for birth registration
- Select 5 business registration offices in Khartoum
- Select 2 locations in Port Sudan for export businesses
- Define success metrics for each service

Week 3-4: Pilot Infrastructure
- Set up pilot servers (separate from production)
- Configure monitoring and alerting
- Prepare pilot support team (20 staff)
- Develop training materials (Arabic and English)

Week 5-6: User Recruitment
- Partner with hospitals for birth registration (1,000 births/month target)
- Engage business associations for business registration
- Work with export associations in Port Sudan
- Set up pilot user support channels (helpline, WhatsApp)
 
Soft Launch (Month 10, Week 4)
text
text
Target: 1,000 users
Services: Birth registration only (civil registry)
Locations: 5 hospitals in Khartoum
Support: On-site support staff at each hospital
Feedback: Daily surveys, weekly focus groups

Success Criteria:
- 95% registration success rate
- Average registration time < 10 minutes
- User satisfaction > 4/5
- Zero critical bugs
 
Full Pilot Launch (Month 11)
text
text
Target: 500,000 users
Services: All 5 integrated services
Locations: Khartoum State + Port Sudan
Support: 24/7 helpdesk, community support points
Marketing: Radio, TV, social media, community meetings

Marketing Campaign:
- Radio: Daily spots on popular stations
- TV: 30-second commercials on Sudan TV
- Social Media: Facebook, WhatsApp, Twitter
- Community: Meetings at mosques, churches, community centers
- Incentives: First 10,000 users get free airtime
 
Evaluation & Phase 2 Planning (Month 12)
text
text
Evaluation Activities:
1. Data Collection
   - System usage statistics
   - User satisfaction surveys (random sample of 5,000 users)
   - Agency feedback (interviews with staff)
   - Cost analysis (actual vs. budget)

2. Analysis
   - Success against KPIs
   - Lessons learned
   - Technical performance assessment
   - Financial analysis

3. Reporting
   - Executive summary for Steering Committee
   - Detailed technical report
   - Financial report
   - Phase 2 recommendations

4. Phase 2 Planning
   - Scope definition (expansion to 5 more states)
   - Budget estimation
   - Timeline development
   - Partnership strategy
 
G. Monthly Governance & Reporting
 
Steering Committee Meetings (Monthly)
text
text
First Monday of each month, 9:00 AM
Duration: 3 hours
Format: In-person (Khartoum) with virtual option

Agenda Template:
1. Review of previous month's progress (15 min)
2. Key achievements and milestones (15 min)
3. Issues and risks requiring decisions (30 min)
4. Budget status and variances (15 min)
5. Upcoming month plan (15 min)
6. Decisions required (30 min)
7. Any other business (15 min)

Deliverables:
- Monthly progress report (5 pages)
- Budget variance report
- Risk register update
- Decision log
- Action items list
 
Technical Committee Meetings (Bi-weekly)
text
text
Every other Wednesday, 2:00 PM
Duration: 2 hours
Format: Hybrid (in-person + virtual)

Focus: Technical decisions, integration issues, architecture reviews
 
Project Management Office (Weekly)
text
text
Every Monday, 10:00 AM
Duration: 1 hour
Format: In-person

Focus: Task tracking, issue resolution, resource coordination
 
H. Resource Allocation & Budget Management
 
Monthly Budget Allocation (Example: Month 3)
text
text
Total Monthly Budget: ~$1.3M
- Personnel: $250,000 (20 FTEs)
- Infrastructure: $150,000 (cloud, office, connectivity)
- Development: $400,000 (tools, software, contractors)
- Integration: $200,000 (agency workshops, adapters)
- Training: $100,000 (materials, trainers)
- Contingency: $200,000
 
Resource Management Strategy
text
text
1. Human Resources
   - Local hires: 80% of team
   - International experts: 20% (technical advisors)
   - Ministry secondments: 15% time commitment
   - Contractors: Specialized skills (security, UX)

2. Financial Management
   - Separate project account (UNDP/World Bank managed)
   - Monthly financial reports to Steering Committee
   - Quarterly external audit
   - Real-time expense tracking system

3. Procurement
   - International tenders for >$50,000
   - Local procurement for < $50,000
   - UNDP procurement support for international
   - Competitive bidding process
 
I. Communication & Change Management
 
Internal Communication
text
text
Channels:
- Project Intranet: SharePoint or similar
- Weekly newsletter (Arabic and English)
- Monthly all-hands meetings
- WhatsApp group for urgent communication

Content:
- Progress updates
- Celebrations and milestones
- Challenges and solutions
- Upcoming activities
 
External Communication
text
text
Stakeholder Updates:
- Monthly to Steering Committee
- Bi-weekly to agency partners
- Quarterly to international partners
- Monthly to public (press releases, social media)

Public Communication:
- Website: www.sgdus.gov.sd (under construction)
- Social media: Facebook, Twitter, Instagram
- Radio: Monthly updates on popular stations
- Community meetings: Monthly in pilot areas
 
J. Risk Management in Execution
 
Weekly Risk Review
text
text
Every Friday, 3:00 PM
Participants: Project Director, Risk Owner, Technical Lead
Format: 1-hour review meeting

Process:
1. Review risk register (new risks, updated scores)
2. Assess mitigation effectiveness
3. Update contingency plans
4. Escalate if needed
 
Contingency Activation
text
text
Triggers:
- Risk score increases by >5 points
- Mitigation fails or is delayed
- New high-risk item emerges
- External event affects project

Process:
1. Risk owner submits contingency request
2. PMO reviews within 24 hours
3. Approval based on amount (as per charter)
4. Implementation and tracking
 
K. Success Metrics & KPIs
 
Monthly KPIs to Track
text
text
1. Schedule Performance
   - Planned vs. actual milestones
   - Critical path status

2. Budget Performance
   - Planned vs. actual expenditure
   - Variance analysis

3. Quality Metrics
   - Defect density (per 1,000 lines of code)
   - Test coverage
   - Security vulnerabilities

4. Team Performance
   - Velocity (story points completed)
   - Team satisfaction
   - Turnover rate

5. Stakeholder Satisfaction
   - Agency satisfaction score
   - Partner satisfaction score
   - User satisfaction (pilot phase)
 
END OF STEP 3 IMPLEMENTATION GUIDE
 
 
STEP 4: SEEK SPECIFIC FUNDING FROM IDENTIFIED PARTNERS
 
TARGETED FUNDING STRATEGY
 
A. Partner Identification & Prioritization
 
Tier 1 Partners (High Priority)
text
text
1. UNDP Sudan
   - Contact: Dr. Aida M. Al-Amin, Country Director
   - Potential: $2-3 million
   - Focus: Digital governance, capacity building
   - Program: Sudan Digital Transformation Program
   - Timeline: 3-4 months for approval

2. World Bank (IDA)
   - Contact: Mr. Hervé L. Lemoine, Country Manager
   - Potential: $2-3 million
   - Focus: Digital development, economic inclusion
   - Program: Digital Development Partnership
   - Timeline: 4-6 months for approval

3. African Development Bank
   - Contact: Sudan Country Office
   - Potential: $1-2 million
   - Focus: Infrastructure, digital economy
   - Program: Digital Transformation Fund
   - Timeline: 3-5 months for approval
 
Tier 2 Partners (Medium Priority)
text
text
4. Islamic Development Bank
   - Contact: Regional Office in Khartoum
   - Potential: $1-2 million
   - Focus: Sharia-compliant financing
   - Program: Digital Infrastructure Fund
   - Timeline: 4-6 months

5. UAE Development Funds
   - Contact: UAE Embassy in Khartoum
   - Potential: $1-2 million
   - Focus: Regional development, technology transfer
   - Program: UAE-Sudan Partnership Fund
   - Timeline: 2-3 months (fast-track)

6. Saudi Arabia (KSRelief/SFD)
   - Contact: Saudi Embassy in Khartoum
   - Potential: $1-2 million
   - Focus: Development assistance
   - Program: Saudi-Sudan Development Cooperation
   - Timeline: 3-4 months
 
Tier 3 Partners (Additional)
text
text
7. European Union
   - Contact: EU Delegation to Sudan
   - Potential: $500K-1M
   - Focus: Governance, human rights
   - Program: EU Sudan Support
   - Timeline: 6-8 months

8. USAID
   - Contact: USAID Sudan Mission
   - Potential: $500K-1M
   - Focus: Economic growth, governance
   - Program: Sudan Growth and Resilience
   - Timeline: 6-9 months

9. Private Sector (Corporate Social Responsibility)
   - MTN Sudan, Zain Sudan, Sudani
   - Potential: $100K-500K each
   - Focus: Connectivity, digital inclusion
   - Program: CSR initiatives
   - Timeline: 1-2 months
 
B. Proposal Development for Each Partner
 
1. UNDP Sudan Proposal
text
text
Executive Summary (Arabic and English)
- Align with UNDP Sudan Country Programme Document (2021-2025)
- Focus on SDG 16 (Peace, Justice, Strong Institutions)
- Emphasize capacity development (UNDP's core strength)

Specific Elements:
- Technical Assistance: Embedded experts (6 months)
- Capacity Building: Training 200 Sudanese staff
- Knowledge Transfer: Study visits to Estonia/India
- Sustainability: Exit strategy with government ownership

Budget Request: $2.5 million
- Personnel: $800,000 (international experts, local staff)
- Capacity Building: $600,000 (training, study visits)
- Technical Assistance: $500,000 (consultants, advisors)
- Operations: $400,000 (office, travel, communications)
- Contingency: $200,000

Timeline: 12 months (aligned with Phase 1)
Reporting: Quarterly to UNDP Country Office
 
2. World Bank Proposal
text
text
Executive Summary
- Align with World Bank Country Partnership Framework (Sudan)
- Focus on Digital Development Partnership (DDP) principles
- Emphasize economic growth and job creation

Specific Elements:
- Digital Infrastructure: Cloud infrastructure setup
- Institutional Strengthening: Legal and regulatory framework
- Private Sector Engagement: Telecom partnerships
- Results-Based Financing: Disbursements tied to milestones

Budget Request: $2 million
- Infrastructure: $800,000 (cloud, security, connectivity)
- Institutional Strengthening: $500,000 (legal framework, policy)
- Private Sector Engagement: $400,000 (partnerships, incentives)
- Monitoring & Evaluation: $200,000
- Contingency: $100,000

Financing Instrument: Grant (no repayment required)
Disbursement: Linked to milestones (Month 3, 6, 9, 12)
 
3. UAE Proposal
text
text
Executive Summary
- Align with UAE's Africa development strategy
- Focus on technology transfer and knowledge sharing
- Emphasize regional cooperation (GCC-Sudan)

Specific Elements:
- Technology Transfer: UAE smart city expertise
- Training: UAE study visits for Sudanese team
- Infrastructure: UAE cloud services (if regional)
- Partnerships: UAE private sector engagement

Budget Request: $1.5 million
- Technology Transfer: $600,000 (UAE experts, knowledge sharing)
- Training: $400,000 (study visits, workshops)
- Infrastructure: $300,000 (cloud services, equipment)
- Operations: $200,000

Timeline: 12 months
Reporting: Monthly to UAE Embassy
 
C. Proposal Submission Strategy
 
1. Submission Timeline
text
text
Month 1-2: Develop proposals for Tier 1 partners
Month 3: Submit to UNDP, World Bank, AfDB
Month 4: Follow-up meetings with Tier 1 partners
Month 5: Develop proposals for Tier 2 partners
Month 6: Submit to Islamic Dev Bank, UAE, Saudi
Month 7: Follow-up with Tier 2 partners
Month 8: Develop Tier 3 proposals (if needed)
Month 9-12: Negotiation and agreement finalization
 
2. Proposal Submission Checklist
text
text
For Each Proposal:
- [ ] Executive Summary (1 page)
- [ ] Project Description (5 pages)
- [ ] Budget Breakdown (detailed)
- [ ] Logical Framework (LogFrame)
- [ ] Risk Assessment
- [ ] Sustainability Plan
- [ ] Team CVs (key personnel)
- [ ] Letters of Support (from government)
- [ ] Organizational Capacity Statement
- [ ] Compliance with partner requirements
- [ ] Arabic and English versions
 
3. Follow-up Strategy
text
text
After Submission:
Week 1: Acknowledgement receipt
Week 2-4: Regular follow-up emails/calls
Month 2: Request for clarification (if needed)
Month 3: Technical review meeting
Month 4: Budget negotiation (if required)
Month 5: Agreement drafting
Month 6: Signing ceremony

Communication Protocol:
- Primary: Email with Arabic and English
- Secondary: Phone calls (WhatsApp for local)
- Tertiary: In-person meetings (Khartoum or partner headquarters)
- Documentation: All communication logged in project CRM
 
D. Negotiation Strategy
 
1. Key Negotiation Points
text
text
Budget Allocation:
- Be flexible on percentages but not on total
- Accept phased disbursement
- Accept milestone-based release

Reporting Requirements:
- Quarterly reports (standard for most partners)
- Financial audits (annual)
- Mid-term evaluation (Month 6)

Implementation Approach:
- Accept partner technical oversight
- Include partner branding (co-branding)
- Allow partner staff embedded in team

Sustainability:
- Commit to government ownership post-project
- Agree to knowledge transfer plan
- Accept exit strategy evaluation
 
2. Common Negotiation Challenges
text
text
Challenge 1: Partner wants more control
Solution: Agree on decision-making matrix (clear roles)

Challenge 2: Budget constraints
Solution: Propose phased approach, in-kind contributions

Challenge 3: Different timelines
Solution: Align with partner programming cycles

Challenge 4: Reporting burden
Solution: Use standardized templates, minimize duplication

Challenge 5: Risk aversion
Solution: Strong risk management plan, contingency arrangements
 
E. Agreement Management
 
1. Contract Types
text
text
UNDP: Project Document (PD) + Financial Agreement
World Bank: Grant Agreement (GA) + Project Agreement
AfDB: Grant Agreement + Technical Cooperation Agreement
UAE: Letter of Agreement + Memorandum of Understanding
 
2. Disbursement Schedule
text
text
Example: UNDP $2.5M
- Tranche 1 (20%): $500,000 upon signing (Month 2)
- Tranche 2 (30%): $750,000 upon milestone 1 (Month 3)
- Tranche 3 (30%): $750,000 upon milestone 2 (Month 6)
- Tranche 4 (20%): $500,000 upon completion (Month 12)

Milestones:
1. Project charter approved, team in place
2. Core platform alpha, integration agreements
3. Beta version ready, security audit passed
4. Pilot launched, evaluation completed
 
3. Reporting Requirements
text
text
Monthly:
- Progress report (5 pages)
- Financial report (UNDP format)
- Risk register update

Quarterly:
- Comprehensive quarterly report (15 pages)
- Financial statements (audited)
- Steering Committee minutes
- M&E data

Mid-term (Month 6):
- Mid-term evaluation report (external evaluation)
- Budget revision (if needed)
- Work plan adjustment

Final (Month 12):
- Final report (30 pages)
- Financial audit
- Impact assessment
- Lessons learned
 
F. Risk Management in Funding
 
1. Funding Risks & Mitigation
text
text
Risk 1: Partner withdraws funding
Mitigation: Diversified funding sources, government bridge funding

Risk 2: Delayed disbursement
Mitigation: Phased budgeting, advance payment requests, contingency fund

Risk 3: Currency fluctuation
Mitigation: USD-denominated agreements, quarterly budget reviews

Risk 4: Reporting non-compliance
Mitigation: Dedicated reporting officer, standardized templates, training

Risk 5: Political conditions affecting partnerships
Mitigation: Strong government support, multi-lateral approach
 
2. Contingency Funding Plan
text
text
If 30% of target funding not secured by Month 3:
- Scale down pilot scope (300,000 users instead of 500,000)
- Reduce number of integrated services (3 instead of 5)
- Extend timeline (15 months instead of 12)
- Increase government contribution

If 50% funding gap by Month 6:
- Pause development, focus on planning
- Seek emergency funding from existing partners
- Consider public-private partnership model
 
G. Success Metrics for Funding Strategy
 
1. Funding Targets
text
text
Primary Target: Secure $6.36M (40% of total) by Month 6
Secondary Target: Secure $5M (minimum viable) by Month 6
Stretch Target: Secure $8M (50% of total) by Month 6

Timeline Targets:
- Month 3: $2M secured (UNDP commitment)
- Month 4: $4M secured (World Bank commitment)
- Month 5: $5.5M secured (AfDB + UAE)
- Month 6: $6.36M+ secured (all commitments)
 
2. Partnership Quality Metrics
text
text
1. Speed of response: < 2 weeks for initial feedback
2. Proposal acceptance rate: > 80%
3. Disbursement timeliness: > 90% on schedule
4. Partner satisfaction: > 4/5 rating
5. Relationship strength: Multiple touchpoints, trust
 
H. Implementation of Funding Strategy
 
Week-by-Week Activities
text
text
Month 1:
- Week 1: Identify key contacts at Tier 1 partners
- Week 2: Prepare UNDP proposal (draft)
- Week 3: Prepare World Bank proposal (draft)
- Week 4: Internal review of proposals

Month 2:
- Week 1: Submit UNDP proposal
- Week 2: Submit World Bank proposal
- Week 3: Follow-up meetings with UNDP
- Week 4: Follow-up meetings with World Bank

Month 3:
- Week 1: Prepare AfDB proposal
- Week 2: Submit AfDB proposal
- Week 3: Respond to UNDP/World Bank queries
- Week 4: Technical review meetings

Month 4:
- Week 1: Prepare UAE proposal
- Week 2: Submit UAE proposal
- Week 3: Negotiation with UNDP
- Week 4: Negotiation with World Bank

Month 5:
- Week 1: Prepare Islamic Development Bank proposal
- Week 2: Submit Islamic Development Bank proposal
- Week 3: Agreement drafting (UNDP)
- Week 4: Agreement drafting (World Bank)

Month 6:
- Week 1: Sign UNDP agreement
- Week 2: Sign World Bank agreement
- Week 3: Sign AfDB agreement
- Week 4: Sign UAE agreement
 
Resource Allocation for Funding Strategy
text
text
Dedicated Team:
- Partnership Manager (1 FTE)
- Proposal Writer (0.5 FTE)
- Financial Analyst (0.5 FTE)
- Legal Advisor (0.25 FTE)

Budget for Funding Strategy:
- Proposal development: $50,000
- Travel and meetings: $30,000
- Consultancy (proposal writing): $20,000
- Total: $100,000 (from project budget)
 
I. Post-Agreement Management
 
1. Partner Relationship Management
text
text
Quarterly Review Meetings:
- Progress against milestones
- Budget utilization
- Risk assessment
- Relationship strengthening

Annual Partnership Events:
- Annual review with each partner
- Joint field visits
- Success story sharing
- Planning for next phase
 
2. Transparency and Accountability
text
text
Public Reporting:
- Website: Funding sources and amounts
- Annual report: Published online
- Media: Regular updates on progress
- Social media: Achievement announcements

Audit Trail:
- All funds tracked in dedicated system
- Regular internal audits
- External audit at project end
- Public disclosure of results
 
END OF STEP 4 FUNDING STRATEGY GUIDE
 
 
INTEGRATED IMPLEMENTATION PLAN
 
Overall Timeline Summary
 
text
text
Month 1-2: Preparation & Team Setup
├── Week 1-2: Document customization
├── Week 3-4: Steering Committee presentation
├── Week 5-6: Team formation
└── Week 7-8: Legal framework development

Month 3: Foundation Building
├── Week 9-10: Requirements workshops
├── Week 11-12: System design
└── Month 3 end: First funding submissions

Month 4-6: Core Development
├── Development sprints (6 sprints)
├── Integration with agencies
├── Funding negotiations
└── Monthly Steering Committee meetings

Month 7-9: Integration & Testing
├── Agency integration completion
├── System testing
├── Security audit
└── Funding agreements finalized

Month 10-12: Pilot Launch & Evaluation
├── Soft launch (1,000 users)
├── Full pilot (500,000 users)
├── Evaluation and reporting
└── Phase 2 planning
 
Critical Success Factors
 
1.Steering Committee Engagement: Monthly meetings, clear decisions
2.Funding Security: 40% external funding by Month 6
3.Team Capability: 80% local hires with international support
4.Stakeholder Buy-in: All 5 agencies committed and engaged
5.Technical Execution: Agile development with regular delivery
6.Change Management: Comprehensive training and communication
7.Risk Management: Proactive identification and mitigation
8.Transparency: Regular reporting and public communication
 
Immediate Next Actions (This Week)
 
1.Customize Project Charter: Add Sudanese context, SDG alignment
2.Identify Steering Committee Members: Confirm availability for Month 1 meeting
3.Draft UNDP Proposal: Using template with Sudan-specific elements
4.Schedule Legal Consultation: With Sudanese law firm for framework review
5.Begin Team Recruitment: Post advertisements for key positions
6.Plan Steering Committee Presentation: Schedule for Week 3 or 4
 
Would you like me to elaborate on any specific aspect of these four steps or provide additional templates and tools for implementation?
Let us tackle the following one by one: Customize Project Charter: Add Sudanese context, SDG alignment
2.Identify Steering Committee Members: Confirm availability for Month 1 meeting
3.Draft UNDP Proposal: Using template with Sudan-specific elements
4.Schedule Legal Consultation: With Sudanese law firm for framework review
5.Begin Team Recruitment: Post advertisements for key positions
6.Plan Steering Committee Presentation

1. CUSTOMIZE PROJECT CHARTER WITH SUDANESE CONTEXT & SDG ALIGNMENT
 
SUDAN GOVERNMENT DIGITAL UNIFIED SYSTEM (SGDUS) - PROJECT CHARTER
Version 2.0: Sudanese Context & SDG Alignment
Date: February 26, 2026 Project ID: SGDUS-2026-001 Location: Sudan (Khartoum State & Port Sudan) Currency: Sudanese Pound (SDG) and USD (1 SDG ≈ $0.0017)
 
 
EXECUTIVE SUMMARY
 
Sudan Context Statement
The Sudan Government Digital Unified System (SGDUS) emerges from Sudan's unique post-conflict reconstruction context. With a population of 45 million, Sudan faces significant digital divide challenges: only 40% internet penetration, 75% mobile penetration, and stark urban-rural disparities. The transitional government (2021-present) has prioritized digital transformation as a pathway to economic recovery, improved governance, and enhanced public service delivery. This project aligns directly with Sudan's Vision 2030 and the National Digital Transformation Strategy 2025-2030.
 
SDG Alignment Framework
This project directly contributes to 7 Sustainable Development Goals:
 
SDG	Alignment	Target Indicator
SDG 8: Decent Work & Economic Growth	Digital inclusion of informal sector, job creation for youth	25% increase in formal business registrations
SDG 9: Industry, Innovation & Infrastructure	Digital infrastructure development, innovation ecosystem	Digital infrastructure in 50% of pilot areas
SDG 10: Reduced Inequalities	Rural-urban, gender, and regional inclusion	40% of rural registrations, 50% women users
SDG 16: Peace, Justice & Strong Institutions	Transparent governance, reduced corruption	30% reduction in processing times, audit trails
SDG 17: Partnerships for Goals	Multi-stakeholder partnerships, technology transfer	5+ international partners, local capacity building
SDG 4: Quality Education	Digital literacy training, youth empowerment	200 government staff trained, 500 youth ambassadors
SDG 3: Good Health & Well-being	Digital health records integration (future phase)	Birth registration integration (5 hospitals)
 
 
1. PROJECT TITLE & SPONSORS
 
Project Title
Sudan Government Digital Unified System (SGDUS) - Phase 1: Foundation & Pilot Implementation
 
Sudanese Government Sponsors
Primary Sponsor: Ministry of Communications and Information Technology, Sudan
Executive Sponsor: Prime Minister's Office, Sudan
Ministerial Sponsors:
Ministry of Interior (Civil Registry Department)
Ministry of Trade and Industry
Ministry of Finance and Economic Planning
Ministry of Justice (Legal Framework)
Ministry of Land and Housing
 
International Partners
Funding Partners: UNDP Sudan, World Bank, African Development Bank
Technical Partners: UAE Smart City Initiative, Estonia e-Governance Academy
Local Partners: Sudanese Telecom Providers (MTN, Zain, Sudani), Sudanese Banks Association
 
 
2. PROJECT PURPOSE & JUSTIFICATION (SUDANESE CONTEXT)
 
Current Challenges in Sudan
1.Fragmented Governance: 30+ government agencies with disconnected systems
2.Bureaucratic Inefficiency: 15+ days for business registration, 7+ days for civil documents
3.Digital Divide: 40% internet penetration, 60% urban vs 30% rural
4.Economic Informality: 50% of economy operates informally, reducing tax base
5.Youth Unemployment: 70% of population under 30, 30% youth unemployment
6.Post-Conflict Reconstruction: Need for transparent, efficient service delivery
7.Regional Disparities: Khartoum vs. other states in service quality
 
Sudan-Specific Opportunities
1.Mobile Leapfrogging: 75% mobile penetration enables digital access
2.Youth Demographic: Digital-native population ready for adoption
3.Political Will: Transitional government's commitment to reform
4.Regional Leadership: Potential for Sudan to lead in digital transformation in East Africa
5.Economic Recovery: Digital systems can enhance revenue collection and business environment
 
Alignment with National Priorities
text
text
Sudan Vision 2030 Pillars:
1. Economic Prosperity: SGDUS improves business environment (Ease of Doing Business)
2. Social Justice: Digital inclusion of marginalized communities
3. Peace & Governance: Transparent systems reduce corruption
4. Environmental Sustainability: Paperless processes, reduced carbon footprint
5. Regional Integration: Standardized systems enable cross-border trade

National Digital Strategy 2025-2030 Priorities:
- Priority 1: Digital Infrastructure (Hybrid cloud for resilience)
- Priority 2: Digital Government Services (5 services in Phase 1)
- Priority 3: Digital Economy (25% formalization target)
- Priority 4: Digital Skills (200 staff trained)
- Priority 5: Cybersecurity (ISO 27001 certification)
 
 
3. PROJECT OBJECTIVES (SMART & SUDANESE CONTEXT)
 
Primary Objectives (Sudan-Specific)
 
Objective 1: Digital Identity Foundation
Specific: Register 500,000 citizens in Khartoum State with digital identity
Measurable: 50% women, 40% rural residents, 10% persons with disabilities
Achievable: Through 5 hospitals, 20 community centers, mobile registration vans
Relevant: Addresses civil registry gaps in post-conflict Sudan
Time-bound: 12 months
 
Objective 2: Service Integration for Sudanese Context
Specific: Integrate 5 services with Sudanese agency systems
Measurable: 50% reduction in processing time, 25% increase in formal registrations
Achievable: Through phased integration with Sudanese legacy systems
Relevant: Addresses bureaucratic inefficiencies in Sudan
Time-bound: 12 months
 
Objective 3: OID System for Sudan
Specific: Implement OID structure 1.3.6.1.4.1.61026 for Sudan
Measurable: 100% unique identification, zero duplicates
Achievable: Through Sudanese OID registry service
Relevant: Provides unique identification for 45 million Sudanese
Time-bound: Month 6
 
Objective 4: Digital Inclusion in Sudan
Specific: 70% mobile penetration, 40% internet access among registered users
Measurable: USSD access for 50% of users, mobile app for 40%, web for 10%
Achievable: Through partnerships with Sudanese telecom providers
Relevant: Addresses Sudan's digital divide
Time-bound: Month 12
 
Objective 5: Capacity Building for Sudan
Specific: Train 200 Sudanese government staff in digital systems
Measurable: 90% pass rate, 80% retention after 6 months
Achievable: Through Sudanese training centers and international partnerships
Relevant: Addresses skills gap in Sudan's public sector
Time-bound: Month 12
 
Secondary Objectives (Sudan-Specific)
 
Economic Objectives
Increase formal business registrations in Khartoum by 25%
Reduce business registration time from 15 days to 3 days
Increase tax compliance through digital tax ID
Create 500 youth jobs in digital sector (maintenance, support)
 
Social Objectives
Improve access to government services for 1 million Sudanese
Enhance transparency in government processes
Reduce corruption in service delivery by 30%
Empower women through digital access (target: 50% female users)
 
Governance Objectives
Establish inter-agency data sharing framework
Create audit trails for all government transactions
Align with Sudan's Anti-Corruption Strategy
Support Sudan's transition to digital democracy
 
 
4. KEY DELIVERABLES (SUDANESE CONTEXT)
 
Technical Deliverables
1.
Core System Platform
OID Registry Service (1.3.6.1.4.1.61026)
Identity Management Module (Citizen & Business)
API Gateway for Sudanese agency integration
Mobile Application (Android/iOS with Arabic interface)
USSD Interface (*123# for basic phones)
Web Portal (Arabic and English)
2.
Sudan-Specific Infrastructure
Hybrid cloud architecture (considering Sudan's connectivity)
On-premise servers for sensitive data (Sudanese sovereignty)
Offline-capable systems for rural areas
Solar-powered community access points
Multi-ISP connectivity for resilience
3.
Integration Components
Civil Registry Adapter (Sudan's existing system)
Business Registration Adapter (Sudan's system)
Tax Authority Adapter (Sudan's system)
Customs Adapter (Port Sudan)
Land Registry Adapter (Sudan's system)
 
Process Deliverables (Sudan-Specific)
1.
Legal Framework
Data Protection Policy (aligned with Sudan's laws)
Inter-Agency Data Sharing Agreement (Sudanese context)
Digital Identity Recognition Law (draft for Parliament)
Privacy Impact Assessment (Sudanese-specific)
2.
Capacity Building
Training Curriculum (Arabic, Sudanese case studies)
Sudanese Training Materials (culturally appropriate)
Sudanese Trainer Certification Program
Youth Ambassador Program (500 young digital champions)
3.
Sudanese Stakeholder Engagement
Community Engagement Plan (tribal structures, religious leaders)
Public Awareness Campaign (radio, TV, community meetings)
Sudanese Success Stories (local champions)
Sudanese Media Strategy
 
Pilot-Specific Deliverables (Sudanese Context)
1.
Khartoum Business Registration Pilot
Digital business registration portal (Arabic)
Integrated tax ID generation (Sudan Tax Authority)
Export license application module (Sudan Customs)
Success metrics dashboard (Sudan-specific KPIs)
2.
Citizen Digital ID Pilot
Birth registration integration (5 Khartoum hospitals)
Family registry module (Sudanese family structure)
Mobile ID verification system (USSD/SMS)
Community registration points (50 locations in Khartoum)
 
 
5. PROJECT SCOPE (SUDANESE CONTEXT)
 
INCLUSIONS (Sudan-Specific)
Geographic: Khartoum State (5 million population) + Port Sudan (free zone)
Services:
1.Civil Registry (birth registration, family registry)
2.Business Registration (Sudan's 2015 Business Registration Act)
3.Tax ID (National Tax Authority system)
4.Export Licensing (Customs Authority, Port Sudan)
5.Land Registry (Ministry of Land and Housing)
Users: Sudanese citizens (adults), Sudanese businesses (SMEs), government employees
Technology:
Mobile-first (Android, iOS, USSD for basic phones)
Arabic interface (right-to-left display)
Offline capabilities (for intermittent connectivity)
Multi-channel access (web, mobile, USSD, SMS, community points)
OID System: Full implementation of 1.3.6.1.4.1.61026 with Sudanese sub-identifiers
 
EXCLUSIONS (Sudan-Specific)
National Security Systems: Separate from military/intelligence systems
Political Systems: Election systems (separate from this project)
Full National Rollout: Phase 1 only (Khartoum + Port Sudan)
Hardware Distribution: Focus on software/platform; hardware through partners
International Border Control: Except export/import modules in Port Sudan
Health/Education Systems: Future phases (considering Sudan's infrastructure)
 
Sudan-Specific Constraints
1.Connectivity: Design for 40% internet penetration, intermittent connectivity
2.Power: Address electricity instability with solar-powered access points
3.Literacy: Design for 65% literacy rate (including illiterate users via USSD/voice)
4.Languages: Arabic primary, English secondary, local languages for outreach
5.Cultural: Respect Sudanese tribal structures, religious considerations
6.Economic: Account for currency volatility (SDG/USD)
7.Security: Address post-conflict security concerns
 
 
6. PROJECT TIMELINE (SUDANESE CONTEXT)
 
Phase 1: Foundation (Months 1-3)
text
text
Month 1: Project Launch & Team Setup
- Week 1-2: Sudanese public announcement (press conference)
- Week 3-4: Team formation (80% Sudanese hires)
- Key Sudanese Milestone: Project announced by Minister of Communications

Month 2: Legal Framework & Infrastructure
- Week 5-6: Legal gap analysis (Sudanese laws)
- Week 7-8: Hybrid cloud setup (considering Sudan's infrastructure)
- Key Sudanese Milestone: Data sharing agreements with 5 agencies

Month 3: Requirements & Design
- Week 9-10: Workshops in Khartoum (Arabic language)
- Week 11-12: System design (Sudanese context)
- Key Sudanese Milestone: Design validated by Sudanese agencies
 
Phase 2: Development & Integration (Months 4-9)
text
text
Month 4-6: Core Development
- Development sprints (considering Sudanese working days)
- Integration with Sudanese legacy systems
- Key Sudanese Milestone: Eid al-Fitr (May) - reduced productivity

Month 7-8: Integration with Sudanese Agencies
- Civil Registry integration (Sudan's existing system)
- Business Registration integration (Sudan's system)
- Key Sudanese Milestone: Independence Day (January 1) - potential soft launch

Month 9: Testing & Security
- Security audit (considering Sudan's cybersecurity landscape)
- User acceptance testing (Sudanese users)
- Key Sudanese Milestone: Eid al-Adha (July) - reduced productivity
 
Phase 3: Pilot Launch & Evaluation (Months 10-12)
text
text
Month 10: Soft Launch
- 1,000 users in Khartoum hospitals
- Key Sudanese Milestone: Islamic New Year (September)

Month 11: Full Pilot Launch
- 500,000 users in Khartoum + Port Sudan
- Marketing campaign (Sudanese media channels)
- Key Sudanese Milestone: Prophet's Birthday (November)

Month 12: Evaluation & Phase 2 Planning
- Evaluation report (Sudanese context)
- Phase 2 recommendations (expansion to 5 more states)
- Key Sudanese Milestone: Year-end review with Sudanese government
 
Sudanese Calendar Considerations
text
text
Ramadan (April 2026): Reduced working hours (6 hours/day)
Eid al-Fitr (May 2026): 4-day holiday
Eid al-Adha (July 2026): 4-day holiday
Islamic New Year (September 2026): 1-day holiday
Prophet's Birthday (November 2026): 1-day holiday
Independence Day (January 1): National holiday

Adjustments:
- No major milestones during holidays
- Development sprints adjusted for Ramadan
- Community engagement during evenings in Ramadan
 
 
7. BUDGET ESTIMATE (PHASE 1 - SUDANESE CONTEXT)
 
Total Budget: $15,900,000 (SDG Equivalent: ~9.35 Billion SDG)
Note: 1 USD ≈ 590 SDG (as of February 2026)
 
Category	Amount (USD)	Amount (SDG)	Percentage	Sudanese Context Notes
Infrastructure	$4,000,000	2.36 billion SDG	25%	Hybrid cloud + on-premise for data sovereignty
Software Development	$3,500,000	2.07 billion SDG	22%	Sudanese developers (70%), international experts (30%)
Personnel	$3,000,000	1.77 billion SDG	19%	80% Sudanese hires, competitive local salaries
Legal & Compliance	$1,200,000	708 million SDG	7.5%	Sudanese law firms, international legal advisors
Training & Capacity	$1,000,000	590 million SDG	6.25%	Sudanese training centers, Arabic materials
Marketing & Outreach	$800,000	472 million SDG	5%	Sudanese media channels, community engagement
Contingency (15%)	$2,400,000	1.42 billion SDG	15%	Currency fluctuation buffer, Sudanese context risks
TOTAL	$15,900,000	9.35 billion SDG	100%	
 
Funding Sources (Sudan-Specific)
text
text
Government of Sudan: $9,540,000 (60%)
- Ministry of Communications & IT: $4,000,000 (SDG 2.36B)
- Ministry of Interior (Civil Registry): $1,500,000 (SDG 885M)
- Ministry of Trade: $1,500,000 (SDG 885M)
- In-kind contributions (office space, staff secondment): $2,540,000 (SDG 1.5B)

International Partners: $6,360,000 (40%)
- UNDP Sudan: $2,000,000 (SDG 1.18B)
- World Bank: $2,000,000 (SDG 1.18B)
- African Development Bank: $1,000,000 (SDG 590M)
- UAE Development Funds: $800,000 (SDG 472M)
- Private Sector (CSR): $560,000 (SDG 330M)
 
Phased Expenditure (Sudanese Calendar)
text
text
Q1 (Jan-Mar): $3M (20%) - Planning, team, infrastructure
Q2 (Apr-Jun): $5M (31%) - Development, design (Ramadan in April)
Q3 (Jul-Sep): $4.5M (28%) - Integration, testing (Eid al-Adha in July)
Q4 (Oct-Dec): $3.4M (21%) - Pilot, evaluation (Independence Day in Jan 2027)
 
Sudan-Specific Budget Considerations
1.Currency Risk: 15% contingency for SDG depreciation
2.Local Hiring: 80% of team Sudanese (competitive salaries in SDG)
3.Infrastructure: Hybrid model (cloud + on-premise for data sovereignty)
4.Connectivity: Partnerships with Sudanese telecoms for zero-rated services
5.Training: Local training centers (Khartoum, Port Sudan) to reduce travel costs
 
 
8. PROJECT TEAM & KEY STAKEHOLDERS (SUDANESE CONTEXT)
 
Project Team Structure
text
text
Project Sponsor: Minister of Communications and IT, Sudan
Project Director: [To be appointed - Sudanese professional with 10+ years experience]
Technical Lead: [To be appointed - Sudanese or international with Sudan experience]
 
Core Team (35 members)
Sudanese Government Staff: 20 (seconded from ministries)
Sudanese Hires: 12 (recruited locally)
International Experts: 3 (embedded for specific skills)
 
Key Sudanese Stakeholders
Stakeholder	Role	Involvement	Sudanese Contact
Prime Minister's Office	Executive Sponsor	Monthly steering committee	PMO Digital Transformation Unit
Ministry of Communications	Technical Oversight	Weekly coordination	Minister's Office, IT Director
Ministry of Interior (Civil Registry)	Data Provider	Bi-weekly meetings	Civil Registry Director
Ministry of Trade & Industry	Business Services	Bi-weekly meetings	Business Registration Director
National Tax Authority	Data Provider	Bi-weekly meetings	Tax Authority Commissioner
Customs Authority (Port Sudan)	Export/Import Module	Monthly reviews	Port Sudan Director
Ministry of Land & Housing	Land Registry	Monthly reviews	Land Registry Director
UNDP Sudan	Funding Partner	Quarterly reviews	Country Director, Dr. Aida M. Al-Amin
World Bank	Technical Assistance	Quarterly reviews	Country Manager, Mr. Hervé L. Lemoine
Sudanese Telecom Providers	Infrastructure Partners	Technical working groups	MTN Sudan, Zain Sudan, Sudani
Civil Society Organizations	User Advocacy	User testing sessions	Transparency Sudan, Sudanese Women's Union
Sudanese Chambers of Commerce	Business Users	Focus groups	Khartoum Chamber, Port Sudan Chamber
Sudanese Religious Leaders	Community Engagement	Advisory role	Imams, Church Leaders (as appropriate)
Sudanese Tribal Leaders	Rural Outreach	Advisory role	Tribal leaders (as appropriate)
 
Sudanese Advisory Board
text
text
1. Sudanese Technical Advisory Committee
   - 5 Sudanese IT experts (academia, private sector)
   - Monthly meetings
   - Review technical architecture

2. Sudanese Legal Advisory Committee
   - 3 Sudanese lawyers (digital law, constitutional law)
   - Bi-weekly meetings
   - Review legal framework

3. Sudanese Community Advisory Board
   - 15 members (5 women, 5 youth, 5 rural representatives)
   - Monthly meetings
   - Provide user feedback
 
 
9. GOVERNANCE STRUCTURE (SUDANESE CONTEXT)
 
Steering Committee (Monthly - Sudanese Leadership)
text
text
Chair: Prime Minister's Office Representative (or Deputy PM)
Members:
- Minister of Communications and IT (Project Sponsor)
- Minister of Interior (Civil Registry)
- Minister of Trade and Industry
- Minister of Finance (Budget Oversight)
- Minister of Justice (Legal Framework)
- UNDP Sudan Country Director
- World Bank Country Manager
- 2 Sudanese Private Sector Representatives (Chambers of Commerce)
- 1 Sudanese Civil Society Representative (Transparency Sudan)

Observers:
- Project Director (non-voting)
- Technical Lead (non-voting)
- International Experts (non-voting)

Meetings: First Monday of each month, 9:00 AM
Location: Khartoum (with virtual option for international partners)
Language: Arabic (with English translation for international partners)
 
Technical Committee (Bi-weekly - Sudanese Technical Leadership)
text
text
Chair: Project Director
Members:
- Ministry of Communications CTO
- Ministry of Interior IT Director
- Ministry of Trade IT Director
- National Tax Authority IT Director
- Customs Authority IT Director
- Ministry of Land IT Director
- UNDP Technical Advisor
- World Bank Technical Advisor

Meetings: Every other Wednesday, 2:00 PM
Location: Khartoum (hybrid)
Focus: Technical decisions, integration issues, architecture reviews
 
Sudanese Implementation Structure
text
text
Federal Level: Khartoum (Project HQ)
State Level: Khartoum State Implementation Team
Local Level: 5 Hospital Teams, 20 Community Centers

Each Level:
- Sudanese Project Coordinator
- Sudanese Technical Lead
- Sudanese Change Champion
- International Advisor (if needed)
 
Escalation Path (Sudanese Context)
text
text
Level 1: Team → PMO (24 hours)
Level 2: PMO → Technical Committee (48 hours)
Level 3: Technical Committee → Steering Committee (72 hours)
Level 4: Steering Committee → Cabinet (5 days)

Sudanese-Specific: Consider tribal/religious structures for rural escalation
 
 
10. SUCCESS CRITERIA (SUDANESE CONTEXT & SDG ALIGNED)
 
Quantitative Metrics (Sudan-Specific)
Metric	Target	SDG Alignment	Measurement Method
User Adoption	500,000 registered citizens	SDG 10, 16	Registration database
Business Registrations	5,000 new formal businesses	SDG 8	Business registry
Rural Inclusion	40% of registrations from rural areas	SDG 10, 16	Geographic analysis
Gender Inclusion	50% female users	SDG 5, 10	User demographics
Processing Time Reduction	50% reduction (15 days → 7.5 days)	SDG 16	Time tracking
System Performance	99.5% uptime, <2s response	SDG 9	Monitoring tools
Security	Zero critical vulnerabilities	SDG 16	Security audits
Staff Training	200 Sudanese staff trained	SDG 4, 8	Training records
 
Qualitative Metrics (Sudan-Specific)
User Satisfaction: >80% (quarterly surveys in Arabic)
Agency Satisfaction: >75% (Sudanese agency feedback)
Media Sentiment: Positive coverage in Sudanese media
International Recognition: Awards/recognition for Sudan
Community Trust: >70% trust in digital system (community surveys)
 
SDG-Specific Indicators
text
text
SDG 8: Economic Growth
- Indicator 8.2.1: 25% increase in formal business registrations
- Indicator 8.3.1: 50% reduction in business registration time

SDG 9: Infrastructure
- Indicator 9.c.1: 40% of rural population with digital access

SDG 10: Reduced Inequalities
- Indicator 10.2.1: 50% of registered users are women
- Indicator 10.3.1: 40% of users from rural areas

SDG 16: Peace & Institutions
- Indicator 16.5.2: 30% reduction in corruption perception (survey)
- Indicator 16.6.1: 100% of transactions audited

SDG 17: Partnerships
- Indicator 17.17.1: 5+ international partners engaged
- Indicator 17.18.1: 200 Sudanese staff trained
 
 
11. RISKS & ASSUMPTIONS (SUDANESE CONTEXT)
 
Sudan-Specific Risks
Risk	Probability	Impact	Sudan-Specific Mitigation
Political Transition	Medium	High	Multi-party support, phased approach, quick wins
Currency Instability	High	High	USD-denominated contracts, quarterly budget reviews
Infrastructure Challenges	High	Medium	Hybrid model, offline capabilities, solar power
Digital Divide	Very High	High	Multi-channel (USSD, SMS, mobile), community points
Regional Security Issues	Medium	Medium	Start with stable states (Khartoum, Port Sudan)
Data Sovereignty Concerns	Medium	Medium	On-premise servers for sensitive data, hybrid cloud
Skills Gap	High	Medium	Intensive training, international experts, youth program
Cultural Resistance	Medium	Medium	Community engagement, religious/tribal leaders
Economic Informality	High	Medium	Simplified registration, incentives for formalization
Post-Conflict Trauma	Medium	Low	Trauma-informed design, community trust building
 
Key Assumptions (Sudan-Specific)
1.Political Stability: Transitional government remains committed to reform
2.Infrastructure: Internet connectivity in Khartoum will support digital services
3.Agency Cooperation: Sudanese agencies will provide data and access
4.International Partners: UNDP/World Bank will deliver as agreed
5.Civil Society: Sudanese civil society will support user adoption
6.Youth Engagement: Young Sudanese will be early adopters
7.Economic Recovery: Currency stability will allow proper budgeting
8.Security: No major conflict escalation in pilot areas
 
Sudan-Specific Contingency Plans
text
text
If Political Instability Increases:
- Pause non-critical activities
- Focus on core technical development
- Seek multi-party support

If Currency Depreciates >20%:
- Activate contingency fund
- Prioritize local procurement
- Consider in-kind contributions

If Infrastructure Fails:
- Switch to offline-first design
- Use USSD/SMS as primary channels
- Deploy mobile registration vans

If Agency Resistance Emerges:
- Escalate to Steering Committee
- Offer incentives (cost savings, efficiency gains)
- Consider phased integration
 
 
12. APPROVALS (SUDANESE CONTEXT)
 
Prepared By:
[Project Director Name]Position: Project Director, SGDUS Date: February 26, 2026 Signature: _________________________
 
Recommended By:
[Technical Lead Name]Position: Technical Lead, SGDUS Date: February 26, 2026 Signature: _________________________
 
Approved By (Sudanese Steering Committee):
 
1. Prime Minister's Office RepresentativeName: [To be appointed] Position: Deputy Prime Minister or PMO Head Date: _________________________ Signature: _________________________
 
2. Minister of Communications and IT, SudanName: [Current Minister: Mr. Talal Ahmed] Position: Minister of Communications and IT Date: _________________________ Signature: _________________________
 
3. UNDP Sudan Country DirectorName: Dr. Aida M. Al-Amin Position: Country Director, UNDP Sudan Date: _________________________ Signature: _________________________
 
4. World Bank Country Manager for SudanName: Mr. Hervé L. Lemoine Position: Country Manager, World Bank Sudan Date: _________________________ Signature: _________________________
 
 
APPENDICES (SUDANESE CONTEXT)
 
Appendix A: Sudanese OID Structure Specification
text
text
1.3.6.1.4.1.61026 - Sudan Government Digital System
├── 1 - Places (States, Districts, Localities)
│   ├── 1.3.6.1.4.1.61026.1.1 - States (18)
│   │   ├── 1.3.6.1.4.1.61026.1.1.1 - Khartoum State
│   │   ├── 1.3.6.1.4.1.61026.1.1.2 - Port Sudan State
│   │   └── ... (all 18 states)
│   ├── 1.3.6.1.4.1.61026.1.2 - Districts (133)
│   └── 1.3.6.1.4.1.61026.1.3 - Localities (425+)
├── 2 - Citizens (Individuals)
│   ├── 1.3.6.1.4.1.61026.2.1 - Adults (18+)
│   ├── 1.3.6.1.4.1.61026.2.2 - Minors (0-17)
│   └── 1.3.6.1.4.1.61026.2.3 - Special Categories
├── 3 - Businesses (Legal Entities)
│   ├── 1.3.6.1.4.1.61026.3.1 - Sole Proprietorship
│   ├── 1.3.6.1.4.1.61026.3.2 - Partnership
│   ├── 1.3.6.1.4.1.61026.3.3 - Limited Company
│   └── 1.3.6.1.4.1.61026.3.4 - Foreign Entity
├── 4 - Government Entities
│   ├── 1.3.6.1.4.1.61026.4.1 - Federal Ministries
│   ├── 1.3.6.1.4.1.61026.4.2 - State Governments
│   └── 1.3.6.1.4.1.61026.4.3 - Local Governments
├── 5 - Digital Services
│   ├── 1.3.6.1.4.1.61026.5.1 - Identity Services
│   ├── 1.3.6.1.4.1.61026.5.2 - Business Services
│   ├── 1.3.6.1.4.1.61026.5.3 - Tax Services
│   ├── 1.3.6.1.4.1.61026.5.4 - Customs Services
│   └── 1.3.6.1.4.1.61026.5.5 - Land Services
└── 6 - Documents & Certificates
    ├── 1.3.6.1.4.1.61026.6.1 - Identity Documents
    ├── 1.3.6.1.4.1.61026.6.2 - Business Licenses
    ├── 1.3.6.1.4.1.61026.6.3 - Tax Certificates
    ├── 1.3.6.1.4.1.61026.6.4 - Export/Import Documents
    └── 1.3.6.1.4.1.61026.6.5 - Property Documents
 
Appendix B: Sudanese Legal Framework Analysis
text
text
Current Laws:
- Electronic Transactions Act, 2007 (Amended 2018)
- National Civil Registry Act, 1994
- Business Registration Act, 2015
- Tax Administration Act, 2018
- Data Protection Act (Under development)

Required Amendments:
1. Digital Identity Recognition Law
2. Inter-Agency Data Sharing Framework
3. Digital Signature and Authentication Law
4. Privacy and Data Protection Regulation
5. Cybersecurity Act (draft stage)

Legal Partners:
- Sudanese Law Firms: [To be identified]
- International Legal Advisors: UNDP/World Bank legal support
 
Appendix C: Sudanese Cultural Considerations
text
text
Language: Arabic (primary), English (technical), local languages (outreach)
Religious: Islamic calendar, prayer times (avoid scheduling during prayer)
Tribal: Respect tribal structures, engage tribal leaders
Gender: Separate registration areas for women in conservative areas
Community: Engage mosque/church leaders for trust building
 
Appendix D: Sudanese Success Stories (Examples)
text
text
1. Estonian Model: Adaptation for Sudanese context
2. India Aadhaar: Scale and inclusivity lessons
3. UAE Smart City: Regional technology transfer
4. Rwanda Digital Transformation: Post-conflict success story
 
 
SIGNATURE PAGE
 
Sudanese Government Approvals
 
Minister of Communications and IT, SudanSignature: _________________________ Date: _________________________
 
Minister of Interior, SudanSignature: _________________________ Date: _________________________
 
Minister of Trade and Industry, SudanSignature: _________________________ Date: _________________________
 
International Partner Approvals
 
UNDP Sudan Country DirectorSignature: _________________________ Date: _________________________
 
World Bank Country Manager for SudanSignature: _________________________ Date: _________________________
 
 
END OF CUSTOMIZED PROJECT CHARTER
 
 
Next Steps for This Deliverable:
1.Review with Sudanese Legal Advisor: Ensure compliance with Sudanese law
2.Cultural Sensitivity Review: With Sudanese cultural advisors
3.SDG Alignment Verification: With UNDP Sudan SDG unit
4.Stakeholder Review: Present to key Sudanese stakeholders for feedback
5.Finalization: Incorporate feedback and finalize Version 2.0
 
Would you like me to proceed with the next deliverable: "Identify Steering Committee Members: Confirm availability for Month 1 meeting"?
Great let us tackle the following one by one: Review with Sudanese Legal Advisor: Ensure compliance with Sudanese law
2.Cultural Sensitivity Review: With Sudanese cultural advisors
3.SDG Alignment Verification: With UNDP Sudan SDG unit
4.Stakeholder Review: Present to key Sudanese stakeholders for feedback
5.Finalization: Incorporate feedback and finalize Version 2.0

STEP 1: REVIEW WITH SUDANESE LEGAL ADVISOR
 
LEGAL REVIEW PROCESS & DELIVERABLES
 
A. Objectives of Legal Review
text
text
Primary Objectives:
1. Ensure Project Charter complies with Sudanese laws and regulations
2. Identify required legal amendments for project implementation
3. Assess data protection and privacy requirements under Sudanese law
4. Validate inter-agency data sharing framework
5. Review intellectual property and technology transfer considerations

Secondary Objectives:
- Strengthen legal foundation for project sustainability
- Mitigate legal risks specific to Sudanese context
- Establish legal basis for international partnerships
- Create model legal framework for future digital projects
 
B. Sudanese Legal Advisor Selection
 
Selection Criteria
text
text
1. Expertise in Sudanese Law:
   - Electronic Transactions Act, 2007 (Amended 2018)
   - Civil Registry Laws and Regulations
   - Business Registration Act, 2015
   - Tax Administration Act, 2018
   - Data Protection Act (Under development)
   - Cybersecurity Act (Draft stage)

2. Experience with Digital/Government Projects:
   - Previous work on government digital systems
   - Experience with international organizations (UNDP, World Bank)
   - Understanding of Sudanese bureaucratic processes

3. Language Capability:
   - Fluent in Arabic (legal drafting)
   - Proficient in English (international standards)
   - Understanding of technical terminology

4. Reputation and Network:
   - Well-respected in Sudanese legal community
   - Established relationships with relevant ministries
   - Track record of successful project support
 
Recommended Legal Firms in Sudan
text
text
1. **Khadiga Law Firm** (Khartoum)
   - Specialization: Commercial law, digital transactions
   - Experience: Worked with UNDP on legal frameworks
   - Contact: [To be obtained]

2. **Sudanese Legal Consultancy Group** (Khartoum)
   - Specialization: Government contracts, data protection
   - Experience: Supported government digital initiatives
   - Contact: [To be obtained]

3. **International Law Firm with Sudan Office** (e.g., Dentons, Clyde & Co)
   - Specialization: International standards with local expertise
   - Experience: Cross-border digital projects
   - Contact: [To be obtained]

4. **Individual Sudanese Legal Experts** (Academic/Practitioner)
   - Prof. [Name] - University of Khartoum, Law Faculty
   - [Name] - Former Minister of Justice, specialized in digital law
   - Contact: [To be obtained]
 
C. Legal Review Scope & Checklist
 
1. Compliance with Existing Sudanese Laws
text
text
Review Areas:
[ ] Electronic Transactions Act, 2007 (Amended 2018)
    - Digital signatures recognition
    - Electronic evidence admissibility
    - Service provider obligations

[ ] National Civil Registry Act, 1994
    - Birth registration requirements
    - Family registry structure
    - Data ownership and access

[ ] Business Registration Act, 2015
    - Registration procedures
    - Business entity types
    - Licensing requirements

[ ] Tax Administration Act, 2018
    - Tax ID generation and management
    - Data sharing with tax authority
    - Privacy protections

[ ] Data Protection Act (Under Development)
    - Alignment with draft provisions
    - International best practices (GDPR-like principles)

[ ] Cybersecurity Act (Draft Stage)
    - Security requirements
    - Incident reporting
    - Cross-border data flows

[ ] Constitutional Provisions
    - Right to privacy (Article 41 of Interim Constitution)
    - Freedom of information
    - Equality and non-discrimination
 
2. Required Legal Amendments
text
text
Identify Gaps:
1. Digital Identity Recognition Law
   - Current gap: No specific law recognizing digital identity
   - Recommendation: Draft new law or amend existing civil registry law

2. Inter-Agency Data Sharing Framework
   - Current gap: No legal basis for sharing between agencies
   - Recommendation: Cabinet decision or ministerial decree

3. Digital Signature and Authentication Law
   - Current gap: Limited recognition of digital signatures
   - Recommendation: Enhance Electronic Transactions Act

4. Privacy and Data Protection Regulation
   - Current gap: No comprehensive data protection law
   - Recommendation: Draft regulation based on international standards

5. Cybersecurity Standards for Government Systems
   - Current gap: No specific standards for government IT
   - Recommendation: Adopt ISO 27001 as national standard
 
3. Data Protection & Privacy Assessment
text
text
Key Questions for Legal Advisor:
1. What are Sudan's current data protection requirements?
2. How does Sudan regulate cross-border data transfer?
3. What are the rights of data subjects under Sudanese law?
4. What are the obligations of data controllers/processors?
5. How are government agencies regulated regarding citizen data?
6. What are the penalties for data breaches?

Sudan-Specific Considerations:
- Tribal and family privacy norms
- Religious considerations (Islamic law on privacy)
- Post-conflict security concerns
- International sanctions and their impact on data flows
 
4. Intellectual Property & Technology Transfer
text
text
Review Areas:
1. Software Licensing
   - Open-source vs. proprietary software
   - Sudanese copyright law compliance
   - Vendor agreements

2. Technology Transfer Agreements
   - UAE/Estonia/India partnerships
   - Intellectual property rights
   - Knowledge transfer protocols

3. Data Ownership
   - Who owns the data? (Citizen, Government, System)
   - Commercial use restrictions
   - Research and analytics permissions
 
5. International Partnership Legal Framework
text
text
UNDP/World Bank Agreements:
- Project Document compliance
- Financial regulations
- Audit requirements
- Reporting obligations

UAE/Estonia/India Partnerships:
- Memorandum of Understanding (MoU) structure
- Technology transfer agreements
- Training and knowledge exchange

Private Sector Partnerships:
- Telecom providers (MTN, Zain, Sudani)
- Banks (for financial inclusion)
- Local tech companies
 
D. Legal Review Process
 
Week 1-2: Initial Engagement
text
text
Day 1-3: Legal Advisor Selection
- Issue request for proposals (RFP)
- Conduct interviews with shortlisted candidates
- Select legal advisor/firm

Day 4-7: Kick-off Meeting
- Present Project Charter to legal team
- Explain project objectives and scope
- Define legal review timeline and deliverables

Day 8-14: Document Collection
- Provide all project documents
- Share existing Sudanese laws relevant to project
- Provide international standards for reference
 
Week 3-6: Comprehensive Review
text
text
Phase 1: Legal Gap Analysis (Week 3-4)
- Review existing laws against project requirements
- Identify compliance gaps
- Draft preliminary recommendations

Phase 2: Detailed Legal Assessment (Week 5-6)
- Review specific clauses in Project Charter
- Assess data protection requirements
- Evaluate international partnership agreements
- Draft legal framework recommendations
 
Week 7-8: Reporting & Recommendations
text
text
Deliverable 1: Legal Gap Analysis Report
- Executive summary (Arabic and English)
- Detailed analysis of each legal area
- Risk assessment (legal risks and mitigations)

Deliverable 2: Legal Framework Recommendations
- Draft laws/regulations needed
- Model inter-agency data sharing agreement
- Data protection policy template
- International partnership agreement templates

Deliverable 3: Compliance Checklist
- For project team to ensure ongoing compliance
- Updated with Sudanese context
- Regular review schedule
 
E. Expected Legal Documents
 
1. Legal Gap Analysis Report (15-20 pages)
text
text
Structure:
1. Executive Summary
2. Methodology and Scope
3. Current Legal Framework Analysis
   - Electronic Transactions Act
   - Civil Registry Laws
   - Business Registration Laws
   - Tax Laws
   - Data Protection (Draft)
   - Cybersecurity (Draft)
4. Gap Analysis
   - Compliance with existing laws
   - Required amendments
   - New legislation needed
5. International Standards Comparison
   - GDPR principles
   - ISO 27001 requirements
   - UN principles on digital governance
6. Risk Assessment
   - Legal risks for project
   - Mitigation strategies
   - Contingency plans
7. Recommendations
   - Short-term (project-specific)
   - Medium-term (national framework)
   - Long-term (regional leadership)
8. Appendices
   - Relevant Sudanese laws
   - Draft provisions for new laws
   - Legal references and citations
 
2. Model Legal Framework (Sudanese Context)
text
text
Document 1: Draft Digital Identity Recognition Law
- Recognition of digital identity as legal identity
- Integration with civil registry
- Security and privacy protections
- Government agency responsibilities

Document 2: Inter-Agency Data Sharing Framework
- Legal basis for data sharing
- Data classification and access levels
- Security and audit requirements
- Dispute resolution mechanism

Document 3: Data Protection Regulation
- Personal data definition (Sudanese context)
- Data subject rights
- Data controller/processor obligations
- Cross-border data transfer rules
- Enforcement and penalties

Document 4: Digital Signature and Authentication Law
- Recognition of digital signatures
- Certification authority framework
- Legal validity of electronic documents
- Liability and trust services
 
3. Partnership Agreement Templates
text
text
Template 1: Government Agency Data Sharing Agreement
- Parties: Ministry X, Ministry Y, SGDUS
- Purpose: Specific service integration
- Data categories and usage
- Security requirements
- Termination clauses

Template 2: International Partnership MoU
- Parties: Sudanese Government + UNDP/World Bank/UAE
- Scope of cooperation
- Funding arrangements
- Reporting and monitoring
- Intellectual property

Template 3: Private Sector Partnership Agreement
- Parties: Telecom providers, banks, tech companies
- Service level agreements
- Revenue sharing (if applicable)
- Data protection commitments
- Termination and exit
 
F. Addressing Legal Issues
 
Potential Issues & Solutions
text
text
Issue 1: Lack of Digital Identity Recognition Law
Solution: Draft new law based on international models (Estonia, India)
Timeline: 6-12 months for parliamentary approval
Interim: Use ministerial decree for pilot phase

Issue 2: Data Protection Gaps
Solution: Adopt GDPR-like principles through regulation
Timeline: 3-6 months for regulation issuance
Interim: Apply international best practices voluntarily

Issue 3: Inter-Agency Data Sharing Restrictions
Solution: Cabinet decision or specific law amendment
Timeline: 3 months for cabinet decision
Interim: Memorandum of Understanding between agencies

Issue 4: International Sanctions Impact
Solution: Work with UNDP/World Bank for compliance
Timeline: Ongoing
Interim: Ensure all partners comply with international regulations
 
Legal Risk Mitigation Strategy
text
text
1. Phased Legal Approach:
   - Phase 1: Use existing laws + ministerial decrees
   - Phase 2: Cabinet decisions for inter-agency sharing
   - Phase 3: New legislation for digital identity

2. Legal Safeguards:
   - Strong data protection by design
   - Regular legal compliance audits
   - Insurance coverage for legal risks
   - Escrow arrangements for critical systems

3. Stakeholder Alignment:
   - Legal review with all participating ministries
   - Engagement with Ministry of Justice early
   - Parliamentary awareness (if needed)
 
G. Timeline & Budget
 
Timeline (8 Weeks)
text
text
Week 1-2: Legal Advisor Selection & Kick-off
Week 3-4: Document Review & Gap Analysis
Week 5-6: Detailed Assessment & Drafting
Week 7-8: Report Finalization & Presentation

Total: 8 weeks (2 months)
 
Budget Estimate
text
text
Legal Review Costs: $50,000 - $75,000
- Legal Advisor Fees: $30,000 - $50,000 (based on experience)
- Internal Team Support: $10,000 - $15,000 (project team time)
- Documentation & Translation: $5,000 - $10,000

Funding Source: Project budget (Legal & Compliance category)
 
H. Next Steps After Legal Review
 
Immediate Actions (Upon Receiving Legal Report)
text
text
1. Internal Review with Project Team (2 days)
2. Presentation to Steering Committee (1 week)
3. Incorporate Legal Recommendations into Project Charter (1 week)
4. Develop Implementation Plan for Legal Framework (2 weeks)
5. Begin Drafting Required Laws/Regulations (ongoing)
 
Long-term Legal Framework Implementation
text
text
Month 1-3: Ministerial Decrees for Pilot Phase
Month 4-6: Cabinet Decisions for Inter-Agency Sharing
Month 7-12: Parliamentary Process for Digital Identity Law
Year 2: Comprehensive Data Protection Law
Year 3: Cybersecurity Law Enhancement
 
I. Contact Information for Sudanese Legal Advisors
 
Suggested Contacts (To Be Obtained)
text
text
1. **Sudanese Bar Association**
   - Contact: [To be obtained]
   - Can provide referrals to qualified lawyers

2. **Ministry of Justice - Legal Drafting Department**
   - Contact: [To be obtained]
   - Can advise on legal framework development

3. **University of Khartoum - Law Faculty**
   - Contact: Prof. [Name], Faculty of Law
   - Can provide academic perspective on legal issues

4. **UNDP Sudan - Legal Advisor**
   - Contact: [To be obtained]
   - Can provide international standards and support
 
J. Deliverables Checklist
 
For Legal Advisor
text
text
[ ] Legal Gap Analysis Report (Arabic and English)
[ ] Model Legal Framework Documents (5 documents)
[ ] Partnership Agreement Templates (3 templates)
[ ] Compliance Checklist for Project Team
[ ] Presentation to Project Team (1 hour)
[ ] Presentation to Steering Committee (30 minutes)
 
For Project Team
text
text
[ ] Provide all project documents
[ ] Schedule meetings with legal advisor
[ ] Review and comment on legal documents
[ ] Incorporate legal recommendations into Project Charter
[ ] Develop legal implementation plan
[ ] Allocate budget for legal framework development
 
END OF STEP 1: LEGAL REVIEW PROCESS
 
 
STEP 2: CULTURAL SENSITIVITY REVIEW WITH SUDANESE CULTURAL ADVISORS
 
CULTURAL REVIEW PROCESS & DELIVERABLES
 
A. Objectives of Cultural Review
text
text
Primary Objectives:
1. Ensure project design respects Sudanese cultural norms and values
2. Identify potential cultural barriers to adoption
3. Adapt communication and engagement strategies
4. Ensure inclusivity across Sudanese diverse communities
5. Build trust through culturally appropriate approaches

Secondary Objectives:
- Strengthen community ownership of the project
- Enhance user experience for all Sudanese demographics
- Prevent cultural misunderstandings in implementation
- Leverage cultural strengths for project success
 
B. Cultural Advisor Selection
 
Selection Criteria
text
text
1. Expertise in Sudanese Culture:
   - Deep understanding of Sudanese social structures
   - Knowledge of tribal, ethnic, and religious diversity
   - Experience with rural and urban cultural differences
   - Understanding of gender norms and family structures

2. Experience with Development Projects:
   - Previous work with international organizations
   - Experience with digital/technology projects
   - Community engagement expertise
   - Change management in cultural contexts

3. Diversity Representation:
   - Geographic diversity (Khartoum, rural states, Port Sudan)
   - Ethnic diversity (Arab, African, etc.)
   - Religious diversity (Muslim, Christian, traditional)
   - Gender balance (male and female advisors)

4. Language Capability:
   - Fluency in Arabic (multiple dialects)
   - Understanding of English (for international coordination)
   - Knowledge of local languages (Dinka, Nuer, Fur, etc.)
 
Recommended Cultural Advisors
text
text
1. **Sudanese Cultural Anthropologists**
   - From University of Khartoum or other Sudanese universities
   - Specialization: Sudanese social structures, tribal systems
   - Contact: [To be obtained]

2. **Community Development Experts**
   - NGOs working in Sudan (e.g., Sudanese Women's Union, local community organizations)
   - Experience: Grassroots engagement, trust-building
   - Contact: [To be obtained]

3. **Religious Leaders (as advisors)**
   - Imams from major mosques in Khartoum and Port Sudan
   - Church leaders from Christian communities
   - Traditional spiritual leaders (as appropriate)
   - Contact: [To be obtained]

4. **Tribal Leaders**
   - Representatives from major tribes in pilot areas
   - Understanding of traditional governance structures
   - Contact: [To be obtained]

5. **Youth Representatives**
   - Young Sudanese professionals (digital natives)
   - Understanding of modern vs. traditional culture
   - Contact: [To be obtained]
 
C. Cultural Review Scope & Areas
 
1. Sudanese Social Structure Analysis
text
text
Family Structure:
- Extended family systems
- Patriarchal vs. matriarchal dynamics
- Age and gender hierarchies
- Decision-making processes

Tribal and Ethnic Structures:
- Major tribes in Khartoum and Port Sudan regions
- Traditional leadership structures
- Inter-tribal relations and tensions
- Tribal identification in official systems

Religious Considerations:
- Islamic practices (prayer times, Ramadan, Eid)
- Christian communities (denominations, practices)
- Traditional African religions (where relevant)
- Religious holidays and observances
 
2. Cultural Barriers to Digital Adoption
text
text
Potential Barriers:
1. **Digital Literacy Gap**
   - Urban vs. rural differences
   - Age-related gaps (elderly vs. youth)
   - Gender disparities

2. **Trust Deficit**
   - Historical distrust of government systems
   - Post-conflict trauma and security concerns
   - Privacy concerns in close-knit communities

3. **Language and Communication**
   - Arabic dialects across regions
   - Literacy levels (65% national, higher in urban areas)
   - Oral vs. written communication preferences

4. **Gender Norms**
   - Women's access to technology
   - Cultural restrictions on female participation
   - Family permission requirements

5. **Community Dynamics**
   - Collective decision-making vs. individual
   - Tribal affiliations affecting participation
   - Urban-rural divides
 
3. Cultural Adaptation Requirements
text
text
For Project Design:
- User interface design (Arabic right-to-left, cultural symbols)
- Registration process (family/group vs. individual)
- Verification methods (community-based vs. individual)
- Communication channels (radio, community meetings, not just digital)

For Communication Strategy:
- Use of traditional media (radio, community gatherings)
- Involvement of cultural leaders in messaging
- Respect for Islamic/Christian values in messaging
- Gender-appropriate outreach methods

For Training and Capacity Building:
- Culturally appropriate training methods
- Respect for traditional learning styles
- Inclusion of women in training (separate sessions if needed)
- Recognition of tribal and ethnic diversity
 
D. Cultural Review Process
 
Week 1-2: Cultural Advisor Engagement
text
text
Day 1-5: Selection of Cultural Advisory Team
- Identify and contact potential advisors
- Form a diverse cultural advisory team (5-7 members)
- Ensure geographic, ethnic, religious, and gender representation

Day 6-14: Cultural Orientation
- Present Project Charter to cultural advisors
- Explain project objectives and potential cultural implications
- Discuss cultural review methodology and timeline
 
Week 3-6: Cultural Assessment
text
text
Phase 1: Cultural Mapping (Week 3-4)
- Identify cultural groups in pilot areas (Khartoum + Port Sudan)
- Map cultural norms, values, and practices
- Identify potential cultural sensitivities

Phase 2: Cultural Risk Assessment (Week 5-6)
- Assess cultural barriers to adoption
- Identify cultural strengths to leverage
- Evaluate cultural appropriateness of project design
 
Week 7-8: Cultural Recommendations
text
text
Deliverable 1: Cultural Assessment Report
- Executive summary (Arabic)
- Detailed analysis of cultural factors
- Risk assessment and mitigation strategies

Deliverable 2: Culturally Adapted Project Design
- Recommendations for user interface
- Communication strategy adaptations
- Training and engagement modifications
- Community involvement frameworks

Deliverable 3: Cultural Engagement Toolkit
- Guidelines for cultural sensitivity
- Training materials for project team
- Community engagement templates
- Monitoring and evaluation framework
 
E. Expected Cultural Documents
 
1. Cultural Assessment Report (20-25 pages)
text
text
Structure:
1. Executive Summary (Arabic and English)
2. Methodology and Scope
3. Sudanese Cultural Context
   - Historical and social background
   - Tribal and ethnic diversity
   - Religious landscape
   - Urban-rural differences
4. Cultural Analysis of Pilot Areas
   - Khartoum State cultural dynamics
   - Port Sudan cultural dynamics
   - Key cultural influencers
5. Cultural Barriers to Digital Adoption
   - Trust issues and historical context
   - Gender and family considerations
   - Literacy and digital access
   - Language diversity
6. Cultural Strengths and Opportunities
   - Community cohesion
   - Respect for education and progress
   - Youth engagement potential
   - Mobile phone penetration
7. Cultural Risk Assessment
   - High-risk areas and mitigations
   - Medium-risk areas and mitigations
   - Low-risk areas and monitoring
8. Recommendations
   - Project design adaptations
   - Communication strategy modifications
   - Training and capacity building
   - Community engagement approach
9. Implementation Plan
   - Timeline for cultural adaptations
   - Resources required
   - Monitoring indicators
10. Appendices
    - Cultural glossary
    - Key cultural contacts
    - Research references
 
2. Culturally Adapted Project Design Recommendations
text
text
A. User Interface Design:
- Arabic right-to-left interface design
- Culturally appropriate color schemes (avoid certain colors)
- Iconography that resonates with Sudanese culture
- Voice interface for low-literacy users
- Family/group registration options

B. Registration Process:
- Community-based registration points
- Mobile registration vans for rural areas
- Female registration staff for women
- Tribal/community leader endorsements
- Verification through community structures

C. Communication Strategy:
- Radio programs in Arabic and local languages
- Community meetings with religious/traditional leaders
- SMS/USSD for basic phone users
- Visual aids for low-literacy populations
- Success stories featuring Sudanese champions

D. Training Approach:
- Separate sessions for men and women (where culturally appropriate)
- Respect for traditional learning styles (oral, demonstration)
- Inclusion of elders in training
- Youth-to-youth training (peer-to-peer)
- Recognition of tribal and ethnic diversity
 
3. Cultural Engagement Toolkit
text
text
Tool 1: Cultural Sensitivity Guidelines
- Do's and Don'ts for project staff
- Communication protocols
- Dress code and behavior expectations
- Gender interaction guidelines

Tool 2: Community Engagement Template
- Steps for engaging community leaders
- Meeting agendas for community consultations
- Feedback collection methods
- Conflict resolution approaches

Tool 3: Cultural Monitoring Framework
- Indicators for cultural acceptance
- Methods for monitoring cultural issues
- Reporting mechanisms
- Adjustment processes

Tool 4: Training Module for Project Team
- Sudanese cultural overview
- Specific cultural considerations for pilot areas
- Case studies of cultural challenges
- Role-playing exercises
 
F. Addressing Cultural Challenges
 
Potential Cultural Challenges & Solutions
text
text
Challenge 1: Gender Inequality in Digital Access
Solution:
- Women-only registration centers
- Female staff for women's services
- Mobile registration for home visits
- Family permission processes
- Success stories of women using the system

Challenge 2: Rural-Urban Digital Divide
Solution:
- USSD/SMS as primary channels in rural areas
- Community access points (schools, mosques, clinics)
- Mobile registration vans
- Training programs in local languages
- Offline capabilities for intermittent connectivity

Challenge 3: Tribal/Regional Distrust
Solution:
- Tribal leader engagement and endorsement
- Transparent communication about data usage
- Local representation in project team
- Phased rollout starting with willing communities
- Community benefit demonstrations

Challenge 4: Religious Considerations
Solution:
- Respect prayer times in scheduling
- Avoid scheduling during religious holidays
- Separate facilities for different religious groups if needed
- Islamic finance principles for any fees
- Christian community engagement in appropriate areas

Challenge 5: Oral Culture vs. Written Systems
Solution:
- Voice-based interfaces
- Visual aids and icons
- Community demonstrations
- Storytelling for communication
- Training through demonstration rather than manuals
 
G. Cultural Engagement Strategy
 
Community Engagement Plan
text
text
Level 1: National Level
- Engage with national cultural institutions
- Work with Ministry of Culture
- Partner with Sudanese cultural organizations

Level 2: Regional Level (Khartoum + Port Sudan)
- Engage with state cultural offices
- Partner with local cultural NGOs
- Work with regional tribal councils

Level 3: Community Level
- Engage with community leaders (tribal, religious, traditional)
- Partner with community-based organizations
- Work with women's groups and youth groups

Level 4: Family/Individual Level
- Family-focused engagement
- Individual trust-building
- Peer-to-peer influence
 
Cultural Champions Program
text
text
Selection:
- 50 Sudanese cultural champions (diverse representation)
- Include: Women, youth, tribal leaders, religious leaders, traditional artists
- Geographic representation from Khartoum and Port Sudan

Training:
- 5-day cultural sensitivity training
- Project overview and benefits
- Communication skills
- Community engagement techniques

Activities:
- Community meetings and demonstrations
- Radio programs and media appearances
- Social media advocacy
- Success story collection
- Feedback collection
 
H. Timeline & Budget
 
Timeline (8 Weeks)
text
text
Week 1-2: Cultural Advisor Selection & Engagement
Week 3-4: Cultural Mapping and Assessment
Week 5-6: Cultural Risk Analysis
Week 7-8: Recommendations and Toolkit Development

Total: 8 weeks (2 months)
 
Budget Estimate
text
text
Cultural Review Costs: $40,000 - $60,000
- Cultural Advisors Fees: $25,000 - $40,000 (5-7 advisors)
- Community Consultations: $5,000 - $10,000 (logistics, venues)
- Translation and Documentation: $5,000 - $10,000
- Cultural Champions Program: $5,000 (training materials, incentives)

Funding Source: Project budget (Training & Capacity Building category)
 
I. Integration with Project Design
 
Immediate Actions (Upon Receiving Cultural Report)
text
text
1. Integrate cultural recommendations into Project Charter (1 week)
2. Update technical design based on cultural insights (2 weeks)
3. Revise communication strategy (1 week)
4. Develop cultural monitoring framework (1 week)
5. Train project team on cultural sensitivity (ongoing)
 
Long-term Cultural Integration
text
text
Month 1-3: Cultural champions program launch
Month 4-6: Community engagement activities
Month 7-9: Cultural monitoring and adjustments
Month 10-12: Cultural success stories collection and sharing
Year 2: Cultural integration into Phase 2 planning
 
J. Contact Information for Cultural Advisors
 
Suggested Contacts (To Be Obtained)
text
text
1. **Sudanese Cultural Heritage Organization**
   - Contact: [To be obtained]
   - Can provide cultural experts and resources

2. **University of Khartoum - Anthropology Department**
   - Contact: [To be obtained]
   - Can provide academic cultural experts

3. **Sudanese Women's Union**
   - Contact: [To be obtained]
   - Can provide women's perspectives and networks

4. **Youth Cultural Organizations**
   - Contact: [To be obtained]
   - Can provide youth perspectives

5. **Religious Institutions**
   - Contact: [To be obtained]
   - Can provide religious perspectives and networks
 
K. Deliverables Checklist
 
For Cultural Advisors
text
text
[ ] Cultural Assessment Report (Arabic and English)
[ ] Culturally Adapted Project Design Recommendations
[ ] Cultural Engagement Toolkit
[ ] Presentation to Project Team (1 hour)
[ ] Presentation to Steering Committee (30 minutes)
 
For Project Team
text
text
[ ] Provide project documents and cultural context
[ ] Schedule cultural consultations
[ ] Review and comment on cultural documents
[ ] Incorporate cultural recommendations
[ ] Develop cultural monitoring plan
[ ] Allocate budget for cultural activities
 
END OF STEP 2: CULTURAL SENSITIVITY REVIEW
 
 
STEP 3: SDG ALIGNMENT VERIFICATION WITH UNDP SUDAN SDG UNIT
 
SDG ALIGNMENT VERIFICATION PROCESS
 
A. Objectives of SDG Alignment Verification
text
text
Primary Objectives:
1. Ensure project contributes to Sudan's SDG targets and indicators
2. Align with UNDP Sudan Country Programme Document (2021-2025)
3. Strengthen project's case for UNDP funding and support
4. Develop robust monitoring framework for SDG contributions
5. Position Sudan as leader in digital transformation for SDGs

Secondary Objectives:
- Enhance project credibility with international partners
- Improve reporting to SDG custodian agencies
- Leverage UNDP global networks for best practices
- Build capacity for SDG monitoring in Sudan
 
B. UNDP Sudan SDG Unit Engagement
 
Identifying Key Contacts
text
text
UNDP Sudan SDG Unit Structure:
1. **SDG Focal Point**
   - Role: Overall SDG coordination in Sudan
   - Contact: [To be obtained]

2. **Sustainable Development Goals Unit**
   - Role: Technical SDG support and verification
   - Contact: [To be obtained]

3. **Country Programme Officer (Digital Governance)**
   - Role: Direct project alignment support
   - Contact: [To be obtained]

4. **M&E Specialist (SDG Monitoring)**
   - Role: SDG indicator development and tracking
   - Contact: [To be obtained]

5. **Partnerships Specialist**
   - Role: Multi-stakeholder partnerships for SDGs
   - Contact: [To be obtained]
 
Engagement Strategy
text
text
Initial Engagement:
- Email introduction to UNDP Sudan SDG Unit
- Request for meeting to discuss SDG alignment
- Share Project Charter draft for preliminary review

Follow-up:
- Schedule technical meeting with SDG technical team
- Present project and seek SDG alignment verification
- Develop joint SDG monitoring framework

Ongoing Collaboration:
- Monthly SDG progress updates to UNDP
- Joint reporting to SDG custodian agencies
- Knowledge sharing on SDG digital transformation
 
C. SDG Alignment Analysis
 
1. SDG Mapping for Project SGDUS
text
text
SDG 8: Decent Work and Economic Growth
Target 8.1: Sustained per capita economic growth
Indicator 8.1.1: Annual GDP growth rate
Project Contribution: Digital formalization → increased tax base → economic growth

Target 8.3: Promote entrepreneurship and job creation
Indicator 8.3.1: Proportion of informal employment
Project Contribution: 25% increase in formal business registrations

Target 8.5: Full employment and decent work
Indicator 8.5.2: Unemployment rate (youth)
Project Contribution: 500 youth jobs in digital sector

SDG 9: Industry, Innovation and Infrastructure
Target 9.1: Develop sustainable infrastructure
Indicator 9.1.1: Proportion of rural population with access to roads
Project Contribution: Digital infrastructure in rural areas (via mobile)

Target 9.c: Increase access to ICT
Indicator 9.c.1: Proportion of population with access to ICT
Project Contribution: 40% increase in digital access among registered users

SDG 10: Reduced Inequalities
Target 10.1: Increase income of bottom 40%
Indicator 10.1.1: Growth rates of bottom 40%
Project Contribution: Economic inclusion of informal sector

Target 10.2: Social, economic and political inclusion
Indicator 10.2.1: Proportion of people below poverty line
Project Contribution: Inclusion of marginalized groups through digital access

Target 10.3: Equal opportunity and reduce inequalities
Indicator 10.3.1: Proportion of population reporting discrimination
Project Contribution: Reduced discrimination in service access

SDG 16: Peace, Justice and Strong Institutions
Target 16.5: Reduce corruption
Indicator 16.5.2: Proportion of businesses bribing officials
Project Contribution: Transparent digital processes reduce corruption

Target 16.6: Effective and accountable institutions
Indicator 16.6.1: Proportion of population satisfied with public services
Project Contribution: 50% reduction in processing times, improved satisfaction

Target 16.9: Legal identity for all
Indicator 16.9.1: Proportion of children under 5 registered at birth
Project Contribution: Digital birth registration integration

SDG 17: Partnerships for Goals
Target 17.17: Multi-stakeholder partnerships
Indicator 17.17.1: Amount of money raised through public-private partnerships
Project Contribution: $6.36M from international partners, $2.54M from private sector

Target 17.18: Data and monitoring
Indicator 17.18.1: Proportion of countries with statistical capacity
Project Contribution: Enhanced statistical capacity through digital data collection
 
2. Alignment with UNDP Sudan Country Programme
text
text
UNDP Sudan Country Programme (2021-2025) Priorities:
1. Governance and Rule of Law
   - Project alignment: Digital governance, transparency, anti-corruption
   - UNDP contribution: Technical assistance, capacity building

2. Sustainable Economic Development
   - Project alignment: Digital economy, formalization, job creation
   - UNDP contribution: Policy support, investment mobilization

3. Social Development and Inclusion
   - Project alignment: Digital inclusion, gender equality, youth empowerment
   - UNDP contribution: Training, awareness, advocacy

4. Climate Change and Resilience
   - Project alignment: Digital climate services (future phase)
   - UNDP contribution: Technical support

5. Crisis Prevention and Recovery
   - Project alignment: Post-conflict reconstruction, transparency
   - UNDP contribution: Peacebuilding support
 
3. SDG Indicator Development
text
text
Project-Specific SDG Indicators:
1. SDG 8.3.1 (Modified): Proportion of new business registrations through digital platform
   - Baseline: 0% (current paper-based system)
   - Target: 25% increase in formal registrations

2. SDG 9.c.1 (Modified): Proportion of registered users with access to digital services
   - Baseline: 40% internet penetration in Sudan
   - Target: 70% mobile penetration, 40% internet access among users

3. SDG 10.2.1 (Modified): Proportion of registered users from rural areas
   - Baseline: 30% rural population
   - Target: 40% of registrations from rural areas

4. SDG 16.5.2 (Modified): Reduction in processing time for government services
   - Baseline: 15 days for business registration
   - Target: 3 days (80% reduction)

5. SDG 16.9.1 (Modified): Proportion of births registered digitally in pilot hospitals
   - Baseline: [To be determined from Civil Registry]
   - Target: 90% of births in 5 pilot hospitals

6. SDG 17.17.1 (Modified): Amount of funding mobilized for digital transformation
   - Baseline: $0
   - Target: $15.9M (Phase 1)
 
D. SDG Alignment Verification Process
 
Week 1-2: Initial Engagement with UNDP SDG Unit
text
text
Day 1-3: Introduction and Scheduling
- Email introduction to UNDP Sudan SDG Focal Point
- Share Project Charter draft
- Request meeting to discuss SDG alignment

Day 4-14: Preliminary SDG Assessment
- UNDP SDG Unit reviews Project Charter
- Preliminary alignment assessment
- Identification of potential gaps
- Feedback provided to project team
 
Week 3-6: Technical Alignment Workshop
text
text
Workshop Structure:
Day 1: Project Presentation
- Overview of SGDUS and Phase 1
- SDG mapping and alignment
- Discussion of Sudan's SDG priorities

Day 2: SDG Indicator Workshop
- Review of existing SDG indicators
- Development of project-specific indicators
- Data collection methods and baselines

Day 3: Monitoring Framework Development
- SDG monitoring plan
- Data sources and collection methods
- Reporting mechanisms
- Integration with UNDP reporting systems

Day 4: Capacity Building
- Training on SDG monitoring for project team
- Introduction to UNDP tools and platforms
- Best practices from other countries

Day 5: Action Planning
- Develop joint action plan
- Assign responsibilities
- Set timelines for SDG verification
 
Week 7-8: Finalization and Documentation
text
text
Deliverable 1: SDG Alignment Report
- Executive summary (Arabic and English)
- Detailed SDG mapping and analysis
- Project-specific SDG indicators
- Monitoring framework

Deliverable 2: Joint Action Plan
- Responsibilities and timelines
- Data collection and reporting schedule
- Capacity building activities
- Partnership development plan

Deliverable 3: Integration into Project Documents
- Updated Project Charter with SDG alignment
- SDG-specific sections in all project documents
- SDG monitoring tools and templates
 
E. Expected SDG Documents
 
1. SDG Alignment Report (25-30 pages)
text
text
Structure:
1. Executive Summary
2. Introduction and Methodology
3. Sudan's SDG Context
   - Current SDG status and challenges
   - National SDG priorities and targets
   - UNDP Sudan's SDG strategy
4. Project SGDUS and SDGs
   - Project overview and objectives
   - SDG mapping and alignment analysis
   - Contribution to specific SDG targets and indicators
5. Project-Specific SDG Indicators
   - Indicator definitions and baselines
   - Data collection methods
   - Targets and timelines
   - Disaggregation (gender, geography, etc.)
6. SDG Monitoring Framework
   - Data sources and collection
   - Reporting mechanisms (quarterly, annual)
   - Integration with UNDP and national systems
   - Quality assurance and verification
7. Capacity Building for SDG Monitoring
   - Training needs assessment
   - Training plan for project team
   - Tools and platforms for monitoring
8. Partnerships for SDG Achievement
   - Multi-stakeholder engagement
   - Role of UNDP in SDG verification
   - Other partners and their contributions
9. Risks and Mitigation
   - Risks to SDG achievement
   - Mitigation strategies
   - Contingency plans
10. Recommendations and Next Steps
    - Immediate actions
    - Medium-term plans
    - Long-term sustainability
11. Appendices
    - SDG indicator framework
    - Data collection templates
    - Reporting templates
    - References and sources
 
2. Joint SDG Action Plan
text
text
Section 1: SDG Alignment Actions
- Action 1: Develop project-specific SDG indicators
- Action 2: Establish baseline data collection
- Action 3: Set up SDG monitoring system
- Action 4: Train project team on SDG monitoring
- Action 5: Integrate SDG reporting into project management

Section 2: Partnership Development
- Action 6: Engage other UN agencies on SDG alignment
- Action 7: Develop SDG partnerships with private sector
- Action 8: Establish SDG multi-stakeholder platform
- Action 9: Develop SDG communication strategy

Section 3: Capacity Building
- Action 10: Train 200 Sudanese staff on SDG monitoring
- Action 11: Develop SDG monitoring toolkit for Sudan
- Action 12: Establish Sudan SDG digital monitoring center
- Action 13: Share lessons with other Sudanese projects

Section 4: Reporting and Communication
- Action 14: Quarterly SDG progress reports
- Action 15: Annual SDG impact assessment
- Action 16: SDG success stories collection
- Action 17: National and international SDG reporting
 
3. Integrated SDG Monitoring Tools
text
text
Tool 1: SDG Indicator Dashboard
- Digital dashboard for real-time SDG monitoring
- Integration with project management system
- Automated reporting to UNDP and government

Tool 2: Data Collection Templates
- Standardized forms for SDG indicator data
- Mobile data collection for field staff
- Quality assurance checklists

Tool 3: Reporting Templates
- Quarterly SDG progress report template
- Annual SDG impact assessment template
- UNDP-specific reporting templates

Tool 4: Training Materials
- SDG monitoring training manual
- Case studies from other countries
- Sudan-specific examples and exercises
 
F. SDG Verification Methodology
 
1. Data Sources and Collection
text
text
Primary Data:
- Project registration database
- User satisfaction surveys
- System performance metrics
- Cost and efficiency data

Secondary Data:
- Government statistics (Central Bureau of Statistics)
- UNDP Sudan reports
- World Bank data
- SDG custodian agency reports

Data Collection Methods:
- Digital data collection (automated)
- Surveys (digital and paper)
- Interviews with stakeholders
- Focus group discussions
- System analytics
 
2. SDG Monitoring Framework
text
text
Monitoring Cycle:
- Monthly: Key performance indicators
- Quarterly: SDG progress reports
- Annual: Comprehensive SDG impact assessment
- Mid-term (Month 6): SDG alignment review
- Final (Month 12): SDG contribution evaluation

Reporting Channels:
- UNDP Sudan SDG Unit (quarterly)
- Government SDG focal point (quarterly)
- Project Steering Committee (monthly)
- Public (annual report)
 
3. Quality Assurance and Verification
text
text
Verification Methods:
- Internal audits by project M&E team
- External verification by UNDP SDG Unit
- Third-party evaluation (mid-term and final)
- Peer review by other digital transformation projects

Data Quality Standards:
- Timeliness: Data collected within specified timeframe
- Accuracy: Data validated against multiple sources
- Completeness: All required indicators covered
- Consistency: Standardized methodology across reporting periods
- Comparability: Data comparable with national and international standards
 
G. SDG Capacity Building
 
Training Program for Project Team
text
text
Module 1: Introduction to SDGs (1 day)
- 17 SDGs explained
- Sudan's SDG priorities
- Role of digital transformation in achieving SDGs

Module 2: SDG Indicators and Monitoring (2 days)
- SDG indicator framework
- Project-specific indicators development
- Data collection methods
- Monitoring tools and platforms

Module 3: SDG Reporting and Communication (1 day)
- Reporting requirements (UNDP, government, public)
- Data visualization and communication
- Success story development

Module 4: SDG Partnerships (1 day)
- Multi-stakeholder engagement
- Partnership development
- Resource mobilization for SDGs
 
Training for Government Partners
text
text
Tailored Training for Sudanese Agencies:
- Ministry of Communications: SDG monitoring in digital projects
- Ministry of Interior: Birth registration and SDG 16.9
- Ministry of Trade: Business formalization and SDG 8
- Ministry of Finance: Economic indicators and SDG 8
- National Statistics: Data collection and SDG monitoring
 
H. Timeline & Budget
 
Timeline (8 Weeks)
text
text
Week 1-2: Initial engagement with UNDP SDG Unit
Week 3-4: SDG mapping and analysis
Week 5-6: Indicator development and framework design
Week 7-8: Action plan development and documentation

Total: 8 weeks (2 months)
 
Budget Estimate
text
text
SDG Alignment Verification Costs: $30,000 - $50,000
- UNDP Technical Support: $15,000 - $25,000 (technical assistance)
- Workshop Costs: $5,000 - $10,000 (venue, logistics, materials)
- Documentation and Tools: $5,000 - $10,000
- Capacity Building: $5,000 - $5,000 (training materials, incentives)

Funding Source: Project budget (Training & Capacity Building category)
 
I. Integration with Project Management
 
SDG Integration into Project Processes
text
text
1. Project Planning:
   - SDG objectives in project objectives
   - SDG indicators in monitoring framework
   - SDG reporting in project reporting

2. Project Execution:
   - Regular SDG progress tracking
   - SDG-specific risk management
   - SDG capacity building activities

3. Project Evaluation:
   - SDG contribution assessment
   - SDG impact evaluation
   - SDG lessons learned documentation

4. Project Closure:
   - SDG sustainability plan
   - SDG knowledge transfer
   - SDG legacy documentation
 
SDG Reporting Requirements
text
text
To UNDP Sudan:
- Quarterly SDG progress reports
- Annual SDG impact assessment
- Mid-term and final evaluations

To Government of Sudan:
- Monthly project progress (including SDG aspects)
- Quarterly SDG dashboard
- Annual SDG contribution report

To Public:
- Annual SDG impact report (public version)
- SDG success stories
- Transparency portal with SDG data
 
J. Contact Information for UNDP Sudan SDG Unit
 
Suggested Contacts (To Be Obtained)
text
text
1. **UNDP Sudan SDG Focal Point**
   - Contact: [To be obtained]
   - Role: Overall SDG coordination

2. **UNDP Sudan Sustainable Development Unit**
   - Contact: [To be obtained]
   - Role: Technical SDG support

3. **UNDP Sudan Monitoring and Evaluation Specialist**
   - Contact: [To be obtained]
   - Role: SDG monitoring and verification

4. **UNDP Sudan Partnerships Specialist**
   - Contact: [To be obtained]
   - Role: Multi-stakeholder partnerships

5. **UNDP Sudan Country Programme Officer (Digital)**
   - Contact: [To be obtained]
   - Role: Digital governance and SDGs
 
K. Deliverables Checklist
 
For UNDP SDG Unit
text
text
[ ] Project Charter review and SDG alignment feedback
[ ] Technical workshop on SDG alignment (5 days)
[ ] SDG Alignment Report (Arabic and English)
[ ] Joint SDG Action Plan
[ ] Integrated SDG monitoring tools
[ ] Training sessions for project team and government partners
 
For Project Team
text
text
[ ] Provide project documents and objectives
[ ] Participate in SDG alignment workshop
[ ] Develop project-specific SDG indicators
[ ] Integrate SDG monitoring into project management
[ ] Establish reporting mechanisms
[ ] Allocate budget for SDG activities
 
END OF STEP 3: SDG ALIGNMENT VERIFICATION
 
 
STEP 4: STAKEHOLDER REVIEW WITH KEY SUDANESE STAKEHOLDERS
 
STAKEHOLDER REVIEW PROCESS & DELIVERABLES
 
A. Objectives of Stakeholder Review
text
text
Primary Objectives:
1. Gather feedback from key Sudanese stakeholders on Project Charter
2. Ensure stakeholder buy-in and commitment
3. Identify potential concerns and address them proactively
4. Strengthen stakeholder relationships and collaboration
5. Incorporate stakeholder perspectives into final project design

Secondary Objectives:
- Build trust and transparency
- Identify additional stakeholder needs
- Strengthen stakeholder engagement plan
- Enhance project ownership among stakeholders
 
B. Stakeholder Identification and Analysis
 
Key Sudanese Stakeholders for Review
text
text
1. **Government Stakeholders**
   - Ministry of Communications and IT (Primary Sponsor)
   - Ministry of Interior (Civil Registry)
   - Ministry of Trade and Industry
   - Ministry of Finance and Economic Planning
   - Ministry of Justice
   - Ministry of Land and Housing
   - National Tax Authority
   - Customs Authority (Port Sudan)
   - Prime Minister's Office

2. **International Partners**
   - UNDP Sudan
   - World Bank Sudan
   - African Development Bank
   - UAE Embassy Development Team
   - Saudi Embassy Development Team

3. **Private Sector**
   - MTN Sudan
   - Zain Sudan
   - Sudani
   - Sudanese Banks Association
   - Khartoum Chamber of Commerce
   - Port Sudan Chamber of Commerce

4. **Civil Society**
   - Transparency Sudan
   - Sudanese Women's Union
   - Sudanese Youth Organizations
   - Community-based organizations
   - Religious institutions (mosques, churches)

5. **Academic and Research Institutions**
   - University of Khartoum (IT and Law faculties)
   - Sudanese universities with digital programs
   - Research institutes focused on governance

6. **Community Representatives**
   - Tribal leaders (Khartoum and Port Sudan regions)
   - Community leaders (urban and rural)
   - Women's group representatives
   - Youth representatives
 
Stakeholder Mapping
text
text
Stakeholder Matrix:
| Stakeholder | Interest | Influence | Engagement Strategy | Review Method |
|-------------|----------|-----------|---------------------|---------------|
| Ministry of Communications | High | Very High | Direct engagement | In-person meeting |
| Ministry of Interior | High | High | Technical working groups | Workshop |
| UNDP Sudan | High | High | Partnership meetings | Joint review |
| Telecom Providers | Medium | Medium | Technical working groups | Workshop |
| Civil Society | High | Medium | Community consultations | Focus groups |
| Community Leaders | Medium | Medium | Community meetings | Town halls |
| Youth Groups | High | Low | Youth forums | Online survey + focus group |
 
C. Stakeholder Review Methodology
 
1. Review Approach (Multi-Method)
text
text
Method 1: In-Person Meetings (For Key Stakeholders)
- Government ministries
- International partners
- Major private sector partners
- Format: 2-hour structured review sessions

Method 2: Workshops (For Technical Stakeholders)
- Agency technical teams
- Private sector technical partners
- Academic experts
- Format: Half-day workshop with interactive feedback

Method 3: Focus Groups (For Civil Society and Communities)
- Women's groups
- Youth groups
- Rural community representatives
- Urban community representatives
- Format: 2-hour facilitated discussions

Method 4: Online Survey (For Broader Stakeholders)
- General public (educated segment)
- Civil society organizations
- Academic community
- Format: Structured questionnaire with open-ended questions
 
2. Review Materials
text
text
For Each Stakeholder:
1. **Project Charter Summary (5 pages)**
   - Executive summary
   - Key objectives
   - Sudanese context
   - Expected benefits
   - Request for feedback

2. **Feedback Form (Structured)**
   - Likert scale questions (1-5) on key aspects
   - Open-ended questions for detailed feedback
   - Priority ranking of concerns
   - Suggestions for improvement

3. **Discussion Guide (For Facilitated Sessions)**
   - Introduction and objectives
   - Project overview presentation
   - Guided discussion questions
   - Feedback collection
   - Next steps
 
3. Review Schedule (Month 1)
text
text
Week 1: Preparation
- Day 1-2: Finalize review materials
- Day 3-4: Schedule meetings with key stakeholders
- Day 5-7: Distribute materials to stakeholders

Week 2: Government Stakeholder Review
- Day 8: Ministry of Communications and IT
- Day 9: Ministry of Interior (Civil Registry)
- Day 10: Ministry of Trade and Industry
- Day 11: Ministry of Finance
- Day 12: Other ministries (as needed)

Week 3: International Partner and Private Sector Review
- Day 13: UNDP Sudan
- Day 14: World Bank Sudan
- Day 15: Telecom providers (MTN, Zain, Sudani)
- Day 16: Chambers of Commerce
- Day 17: Other private sector partners

Week 4: Civil Society and Community Review
- Day 18: Focus group with women's organizations
- Day 19: Focus group with youth organizations
- Day 20: Community meeting in Khartoum
- Day 21: Community meeting in Port Sudan
- Day 22-23: Online survey distribution and collection
- Day 24-25: Feedback synthesis and analysis
 
D. Stakeholder Feedback Collection
 
1. Structured Feedback Questions
text
text
For Government Ministries:
1. How well does the project align with your ministry's strategic objectives?
2. What are your main concerns about the project?
3. What resources can your ministry contribute?
4. What are the main challenges in data sharing and integration?
5. What would ensure successful implementation?

For International Partners:
1. How well does the project align with your country's SDG priorities?
2. What are your recommendations for improvement?
3. What capacity building needs do you identify?
4. How can we strengthen the partnership?
5. What are your expectations for reporting and monitoring?

For Private Sector:
1. How can the project support your business objectives?
2. What are the main barriers to your participation?
3. What incentives would encourage your involvement?
4. What are your concerns about data sharing?
5. What would make this partnership successful?

For Civil Society:
1. How can the project better serve marginalized communities?
2. What are your concerns about digital inclusion?
3. How can we ensure transparency and accountability?
4. What role should civil society play in the project?
5. How can we build trust with communities?

For Community Representatives:
1. What are the main challenges in accessing government services?
2. How would digital services improve your daily life?
3. What are your concerns about digital systems?
4. How can we ensure the system works for everyone?
5. What role should community leaders play?
 
2. Feedback Collection Methods
text
text
For In-Person Meetings:
- Structured presentation (30 minutes)
- Q&A and discussion (60 minutes)
- Feedback form collection (30 minutes)
- Note-taking and recording (with consent)

For Workshops:
- Interactive presentations
- Group discussions and activities
- Feedback cards and sticky notes
- Digital polling tools

For Focus Groups:
- Facilitated discussion
- Individual feedback collection
- Voting on priorities
- Visual feedback methods

For Online Survey:
- Structured questionnaire (15-20 questions)
- Open-ended questions for detailed feedback
- Rating scales for key aspects
- Demographic information collection
 
3. Feedback Analysis Methodology
text
text
Quantitative Analysis:
- Rating scales (1-5) analysis
- Priority ranking of concerns
- Demographic breakdown (if collected)
- Statistical significance testing (if sample size permits)

Qualitative Analysis:
- Thematic analysis of open-ended responses
- Identification of common themes and concerns
- Categorization of suggestions
- Identification of emerging issues

Synthesis:
- Combine quantitative and qualitative findings
- Identify consensus and divergence
- Prioritize feedback by impact and feasibility
- Develop response strategies for each stakeholder group
 
E. Expected Stakeholder Review Outputs
 
1. Stakeholder Feedback Report (30-40 pages)
text
text
Structure:
1. Executive Summary
2. Methodology and Scope
   - Review process
   - Stakeholder groups consulted
   - Methods used
3. Stakeholder Profiles
   - Government stakeholders
   - International partners
   - Private sector
   - Civil society
   - Community representatives
4. Feedback Analysis by Stakeholder Group
   - Government feedback and analysis
   - International partner feedback and analysis
   - Private sector feedback and analysis
   - Civil society feedback and analysis
   - Community feedback and analysis
5. Cross-Cutting Themes and Concerns
   - Common themes across all groups
   - Divergent perspectives
   - Priority concerns
6. Recommendations for Project Adjustment
   - High-priority adjustments
   - Medium-priority adjustments
   - Low-priority adjustments
   - Rationale for each adjustment
7. Stakeholder Commitment and Support
   - Commitments received
   - Resources pledged
   - Next steps for engagement
8. Appendices
   - Feedback forms and surveys
   - Meeting minutes
   - Raw data (anonymized)
   - Analysis methodology details
 
2. Revised Project Charter (Incorporating Feedback)
text
text
Changes Based on Stakeholder Feedback:
1. **Scope Adjustments**
   - Additional services or reduced scope based on feedback
   - Geographic adjustments (add/remove locations)
   - Timeline adjustments based on stakeholder capacity

2. **Governance Adjustments**
   - Steering Committee composition changes
   - Decision-making process modifications
   - Stakeholder representation changes

3. **Technical Adjustments**
   - Technology choices based on stakeholder input
   - Integration priorities based on agency feedback
   - User interface adjustments based on community feedback

4. **Budget Adjustments**
   - Reallocation based on stakeholder priorities
   - Additional funding sources identified
   - Cost-sharing arrangements revised

5. **Risk Management Adjustments**
   - Additional risks identified by stakeholders
   - Enhanced mitigation strategies
   - Stakeholder-specific risk management plans
 
3. Stakeholder Commitment Letters
text
text
For Each Key Stakeholder:
1. **Government Ministry Commitment Letter**
   - Data sharing commitment
   - Resource commitment (staff, budget, infrastructure)
   - Timeline commitment
   - Sign-off by minister or authorized representative

2. **International Partner Commitment Letter**
   - Funding commitment (amount, timeline)
   - Technical assistance commitment
   - Capacity building commitment
   - Sign-off by country director or authorized representative

3. **Private Sector Commitment Letter**
   - Partnership commitment
   - Resource contribution (infrastructure, expertise)
   - Service provision commitment
   - Sign-off by CEO or authorized representative
 
F. Addressing Stakeholder Concerns
 
Common Concerns and Responses
text
text
Concern 1: "This will create more bureaucracy, not less"
Response:
- Show efficiency metrics (50% time reduction)
- Demonstrate streamlined processes
- Highlight automation benefits
- Provide case studies from other countries

Concern 2: "Data sharing violates privacy"
Response:
- Present robust data protection framework
- Explain encryption and security measures
- Show compliance with Sudanese laws
- Offer data minimization principles

Concern 3: "We don't have the capacity to participate"
Response:
- Offer training and capacity building
- Provide technical support
- Phased implementation approach
- Resource sharing opportunities

Concern 4: "This will benefit urban areas more than rural"
Response:
- Present multi-channel access strategy
- Highlight USSD and mobile solutions
- Community access points plan
- Rural registration vans

Concern 5: "We need more time to prepare"
Response:
- Offer extended timelines for specific agencies
- Provide additional technical assistance
- Phased integration approach
- Pilot phase for learning and adjustment
 
Stakeholder-Specific Response Strategies
text
text
For Government Ministries:
- Address resource constraints with phased approach
- Provide technical support for integration
- Offer incentives (efficiency gains, cost savings)
- Ensure political cover with PMO support

For International Partners:
- Align with their strategic priorities
- Provide clear monitoring and reporting
- Offer visibility and recognition
- Ensure risk management

For Private Sector:
- Clear value proposition and ROI
- Partnership benefits (market access, reputation)
- Risk sharing and mitigation
- Long-term partnership opportunities

For Civil Society:
- Transparency and accountability mechanisms
- Inclusion in decision-making
- Capacity building for oversight
- Protection of vulnerable groups

For Communities:
- Trust-building through community leaders
- Tangible benefits demonstration
- Grievance redress mechanisms
- Cultural sensitivity
 
G. Timeline and Budget
 
Timeline (4 Weeks)
text
text
Week 1: Preparation and Scheduling
- Finalize materials
- Schedule stakeholder meetings
- Distribute materials

Week 2-3: Stakeholder Consultations
- Government meetings (Week 2)
- Partner meetings (Week 2-3)
- Civil society and community consultations (Week 3)

Week 4: Feedback Synthesis and Reporting
- Data analysis
- Report drafting
- Feedback validation
- Final report preparation

Total: 4 weeks (1 month)
 
Budget Estimate
text
text
Stakeholder Review Costs: $25,000 - $40,000
- Meeting logistics: $10,000 - $15,000 (venues, travel, materials)
- Facilitation and note-taking: $5,000 - $10,000
- Report preparation: $5,000 - $10,000
- Translation and documentation: $5,000

Funding Source: Project budget (Stakeholder Engagement category)
 
H. Integration with Project Planning
 
Immediate Actions (After Stakeholder Review)
text
text
1. Incorporate feedback into Project Charter (1 week)
2. Update stakeholder engagement plan (1 week)
3. Develop response strategies for each stakeholder group (1 week)
4. Schedule follow-up meetings to confirm commitments (ongoing)
5. Begin implementation of agreed adjustments
 
Long-term Stakeholder Management
text
text
Month 1-3: Regular stakeholder meetings (monthly)
Month 4-6: Progress reporting and feedback collection
Month 7-9: Mid-term stakeholder review
Month 10-12: Final stakeholder evaluation and lessons learned
Year 2: Stakeholder engagement in Phase 2 planning
 
I. Contact Information for Stakeholders
 
Key Stakeholder Contacts (To Be Obtained)
text
text
Government:
- Ministry of Communications: Minister's Office, IT Director
- Ministry of Interior: Civil Registry Director
- Ministry of Trade: Business Registration Director
- Ministry of Finance: Budget Director
- Prime Minister's Office: Digital Transformation Unit

International Partners:
- UNDP Sudan: Country Director, SDG Focal Point
- World Bank: Country Manager, Digital Development Specialist
- UAE Embassy: Development Cooperation Officer
- Saudi Embassy: Development Team Lead

Private Sector:
- MTN Sudan: Corporate Affairs Director
- Zain Sudan: Government Relations Director
- Sudani: CEO or equivalent
- Chambers of Commerce: President or CEO

Civil Society:
- Transparency Sudan: Executive Director
- Sudanese Women's Union: President
- Youth organizations: Representative contacts
- Religious institutions: Key leaders
 
J. Deliverables Checklist
 
For Stakeholder Review Process
text
text
[ ] Stakeholder identification and mapping
[ ] Review materials preparation (Arabic and English)
[ ] Scheduling and logistics for all meetings
[ ] Facilitation of all stakeholder sessions
[ ] Feedback collection and documentation
[ ] Analysis and synthesis of feedback
[ ] Stakeholder Feedback Report
[ ] Revised Project Charter
[ ] Stakeholder commitment letters
[ ] Presentation to Steering Committee
 
For Project Team
text
text
[ ] Provide project documents for review
[ ] Participate in stakeholder meetings
[ ] Address stakeholder concerns
[ ] Incorporate feedback into project design
[ ] Follow up on stakeholder commitments
[ ] Maintain stakeholder relationships
 
END OF STEP 4: STAKEHOLDER REVIEW PROCESS
 
 
STEP 5: FINALIZATION OF VERSION 2.0 PROJECT CHARTER
 
FINALIZATION PROCESS & DELIVERABLES
 
A. Objectives of Finalization
text
text
Primary Objectives:
1. Incorporate all feedback from legal, cultural, SDG, and stakeholder reviews
2. Create a comprehensive, approved Project Charter (Version 2.0)
3. Ensure all stakeholders understand and commit to the final charter
4. Establish baseline for project implementation
5. Create foundation for Phase 1 execution

Secondary Objectives:
- Build consensus among all parties
- Establish clear accountability
- Create reference document for all project activities
- Facilitate smooth project launch
 
B. Finalization Process
 
Week 1: Feedback Integration
text
text
Day 1-2: Consolidate All Feedback
- Compile feedback from all four review processes
- Categorize by priority (critical, important, minor)
- Identify conflicting feedback and resolve

Day 3-5: Revise Project Charter
- Incorporate legal recommendations
- Integrate cultural adaptations
- Update SDG alignment section
- Address stakeholder concerns
- Make necessary adjustments to budget, timeline, scope

Day 6-7: Internal Review
- Project team review of revised charter
- Quality assurance check
- Consistency and completeness verification
 
Week 2: Validation and Approval
text
text
Day 8-10: Stakeholder Validation
- Circulate revised charter to all reviewers
- Request final validation comments
- Address any last-minute concerns

Day 11-12: Steering Committee Review
- Present revised charter to Steering Committee
- Address any remaining questions
- Seek formal approval

Day 13-14: Finalization and Documentation
- Incorporate final Steering Committee feedback
- Prepare final Version 2.0
- Create distribution package
 
Week 3: Communication and Launch
text
text
Day 15-17: Internal Communication
- Distribute final charter to project team
- Conduct orientation session
- Establish baseline metrics

Day 18-21: External Communication
- Public announcement (press conference)
- Distribution to all stakeholders
- Social media and media outreach
- Community awareness

Day 22-25: Project Launch Activities
- Official project launch event
- Kick-off meeting with all stakeholders
- Begin implementation of Phase 1
 
C. Final Version 2.0 Project Charter Structure
 
Enhanced Sections Based on Reviews
text
text
1. Legal Framework Section (Enhanced)
   - Compliance with Sudanese laws (detailed)
   - Required legal amendments and timeline
   - Data protection and privacy framework
   - International partnership legal structure

2. Cultural Adaptation Section (New)
   - Sudanese cultural context analysis
   - Cultural barriers and mitigation strategies
   - Community engagement approach
   - Cultural monitoring framework

3. SDG Alignment Section (Enhanced)
   - Detailed SDG mapping and indicators
   - SDG monitoring and reporting framework
   - Capacity building for SDG achievement
   - Partnership for SDGs approach

4. Stakeholder Commitment Section (New)
   - Stakeholder roles and responsibilities
   - Resource commitments from each stakeholder
   - Governance structure with stakeholder representation
   - Communication and reporting mechanisms

5. Risk Management Section (Enhanced)
   - Sudanese-specific risks and mitigations
   - Cultural and social risks
   - Legal and regulatory risks
   - Stakeholder-related risks

6. Budget Section (Enhanced)
   - Detailed breakdown with Sudanese context
   - Funding sources with commitments
   - Currency risk management
   - Contingency arrangements

7. Implementation Plan (Enhanced)
   - Sudanese calendar adjustments
   - Phased approach with cultural considerations
   - Stakeholder engagement activities
   - SDG integration activities
 
Key Changes and Improvements
text
text
Based on Legal Review:
- Added legal framework section with specific Sudanese laws
- Included data protection policy framework
- Added required legal amendments and timeline
- Enhanced international partnership legal structure

Based on Cultural Review:
- Added cultural adaptation section
- Enhanced communication strategy with cultural considerations
- Added community engagement plan
- Included gender and accessibility adaptations

Based on SDG Alignment Review:
- Enhanced SDG section with specific indicators
- Added SDG monitoring framework
- Included capacity building for SDG achievement
- Enhanced partnership section for SDGs

Based on Stakeholder Review:
- Added stakeholder commitment section
- Enhanced governance structure with stakeholder representation
- Updated budget based on stakeholder input
- Added stakeholder-specific risk management
 
D. Quality Assurance and Validation
 
Validation Checklist
text
text
Legal Compliance:
[ ] All Sudanese laws referenced and addressed
[ ] Data protection requirements incorporated
[ ] International partnership legal structure clear
[ ] Required legal amendments identified and planned

Cultural Appropriateness:
[ ] Cultural context analysis included
[ ] Cultural barriers identified and mitigated
[ ] Community engagement approach detailed
[ ] Gender and accessibility considerations addressed

SDG Alignment:
[ ] All relevant SDGs mapped and aligned
[ ] Specific SDG indicators defined
[ ] Monitoring framework established
[ ] Capacity building for SDG achievement planned

Stakeholder Commitment:
[ ] Stakeholder roles and responsibilities defined
[ ] Resource commitments documented
[ ] Governance structure includes stakeholder representation
[ ] Communication and reporting mechanisms established

Overall Quality:
[ ] All sections coherent and consistent
[ ] Language clear and professional (Arabic and English)
[ ] Format professional and accessible
[ ] All attachments complete and correct
[ ] Signatures and approvals obtained
 
Validation Process
text
text
Step 1: Internal Quality Review
- Project team review against checklist
- Peer review by technical experts
- Consistency check across all sections

Step 2: External Validation
- Legal advisor validation
- Cultural advisor validation
- UNDP SDG unit validation
- Key stakeholder validation

Step 3: Steering Committee Approval
- Formal presentation of Version 2.0
- Address any final concerns
- Obtain formal approval with signatures
 
E. Final Version 2.0 Deliverables
 
1. Main Project Charter Document
text
text
Format: Professional PDF (Arabic and English versions)
Length: 50-60 pages (including appendices)
Distribution:
- Hard copies for Steering Committee members
- Digital copies for all stakeholders
- Public version (summary) for website
 
2. Executive Summary (Standalone)
text
text
Format: 2-page summary (Arabic and English)
Content:
- Project overview
- Key objectives
- Sudanese context
- Expected impact
- Budget and timeline
- Contact information
 
3. Implementation Toolkit
text
text
Toolkit Contents:
1. Project Launch Checklist
2. Monthly Progress Tracking Template
3. Stakeholder Communication Plan
4. Risk Management Template
5. Budget Tracking Template
6. SDG Monitoring Template
7. Cultural Sensitivity Guidelines
8. Legal Compliance Checklist
 
4. Presentation Materials
text
text
For Steering Committee:
- Presentation deck (30 slides)
- Q&A preparation
- Decision forms

For Project Team:
- Orientation presentation
- Training materials
- Quick reference guide

For Public:
- Infographic (Arabic)
- Video summary (2 minutes)
- Press release
 
F. Communication and Launch Strategy
 
Internal Launch (Week 3)
text
text
Day 1: Project Team Orientation
- Present final charter
- Review roles and responsibilities
- Establish communication protocols
- Set up project management tools

Day 2-3: Agency Briefings
- Individual briefings to each agency
- Review agency-specific responsibilities
- Address agency concerns
- Establish working relationships

Day 4: Kick-off Meeting
- All stakeholders present
- Formal project launch
- Commitment ceremony
- Media coverage
 
External Launch (Week 3-4)
text
text
Press Conference:
- Date: [To be scheduled]
- Location: Khartoum (with virtual option)
- Participants: PMO, Minister of Communications, UNDP, World Bank
- Content: Project announcement, benefits, next steps
- Media: National and international press

Public Communication:
- Government website announcement
- Social media campaign (Facebook, Twitter, Instagram)
- Radio announcements (Arabic stations)
- Community meetings in pilot areas
- SMS/USSD announcements to registered users

Stakeholder Communication:
- Email distribution of final charter
- Individual meetings with key stakeholders
- Webinar for broader stakeholder groups
- Regular updates through project website
 
G. Timeline and Budget for Finalization
 
Timeline (3 Weeks)
text
text
Week 1: Feedback Integration
- Consolidate all reviews
- Revise Project Charter
- Internal quality review

Week 2: Validation and Approval
- Stakeholder validation
- Steering Committee review and approval
- Final documentation

Week 3: Communication and Launch
- Internal orientation and training
- Public launch activities
- Project initiation

Total: 3 weeks
 
Budget Estimate
text
text
Finalization Costs: $20,000 - $30,000
- Document preparation and formatting: $5,000 - $8,000
- Translation (Arabic/English): $3,000 - $5,000
- Launch event and communications: $8,000 - $12,000
- Validation and quality assurance: $4,000 - $5,000

Funding Source: Project budget (Project Setup category)
 
H. Success Metrics for Finalization
 
Quality Metrics
text
text
1. Stakeholder Satisfaction: >80% satisfaction with final charter
2. Legal Compliance: 100% compliance with Sudanese laws identified
3. Cultural Appropriateness: >90% cultural advisors approve
4. SDG Alignment: 100% relevant SDGs mapped with indicators
5. Completeness: All required sections included and approved
 
Process Metrics
text
text
1. Timeline Adherence: Finalization within 3 weeks
2. Budget Adherence: Within 10% of finalization budget
3. Stakeholder Engagement: 100% of key stakeholders reviewed
4. Approval Rate: Unanimous or majority approval by Steering Committee
5. Communication Reach: >80% of target audience reached
 
I. Post-Finalization Activities
 
Immediate Actions (First Month)
text
text
Week 1: Team Onboarding
- Project team training on charter
- Role clarification and assignment
- Tool setup and access
- Initial task assignments

Week 2: Agency Coordination
- Data sharing agreements finalization
- Integration planning begins
- Resource mobilization
- Infrastructure procurement starts

Week 3: Pilot Preparation
- Pilot site selection finalization
- Community engagement begins
- Training program development
- Monitoring system setup

Week 4: Implementation Kick-off
- Development sprints begin
- Integration activities start
- Regular reporting established
- Risk management activated
 
Long-term Sustainability
text
text
Month 2-6: Regular Review
- Monthly progress against charter
- Quarterly charter review and adjustment
- Annual comprehensive review
- Version control for charter updates

Year 1: Charter Evolution
- Version 2.1 (minor updates)
- Version 2.2 (major adjustments if needed)
- Version 3.0 (Phase 2 charter)

Ongoing: Stakeholder Management
- Regular stakeholder communication
- Annual stakeholder satisfaction survey
- Continuous improvement based on feedback
 
J. Deliverables Checklist for Finalization
 
Final Version 2.0 Project Charter
text
text
[ ] Complete document (50-60 pages)
[ ] Arabic and English versions
[ ] Executive summary (2 pages each language)
[ ] All appendices included
[ ] Signatures and approvals obtained
[ ] Version control established (Version 2.0)
[ ] Distribution to all stakeholders
[ ] Public version (summary) prepared
 
Implementation Toolkit
text
text
[ ] Project Launch Checklist
[ ] Monthly Progress Tracking Template
[ ] Stakeholder Communication Plan
[ ] Risk Management Template
[ ] Budget Tracking Template
[ ] SDG Monitoring Template
[ ] Cultural Sensitivity Guidelines
[ ] Legal Compliance Checklist
 
Communication Materials
text
text
[ ] Steering Committee Presentation Deck
[ ] Project Team Orientation Materials
[ ] Public Infographic (Arabic)
[ ] Press Release
[ ] Social Media Campaign Plan
[ ] Website Content
 
END OF STEP 5: FINALIZATION PROCESS
 
 
INTEGRATED FINALIZATION TIMELINE
 
Overall Timeline for All 5 Steps
text
text
Step 1: Legal Review (Weeks 1-2)
Step 2: Cultural Review (Weeks 3-4)
Step 3: SDG Alignment (Weeks 5-6)
Step 4: Stakeholder Review (Weeks 7-8)
Step 5: Finalization (Weeks 9-11)

Total: 11 weeks (approximately 2.5 months)
 
Critical Path
text
text
1. Legal Review must complete before Cultural Review can begin
2. Cultural Review can parallel with SDG Alignment (partial overlap)
3. Stakeholder Review depends on outputs from all previous reviews
4. Finalization depends on completion of all reviews
 
Resource Requirements
text
text
Human Resources:
- Project Director (full-time)
- Legal Advisor (part-time, 8 weeks)
- Cultural Advisors (part-time, 8 weeks)
- UNDP SDG Unit (part-time, 8 weeks)
- Stakeholder Engagement Team (full-time, 4 weeks)
- Documentation Team (full-time, 3 weeks)

Budget:
- Legal Review: $50,000 - $75,000
- Cultural Review: $40,000 - $60,000
- SDG Alignment: $30,000 - $50,000
- Stakeholder Review: $25,000 - $40,000
- Finalization: $20,000 - $30,000
- Total: $165,000 - $255,000 (from project budget)
 
Success Indicators
text
text
1. Legal Compliance: 100% compliance with Sudanese laws
2. Cultural Appropriateness: >90% cultural advisor approval
3. SDG Alignment: 100% relevant SDGs mapped with indicators
4. Stakeholder Buy-in: >80% stakeholder satisfaction
5. Charter Quality: Professional, comprehensive, approved
6. Timeline Adherence: Within 11 weeks
7. Budget Adherence: Within 10% of allocated budget
 
END OF INTEGRATED FINALIZATION PLAN
 
 
Next Steps After Finalization:
1.Begin Implementation of Phase 1 Activities (as outlined in Step 3 of previous response)
2.Proceed with Funding Strategy (Step 4 of previous response)
3.Establish Project Management Office and begin execution
4.Launch Communication and Change Management activities
 
Would you like me to elaborate on any specific aspect of these five steps or provide additional templates and tools for implementation?
Let us see about all the following one by one: Begin Implementation of Phase 1 Activities (as outlined in Step 3 of previous response)
2.Proceed with Funding Strategy (Step 4 of previous response)
3.Establish Project Management Office and begin execution
4.Launch Communication and Change Management activities

STEP 1: BEGIN IMPLEMENTATION OF PHASE 1 ACTIVITIES
 
PHASE 1 IMPLEMENTATION ROADMAP (MONTHS 1-12)
 
A. Month 1: Project Launch & Team Setup
 
Week 1-2: Official Launch Activities
text
text
Day 1-2: Project Announcement
- Press Conference in Khartoum
  - Participants: Prime Minister's Office, Minister of Communications, UNDP, World Bank
  - Media: National TV (Sudan TV), Radio (Sudan Radio), International Media (BBC Arabic, Al Jazeera)
  - Social Media: Live streaming on Facebook, Twitter, Instagram
  - Press Release: Arabic and English (distributed to all Sudanese media outlets)

Day 3-5: Internal Launch
- All-staff meeting with project team
- Review of Project Charter (Version 2.0)
- Assignment of initial tasks and responsibilities
- Setup of project office in Khartoum (location: Ministry of Communications building)

Day 6-10: Stakeholder Kick-off Meetings
- Individual meetings with each ministry (1 hour each)
- Review of agency-specific responsibilities
- Establish working relationships
- Set up communication channels

Day 11-14: Team Onboarding
- IT setup: laptops, software, access rights
- Security clearances for team members
- Introduction to project tools and processes
- Initial training on Sudanese context and project objectives
 
Week 3-4: Core Team Formation
text
text
Recruitment Activities:
1. Project Director (Sudanese, 10+ years experience)
   - Recruitment method: International recruitment firms (Michael Page, Hays) + local networks
   - Timeline: 2 weeks for shortlisting, 1 week for interviews, 1 week for offer
   - Start date: End of Month 1

2. Technical Lead (Sudanese or international with Sudan experience)
   - Recruitment method: UNDP/World Bank networks, LinkedIn, tech communities
   - Timeline: 2 weeks for shortlisting, 1 week for interviews, 1 week for offer
   - Start date: End of Month 1

3. Core Team Members (30 positions)
   - 20 Ministry secondments (15% time commitment)
   - 12 Local hires (recruited in Sudan)
   - 3 International experts (embedded for 6 months)
   - Recruitment timeline: 4 weeks (parallel processing)

Onboarding Plan:
- Week 1: Project introduction and Sudanese context
- Week 2: Technical training and tool setup
- Week 3: Stakeholder mapping and agency introductions
- Week 4: Initial task assignments and sprint planning
 
B. Month 2: Legal Framework & Infrastructure
 
Week 5-6: Legal Framework Development
text
text
Key Activities:
1. Legal Gap Analysis (with Sudanese legal advisor)
   - Review existing laws (Electronic Transactions Act 2007, Civil Registry Act 1994, etc.)
   - Identify required amendments
   - Draft digital identity recognition law
   - Develop data sharing agreements template

2. Regulatory Engagement
   - Meeting with Ministry of Justice (legal drafting department)
   - Consultation with National Intelligence and Security Service (NISS) on security
   - Engagement with telecommunications regulator (NTRA)

3. Legal Documentation
   - Data Protection Policy (aligned with Sudanese laws and international standards)
   - Privacy Impact Assessment (Sudanese-specific)
   - Terms of Service for citizens and businesses (Arabic and English)
   - Agency Data Sharing Agreements (5 agencies)

Deliverables:
- Legal Gap Analysis Report (Week 6)
- Draft Digital Identity Recognition Law (Week 8)
- Data Sharing Agreement Templates (Week 6)
- Compliance Checklist (Week 6)
 
Week 7-8: Infrastructure Procurement
text
text
Cloud Infrastructure:
- Evaluate providers: AWS, Azure, Google Cloud (regional presence in Middle East)
- Consider hybrid model: Cloud + on-premise in Sudan
- Procurement process: International tender (UNDP can assist with procurement)
- Timeline: 6-8 weeks for contract and setup
- Budget: $4M allocated (from project budget)

Local Infrastructure:
- Office space in Khartoum (secure, with backup power)
  - Location: Ministry of Communications building or dedicated space
  - Features: 24/7 security, generator, UPS, internet redundancy
  - Cost: $50,000/year (from project budget)

Network Connectivity:
- Primary ISP: Canar Telecom or Sudani (Sudanese providers)
- Backup ISP: Zain or MTN (mobile broadband)
- VPN setup for secure agency connections
- Cost: $10,000/month (from project budget)

Development Environment:
- Set up development servers (local or cloud)
- Configure version control (Git)
- Establish CI/CD pipeline
- Security scanning tools (SonarQube, OWASP ZAP)
- Cost: $20,000 (from project budget)
 
C. Month 3: Requirements & Design
 
Week 9-10: Requirements Workshops
text
text
Workshop Schedule (Arabic language, with English translation for international experts):

Day 1-2: Civil Registry Workshop (Ministry of Interior)
- Participants: Civil Registry Director, IT staff, data owners
- Location: Ministry of Interior, Khartoum
- Focus: Birth registration process, family structure, existing data
- Output: Data dictionary, integration requirements, process maps

Day 3-4: Business Registration Workshop (Ministry of Trade)
- Participants: Business Registration Director, IT staff, business owners
- Location: Ministry of Trade, Khartoum
- Focus: Current process (15 days), documents required, fees
- Output: Business registration workflow, integration points, user stories

Day 5-6: Tax Authority Workshop
- Participants: Tax Authority Commissioner, IT staff
- Location: National Tax Authority, Khartoum
- Focus: Tax ID generation, existing tax system
- Output: Tax integration requirements, data formats, security requirements

Day 7-8: Customs Workshop (Port Sudan)
- Participants: Customs Authority Director, Port Sudan Free Zone managers
- Location: Port Sudan (travel from Khartoum)
- Focus: Export/import process, documentation
- Output: Customs integration requirements, EDI specifications

Day 9-10: Land Registry Workshop
- Participants: Ministry of Land and Housing Director, IT staff
- Location: Ministry of Land, Khartoum
- Focus: Property registration, existing system
- Output: Land registry integration requirements, data models

Workshop Logistics:
- Venue: Ministry meeting rooms (no additional cost)
- Translation: Arabic/English simultaneous interpretation
- Documentation: Digital and printed materials
- Cost: $15,000 (travel, materials, facilitation)
 
Week 11-12: System Design
text
text
Technical Design Sessions (Parallel Tracks):

Track 1: OID System Design (2 days)
- Finalize OID hierarchy for Sudan
- Design OID assignment algorithm
- Create OID resolution service architecture
- Deliverable: OID System Design Document

Track 2: Identity System Design (2 days)
- Citizen data model (Sudanese demographics)
- Business data model (SME-focused)
- Biometric integration (fingerprint, facial)
- Deliverable: Identity System Design Document

Track 3: API Design (2 days)
- RESTful API specifications
- Authentication/authorization design
- Error handling and logging
- Deliverable: API Design Document

Track 4: UI/UX Design (3 days)
- Citizen portal (mobile-first)
- Business portal (web and mobile)
- Admin dashboard (Arabic interface)
- USSD menu design (Arabic and English)
- Deliverable: UI/UX Design Document

Design Tools:
- Architecture: Draw.io, Lucidchart
- UI/UX: Figma, Adobe XD
- Documentation: Confluence, Google Docs
- Cost: $5,000 (software licenses, tools)
 
D. Months 4-6: Core Development
 
Development Sprints (2-week cycles)
text
text
Sprint 1 (Month 4, Weeks 1-2):
- OID Registry Service (MVP)
- Basic identity registration API
- API Gateway setup (Kong/Nginx)
- Security baseline implementation
- Daily stand-ups: 9:00 AM, 15 minutes
- Sprint planning: Monday 10:00 AM
- Sprint review: Friday 3:00 PM

Sprint 2 (Month 4, Weeks 3-4):
- Citizen registration module
- Business registration module
- Basic verification services
- Audit logging system
- Integration with Civil Registry (API)

Sprint 3 (Month 5, Weeks 1-2):
- Biometric integration (fingerprint)
- De-duplication engine
- USSD interface development
- Mobile app (Android first)

Sprint 4 (Month 5, Weeks 3-4):
- API Gateway enhancements
- Rate limiting and throttling
- Performance optimization
- Security hardening

Sprint 5 (Month 6, Weeks 1-2):
- Integration with Business Registration (API)
- Integration with Tax Authority (file-based)
- Data mapping and transformation
- Initial testing

Sprint 6 (Month 6, Weeks 3-4):
- Integration with Customs (EDI)
- Integration with Land Registry
- User acceptance testing preparation
- Documentation updates
 
Development Team Structure
text
text
Squad 1: OID & Identity Core (6 developers)
- Lead: Senior Java/Python developer
- Members: 5 developers (3 Sudanese, 2 international)

Squad 2: API & Integration (5 developers)
- Lead: API architect
- Members: 4 developers (3 Sudanese, 1 international)

Squad 3: Frontend & Mobile (5 developers)
- Lead: UX/UI designer
- Members: 4 developers (4 Sudanese)

Squad 4: Security & DevOps (4 developers)
- Lead: Security architect
- Members: 3 developers (2 Sudanese, 1 international)

Squad 5: QA & Testing (3 testers)
- Lead: QA manager
- Members: 2 testers (2 Sudanese)

Daily Stand-ups: 15 minutes (9:00 AM)
Sprint Planning: Every 2 weeks (Monday 10:00 AM)
Sprint Review: Every 2 weeks (Friday 3:00 PM)
Retrospective: Every 2 weeks (Friday 4:00 PM)
 
E. Months 7-9: Integration & Testing
 
Integration Strategy
text
text
Phased Integration Approach:
Phase A (Month 7): Civil Registry + Business Registration
  - Week 1-2: Civil Registry integration (API)
  - Week 3-4: Business Registration integration (API)
  - Week 5-6: Testing and validation
  - Week 7-8: Deployment to staging

Phase B (Month 8): Tax Authority + Customs
  - Week 1-2: Tax Authority integration (file-based)
  - Week 3-4: Customs integration (EDI)
  - Week 5-6: Testing and validation
  - Week 7-8: Deployment to staging

Phase C (Month 9): Land Registry + Final Integration
  - Week 1-2: Land Registry integration
  - Week 3-4: End-to-end workflow testing
  - Week 5-6: Security audit
  - Week 7-8: User acceptance testing

Integration Methodology:
1. Agency Workshops (technical teams)
2. API Specification Finalization
3. Development of Adapters
4. Testing in Sandbox Environment
5. Production Deployment (staged)
6. Monitoring and Validation
 
Testing Strategy
text
text
Testing Phases:
1. Unit Testing (ongoing): Code-level testing (Sprint 1-6)
2. Integration Testing (Month 7-8): Agency system integration
3. System Testing (Month 8): End-to-end workflows
4. Performance Testing (Month 8): Load and stress testing
5. Security Testing (Month 9): Penetration testing, vulnerability assessment
6. User Acceptance Testing (Month 9): Real users in controlled environment

Sudan-Specific Testing Considerations:
- Test on low-bandwidth connections (2G/3G)
- Test USSD functionality with major telecom providers (MTN, Zain, Sudani)
- Test with different mobile devices (feature phones, smartphones)
- Test with Arabic text (right-to-left display)
- Test with Sudanese names and address formats
- Test with intermittent connectivity scenarios

Testing Environment:
- Staging environment: Mirror of production
- Test data: Anonymized production data (where possible)
- Load testing: 10,000 concurrent users
- Security testing: OWASP Top 10, Sudanese cybersecurity standards
 
F. Months 10-12: Pilot Launch & Evaluation
 
Pilot Preparation (Month 10)
text
text
Week 1-2: Pilot Design
- Select 5 hospitals in Khartoum for birth registration
  - Hospital 1: Khartoum Teaching Hospital
  - Hospital 2: Omdurman Maternity Hospital
  - Hospital 3: Khartoum North Hospital
  - Hospital 4: Port Sudan Hospital
  - Hospital 5: El Obeid Hospital (considering connectivity)

- Select 5 business registration offices in Khartoum
  - Office 1: Khartoum State Business Registration Office
  - Office 2: Khartoum North Office
  - Office 3: Omdurman Office
  - Office 4: Port Sudan Free Zone Office
  - Office 5: El Obeid Office

- Select 2 locations in Port Sudan for export businesses
  - Location 1: Port Sudan Customs Office
  - Location 2: Port Sudan Free Zone Administration

- Define success metrics for each service
  - Birth registration: 90% of births registered within 24 hours
  - Business registration: 80% of applications processed within 3 days
  - Export licensing: 70% reduction in processing time

Week 3-4: Pilot Infrastructure
- Set up pilot servers (separate from production)
- Configure monitoring and alerting (Prometheus, Grafana)
- Prepare pilot support team (20 staff)
  - 5 at hospitals (1 per hospital)
  - 5 at business registration offices
  - 5 at Port Sudan locations
  - 5 at central support (24/7 helpdesk)

- Develop training materials (Arabic and English)
  - User manuals (illustrated for low literacy)
  - Video tutorials (Arabic)
  - Quick reference cards

Week 5-6: User Recruitment
- Partner with hospitals for birth registration (target: 1,000 births/month)
- Engage business associations for business registration (target: 500 businesses/month)
- Work with export associations in Port Sudan (target: 100 exporters/month)
- Set up pilot user support channels
  - Helpline: 24/7 call center (Arabic/English)
  - WhatsApp support group
  - Community support points (10 locations)

Pilot Incentives:
- First 10,000 users get free airtime (50 SDG each)
- Businesses get 50% discount on registration fees for first 3 months
- Public recognition for early adopters
 
Soft Launch (Month 10, Week 4)
text
text
Target: 1,000 users
Services: Birth registration only (civil registry)
Locations: 5 hospitals in Khartoum
Support: On-site support staff at each hospital
Feedback: Daily surveys, weekly focus groups

Success Criteria:
- 95% registration success rate
- Average registration time < 10 minutes
- User satisfaction > 4/5
- Zero critical bugs
- System uptime > 99%

Launch Event:
- Date: [To be scheduled - Week 4 of Month 10]
- Location: Khartoum Teaching Hospital
- Participants: Minister of Communications, Minister of Interior, UNDP, World Bank, hospital staff, first users
- Media: National TV, radio, newspapers
- Activities: Live demonstration, user testimonials, media interviews
 
Full Pilot Launch (Month 11)
text
text
Target: 500,000 users
Services: All 5 integrated services
Locations: Khartoum State + Port Sudan
Support: 24/7 helpdesk, community support points
Marketing: Radio, TV, social media, community meetings

Marketing Campaign (Month 11):
- Radio: Daily spots on popular stations (Sudan Radio, FM 96, etc.)
  - Morning drive time (6-9 AM)
  - Evening drive time (5-8 PM)
  - Cost: $20,000/month

- TV: 30-second commercials on Sudan TV
  - Prime time slots (7-9 PM)
  - Cost: $30,000/month

- Social Media: Facebook, WhatsApp, Twitter
  - Targeted ads (Khartoum, Port Sudan)
  - Influencer partnerships
  - Cost: $10,000/month

- Community: Meetings at mosques, churches, community centers
  - 50 meetings in Month 11
  - Cost: $5,000 (venue, materials, transportation)

- Incentives: First 50,000 users get free airtime (100 SDG each)
  - Cost: $850,000 (from project budget)

Total Marketing Budget: $25,000/month + $850,000 incentives = $875,000
 
Evaluation & Phase 2 Planning (Month 12)
text
text
Evaluation Activities:
1. Data Collection
   - System usage statistics (daily, weekly, monthly)
   - User satisfaction surveys (random sample of 5,000 users)
   - Agency feedback (interviews with 50 staff)
   - Cost analysis (actual vs. budget)

2. Analysis
   - Success against KPIs (see below)
   - Lessons learned
   - Technical performance assessment
   - Financial analysis

3. Reporting
   - Executive summary for Steering Committee (10 pages)
   - Detailed technical report (30 pages)
   - Financial report (10 pages)
   - Phase 2 recommendations (15 pages)

4. Phase 2 Planning
   - Scope definition (expansion to 5 more states)
   - Budget estimation ($25M for Phase 2)
   - Timeline development (24 months)
   - Partnership strategy (additional funding sources)

Success KPIs (Month 12):
- User Adoption: 500,000 registered citizens (50% women, 40% rural)
- Business Registrations: 5,000 new formal businesses
- Processing Time: 50% reduction (15 days → 7.5 days)
- System Performance: 99.5% uptime, <2s response time
- User Satisfaction: >80% satisfaction rate
- Cost Efficiency: Within 10% of budget
- Security: Zero critical vulnerabilities
- SDG Alignment: 100% of relevant SDG indicators on track
 
G. Monthly Governance & Reporting
 
Steering Committee Meetings (Monthly)
text
text
First Monday of each month, 9:00 AM
Duration: 3 hours
Location: Khartoum (with virtual option for international partners)
Language: Arabic (with English translation)

Agenda Template:
1. Review of previous month's progress (15 min)
2. Key achievements and milestones (15 min)
3. Issues and risks requiring decisions (30 min)
4. Budget status and variances (15 min)
5. Upcoming month plan (15 min)
6. Decisions required (30 min)
7. Any other business (15 min)

Deliverables:
- Monthly progress report (5 pages)
- Budget variance report
- Risk register update
- Decision log
- Action items list
 
Technical Committee Meetings (Bi-weekly)
text
text
Every other Wednesday, 2:00 PM
Duration: 2 hours
Location: Khartoum (hybrid)

Focus: Technical decisions, integration issues, architecture reviews
 
Project Management Office (Weekly)
text
text
Every Monday, 10:00 AM
Duration: 1 hour
Location: Khartoum

Focus: Task tracking, issue resolution, resource coordination
 
H. Resource Allocation & Budget Management
 
Monthly Budget Allocation (Example: Month 3)
text
text
Total Monthly Budget: ~$1.3M
- Personnel: $250,000 (20 FTEs)
- Infrastructure: $150,000 (cloud, office, connectivity)
- Development: $400,000 (tools, software, contractors)
- Integration: $200,000 (agency workshops, adapters)
- Training: $100,000 (materials, trainers)
- Contingency: $200,000
 
Resource Management Strategy
text
text
1. Human Resources
   - Local hires: 80% of team (Sudanese professionals)
   - International experts: 20% (technical advisors)
   - Ministry secondments: 15% time commitment
   - Contractors: Specialized skills (security, UX)

2. Financial Management
   - Separate project account (UNDP/World Bank managed)
   - Monthly financial reports to Steering Committee
   - Quarterly external audit
   - Real-time expense tracking system

3. Procurement
   - International tenders for >$50,000
   - Local procurement for < $50,000
   - UNDP procurement support for international
   - Competitive bidding process
 
I. Communication & Change Management
 
Internal Communication
text
text
Channels:
- Project Intranet: SharePoint or similar
- Weekly newsletter (Arabic and English)
- Monthly all-hands meetings
- WhatsApp group for urgent communication

Content:
- Progress updates
- Celebrations and milestones
- Challenges and solutions
- Upcoming activities
 
External Communication
text
text
Stakeholder Updates:
- Monthly to Steering Committee
- Bi-weekly to agency partners
- Quarterly to international partners
- Monthly to public (press releases, social media)

Public Communication:
- Website: www.sgdus.gov.sd (under construction)
- Social media: Facebook, Twitter, Instagram
- Radio: Monthly updates on popular stations
- Community meetings: Monthly in pilot areas
 
J. Risk Management in Execution
 
Weekly Risk Review
text
text
Every Friday, 3:00 PM
Participants: Project Director, Risk Owner, Technical Lead
Format: 1-hour review meeting

Process:
1. Review risk register (new risks, updated scores)
2. Assess mitigation effectiveness
3. Update contingency plans
4. Escalate if needed
 
Contingency Activation
text
text
Triggers:
- Risk score increases by >5 points
- Mitigation fails or is delayed
- New high-risk item emerges
- External event affects project

Process:
1. Risk owner submits contingency request
2. PMO reviews within 24 hours
3. Approval based on amount (as per charter)
4. Implementation and tracking
 
K. Success Metrics & KPIs
 
Monthly KPIs to Track
text
text
1. Schedule Performance
   - Planned vs. actual milestones
   - Critical path status

2. Budget Performance
   - Planned vs. actual expenditure
   - Variance analysis

3. Quality Metrics
   - Defect density (per 1,000 lines of code)
   - Test coverage
   - Security vulnerabilities

4. Team Performance
   - Velocity (story points completed)
   - Team satisfaction
   - Turnover rate

5. Stakeholder Satisfaction
   - Agency satisfaction score
   - Partner satisfaction score
   - User satisfaction (pilot phase)
 
END OF STEP 1: PHASE 1 IMPLEMENTATION
 
 
STEP 2: PROCEED WITH FUNDING STRATEGY
 
TARGETED FUNDING STRATEGY (SUDAN CONTEXT)
 
A. Partner Identification & Prioritization
 
Tier 1 Partners (High Priority - $4-6M Target)
text
text
1. UNDP Sudan
   - Contact: Dr. Aida M. Al-Amin, Country Director
   - Potential: $2-3 million
   - Focus: Digital governance, capacity building
   - Program: Sudan Digital Transformation Program
   - Timeline: 3-4 months for approval
   - Proposal Focus: SDG alignment, governance reform, capacity building

2. World Bank (IDA)
   - Contact: Mr. Hervé L. Lemoine, Country Manager
   - Potential: $2-3 million
   - Focus: Digital development, economic inclusion
   - Program: Digital Development Partnership (DDP)
   - Timeline: 4-6 months for approval
   - Proposal Focus: Economic growth, job creation, private sector engagement

3. African Development Bank
   - Contact: Sudan Country Office
   - Potential: $1-2 million
   - Focus: Infrastructure, digital economy
   - Program: Digital Transformation Fund
   - Timeline: 3-5 months for approval
   - Proposal Focus: Regional integration, infrastructure development
 
Tier 2 Partners (Medium Priority - $2-3M Target)
text
text
4. Islamic Development Bank
   - Contact: Regional Office in Khartoum
   - Potential: $1-2 million
   - Focus: Sharia-compliant financing
   - Program: Digital Infrastructure Fund
   - Timeline: 4-6 months
   - Proposal Focus: Islamic finance principles, regional development

5. UAE Development Funds
   - Contact: UAE Embassy in Khartoum
   - Potential: $1-2 million
   - Focus: Regional development, technology transfer
   - Program: UAE-Sudan Partnership Fund
   - Timeline: 2-3 months (fast-track)
   - Proposal Focus: Technology transfer, knowledge sharing, GCC-Sudan relations

6. Saudi Arabia (KSRelief/SFD)
   - Contact: Saudi Embassy in Khartoum
   - Potential: $1-2 million
   - Focus: Development assistance
   - Program: Saudi-Sudan Development Cooperation
   - Timeline: 3-4 months
   - Proposal Focus: Humanitarian-development nexus, post-conflict reconstruction
 
Tier 3 Partners (Additional - $1-2M Target)
text
text
7. European Union
   - Contact: EU Delegation to Sudan
   - Potential: $500K-1M
   - Focus: Governance, human rights
   - Program: EU Sudan Support
   - Timeline: 6-8 months
   - Proposal Focus: Governance reform, transparency, human rights

8. USAID
   - Contact: USAID Sudan Mission
   - Potential: $500K-1M
   - Focus: Economic growth, governance
   - Program: Sudan Growth and Resilience
   - Timeline: 6-9 months
   - Proposal Focus: Economic inclusion, youth empowerment

9. Private Sector (Corporate Social Responsibility)
   - MTN Sudan, Zain Sudan, Sudani
   - Potential: $100K-500K each
   - Focus: Connectivity, digital inclusion
   - Program: CSR initiatives
   - Timeline: 1-2 months
   - Proposal Focus: Network access, USSD channels, community support
 
B. Proposal Development for Each Partner
 
1. UNDP Sudan Proposal
text
text
Executive Summary (Arabic and English)
- Align with UNDP Sudan Country Programme Document (2021-2025)
- Focus on SDG 16 (Peace, Justice, Strong Institutions)
- Emphasize capacity development (UNDP's core strength)

Specific Elements:
- Technical Assistance: Embedded experts (6 months)
- Capacity Building: Training 200 Sudanese staff
- Knowledge Transfer: Study visits to Estonia/India
- Sustainability: Exit strategy with government ownership

Budget Request: $2.5 million
- Personnel: $800,000 (international experts, local staff)
- Capacity Building: $600,000 (training, study visits)
- Technical Assistance: $500,000 (consultants, advisors)
- Operations: $400,000 (office, travel, communications)
- Contingency: $200,000

Timeline: 12 months (aligned with Phase 1)
Reporting: Quarterly to UNDP Country Office

Sudan-Specific Elements:
- Focus on post-conflict governance reform
- Inclusion of marginalized communities
- Women's empowerment through digital access
- Youth employment in digital sector
 
2. World Bank Proposal
text
text
Executive Summary
- Align with World Bank Country Partnership Framework (Sudan)
- Focus on Digital Development Partnership (DDP) principles
- Emphasize economic growth and job creation

Specific Elements:
- Digital Infrastructure: Cloud infrastructure setup
- Institutional Strengthening: Legal and regulatory framework
- Private Sector Engagement: Telecom partnerships
- Results-Based Financing: Disbursements tied to milestones

Budget Request: $2 million
- Infrastructure: $800,000 (cloud, security, connectivity)
- Institutional Strengthening: $500,000 (legal framework, policy)
- Private Sector Engagement: $400,000 (partnerships, incentives)
- Monitoring & Evaluation: $200,000
- Contingency: $100,000

Financing Instrument: Grant (no repayment required)
Disbursement: Linked to milestones (Month 3, 6, 9, 12)

Sudan-Specific Elements:
- Focus on economic formalization
- Job creation for youth (70% under 30)
- Improved business environment (Ease of Doing Business)
- Enhanced revenue collection (fiscal sustainability)
 
3. UAE Proposal
text
text
Executive Summary
- Align with UAE's Africa development strategy
- Focus on technology transfer and knowledge sharing
- Emphasize regional cooperation (GCC-Sudan)

Specific Elements:
- Technology Transfer: UAE smart city expertise
- Training: UAE study visits for Sudanese team
- Infrastructure: UAE cloud services (if regional)
- Partnerships: UAE private sector engagement

Budget Request: $1.5 million
- Technology Transfer: $600,000 (UAE experts, knowledge sharing)
- Training: $400,000 (study visits, workshops)
- Infrastructure: $300,000 (cloud services, equipment)
- Operations: $200,000

Timeline: 12 months
Reporting: Monthly to UAE Embassy

Sudan-Specific Elements:
- Focus on regional leadership in digital transformation
- Knowledge transfer from UAE's experience
- Potential for UAE-Sudan digital corridor
- Alignment with UAE's Africa strategy
 
C. Proposal Submission Strategy
 
1. Submission Timeline
text
text
Month 1-2: Develop proposals for Tier 1 partners
Month 3: Submit to UNDP, World Bank, AfDB
Month 4: Follow-up meetings with Tier 1 partners
Month 5: Develop proposals for Tier 2 partners
Month 6: Submit to Islamic Dev Bank, UAE, Saudi
Month 7: Follow-up with Tier 2 partners
Month 8: Develop Tier 3 proposals (if needed)
Month 9-12: Negotiation and agreement finalization
 
2. Proposal Submission Checklist
text
text
For Each Proposal:
- [ ] Executive Summary (1 page)
- [ ] Project Description (5 pages)
- [ ] Budget Breakdown (detailed)
- [ ] Logical Framework (LogFrame)
- [ ] Risk Assessment
- [ ] Sustainability Plan
- [ ] Team CVs (key personnel)
- [ ] Letters of Support (from government)
- [ ] Organizational Capacity Statement
- [ ] Compliance with partner requirements
- [ ] Arabic and English versions
- [ ] Sudanese context and alignment
 
3. Follow-up Strategy
text
text
After Submission:
Week 1: Acknowledgement receipt
Week 2-4: Regular follow-up emails/calls
Month 2: Request for clarification (if needed)
Month 3: Technical review meeting
Month 4: Budget negotiation (if required)
Month 5: Agreement drafting
Month 6: Signing ceremony

Communication Protocol:
- Primary: Email with Arabic and English
- Secondary: Phone calls (WhatsApp for local)
- Tertiary: In-person meetings (Khartoum or partner headquarters)
- Documentation: All communication logged in project CRM
 
D. Negotiation Strategy
 
1. Key Negotiation Points
text
text
Budget Allocation:
- Be flexible on percentages but not on total
- Accept phased disbursement
- Accept milestone-based release

Reporting Requirements:
- Quarterly reports (standard for most partners)
- Financial audits (annual)
- Mid-term evaluation (Month 6)

Implementation Approach:
- Accept partner technical oversight
- Include partner branding (co-branding)
- Allow partner staff embedded in team

Sustainability:
- Commit to government ownership post-project
- Agree to knowledge transfer plan
- Accept exit strategy evaluation
 
2. Common Negotiation Challenges
text
text
Challenge 1: Partner wants more control
Solution: Agree on decision-making matrix (clear roles)

Challenge 2: Budget constraints
Solution: Propose phased approach, in-kind contributions

Challenge 3: Different timelines
Solution: Align with partner programming cycles

Challenge 4: Reporting burden
Solution: Use standardized templates, minimize duplication

Challenge 5: Risk aversion
Solution: Strong risk management plan, contingency arrangements
 
E. Agreement Management
 
1. Contract Types
text
text
UNDP: Project Document (PD) + Financial Agreement
World Bank: Grant Agreement (GA) + Project Agreement
AfDB: Grant Agreement + Technical Cooperation Agreement
UAE: Letter of Agreement + Memorandum of Understanding
 
2. Disbursement Schedule
text
text
Example: UNDP $2.5M
- Tranche 1 (20%): $500,000 upon signing (Month 2)
- Tranche 2 (30%): $750,000 upon milestone 1 (Month 3)
- Tranche 3 (30%): $750,000 upon milestone 2 (Month 6)
- Tranche 4 (20%): $500,000 upon completion (Month 12)

Milestones:
1. Project charter approved, team in place
2. Core platform alpha, integration agreements
3. Beta version ready, security audit passed
4. Pilot launched, evaluation completed
 
3. Reporting Requirements
text
text
Monthly:
- Progress report (5 pages)
- Financial report (UNDP format)
- Risk register update

Quarterly:
- Comprehensive quarterly report (15 pages)
- Financial statements (audited)
- Steering Committee minutes
- M&E data

Mid-term (Month 6):
- Mid-term evaluation report (external evaluation)
- Budget revision (if needed)
- Work plan adjustment

Final (Month 12):
- Final report (30 pages)
- Financial audit
- Impact assessment
- Lessons learned
 
F. Risk Management in Funding
 
1. Funding Risks & Mitigation
text
text
Risk 1: Partner withdraws funding
Mitigation: Diversified funding sources, government bridge funding

Risk 2: Delayed disbursement
Mitigation: Phased budgeting, advance payment requests, contingency fund

Risk 3: Currency fluctuation
Mitigation: USD-denominated agreements, quarterly budget reviews

Risk 4: Reporting non-compliance
Mitigation: Dedicated reporting officer, standardized templates, training

Risk 5: Political conditions affecting partnerships
Mitigation: Strong government support, multi-lateral approach
 
2. Contingency Funding Plan
text
text
If 30% of target funding not secured by Month 3:
- Scale down pilot scope (300,000 users instead of 500,000)
- Reduce number of integrated services (3 instead of 5)
- Extend timeline (15 months instead of 12)
- Increase government contribution

If 50% funding gap by Month 6:
- Pause development, focus on planning
- Seek emergency funding from existing partners
- Consider public-private partnership model
 
G. Success Metrics for Funding Strategy
 
1. Funding Targets
text
text
Primary Target: Secure $6.36M (40% of total) by Month 6
Secondary Target: Secure $5M (minimum viable) by Month 6
Stretch Target: Secure $8M (50% of total) by Month 6

Timeline Targets:
- Month 3: $2M secured (UNDP commitment)
- Month 4: $4M secured (World Bank commitment)
- Month 5: $5.5M secured (AfDB + UAE)
- Month 6: $6.36M+ secured (all commitments)
 
2. Partnership Quality Metrics
text
text
1. Speed of response: < 2 weeks for initial feedback
2. Proposal acceptance rate: > 80%
3. Disbursement timeliness: > 90% on schedule
4. Partner satisfaction: > 4/5 rating
5. Relationship strength: Multiple touchpoints, trust
 
H. Implementation of Funding Strategy
 
Week-by-Week Activities
text
text
Month 1:
- Week 1: Identify key contacts at Tier 1 partners
- Week 2: Prepare UNDP proposal (draft)
- Week 3: Prepare World Bank proposal (draft)
- Week 4: Internal review of proposals

Month 2:
- Week 1: Submit UNDP proposal
- Week 2: Submit World Bank proposal
- Week 3: Follow-up meetings with UNDP
- Week 4: Follow-up meetings with World Bank

Month 3:
- Week 1: Prepare AfDB proposal
- Week 2: Submit AfDB proposal
- Week 3: Respond to UNDP/World Bank queries
- Week 4: Technical review meetings

Month 4:
- Week 1: Prepare UAE proposal
- Week 2: Submit UAE proposal
- Week 3: Negotiation with UNDP
- Week 4: Negotiation with World Bank

Month 5:
- Week 1: Prepare Islamic Development Bank proposal
- Week 2: Submit Islamic Development Bank proposal
- Week 3: Agreement drafting (UNDP)
- Week 4: Agreement drafting (World Bank)

Month 6:
- Week 1: Sign UNDP agreement
- Week 2: Sign World Bank agreement
- Week 3: Sign AfDB agreement
- Week 4: Sign UAE agreement
 
Resource Allocation for Funding Strategy
text
text
Dedicated Team:
- Partnership Manager (1 FTE)
- Proposal Writer (0.5 FTE)
- Financial Analyst (0.5 FTE)
- Legal Advisor (0.25 FTE)

Budget for Funding Strategy:
- Proposal development: $50,000
- Travel and meetings: $30,000
- Consultancy (proposal writing): $20,000
- Total: $100,000 (from project budget)
 
I. Post-Agreement Management
 
1. Partner Relationship Management
text
text
Quarterly Review Meetings:
- Progress against milestones
- Budget utilization
- Risk assessment
- Relationship strengthening

Annual Partnership Events:
- Annual review with each partner
- Joint field visits
- Success story sharing
- Planning for next phase
 
2. Transparency and Accountability
text
text
Public Reporting:
- Website: Funding sources and amounts
- Annual report: Published online
- Media: Regular updates on progress
- Social media: Achievement announcements

Audit Trail:
- All funds tracked in dedicated system
- Regular internal audits
- External audit at project end
- Public disclosure of results
 
END OF STEP 2: FUNDING STRATEGY
 
 
STEP 3: ESTABLISH PROJECT MANAGEMENT OFFICE (PMO)
 
PMO ESTABLISHMENT & EXECUTION
 
A. PMO Structure and Design
 
PMO Governance Model
text
text
PMO Type: Supportive PMO (provides standards, templates, training)
Reporting Line: Directly to Project Director
PMO Size: 8-10 FTEs (full-time equivalent)
Location: Khartoum (Project Headquarters)

PMO Structure:
1. PMO Director (1 FTE)
   - Reports to: Project Director
   - Responsibilities: Overall PMO management, reporting, standards

2. Planning & Scheduling (2 FTEs)
   - Master schedule management
   - Resource planning
   - Milestone tracking

3. Budget & Finance (2 FTEs)
   - Budget tracking and reporting
   - Financial compliance
   - Partner financial reporting

4. Quality & Risk (2 FTEs)
   - Quality assurance processes
   - Risk management
   - Issue tracking

5. Communication & Stakeholder (1 FTE)
   - Stakeholder communication
   - Meeting coordination
   - Documentation management

6. Tools & Technology (1 FTE)
   - Project management tools administration
   - Reporting dashboard maintenance
   - System administration support
 
PMO Charter
text
text
Purpose: To ensure effective project execution through standardized processes, tools, and reporting
Vision: To be the center of excellence for project management in Sudan's digital transformation
Values: Transparency, Collaboration, Excellence, Accountability

Key Responsibilities:
1. Establish and maintain project management standards
2. Provide planning and scheduling support
3. Track and report project performance
4. Manage project risks and issues
5. Facilitate communication and stakeholder engagement
6. Ensure quality assurance and control
7. Manage project documentation
8. Support project team with tools and training

Authority:
- Decision-making authority within defined limits
- Escalation authority to Project Director
- Access to all project information and systems
 
B. PMO Setup Activities (Month 1-2)
 
Week 1-2: PMO Director Recruitment
text
text
Recruitment Process:
1. Job Analysis and Description (Week 1)
   - Required skills: PMP/PRINCE2 certification, 10+ years project management
   - Experience: Large-scale IT projects, international development
   - Language: Arabic (fluent), English (professional)
   - Location: Khartoum-based

2. Recruitment (Week 1-2)
   - Source: LinkedIn, professional networks, UNDP/World Bank referrals
   - Advertise: Sudanese newspapers, online job portals
   - Timeline: 2 weeks for shortlisting, 1 week for interviews, 1 week for offer

3. Onboarding (Week 3-4)
   - Introduction to project and team
   - Training on project charter and objectives
   - Setup of PMO systems and tools
   - Initial stakeholder introductions
 
Week 3-4: PMO Team Formation
text
text
Team Recruitment:
- Planning & Scheduling: 2 FTEs (1 senior, 1 junior)
- Budget & Finance: 2 FTEs (1 senior, 1 junior)
- Quality & Risk: 2 FTEs (1 senior, 1 junior)
- Communication: 1 FTE
- Tools & Technology: 1 FTE

Recruitment Timeline:
- Senior roles: 3 weeks (parallel recruitment)
- Junior roles: 2 weeks (local market)
- Total team formation: 4 weeks

Team Composition:
- 70% Sudanese professionals (local market)
- 30% international experts (for specialized roles)
- 50% female representation (target)
- Diverse geographic representation (Khartoum, Port Sudan, other states)
 
Week 5-8: PMO System Setup
text
text
Project Management Tools:
1. Planning & Scheduling: Microsoft Project or similar
   - Master schedule development
   - Resource allocation
   - Critical path analysis

2. Budget Tracking: Excel-based or specialized software
   - Budget vs. actual tracking
   - Financial reporting templates
   - Partner financial reporting

3. Risk Management: Risk register software or Excel
   - Risk identification and assessment
   - Mitigation planning
   - Monitoring and reporting

4. Communication: SharePoint or similar
   - Document management
   - Meeting minutes
   - Stakeholder communication log

5. Reporting: Power BI or similar
   - Dashboard development
   - Automated reporting
   - Data visualization

Setup Activities:
- Tool selection and procurement (Week 5-6)
- System configuration (Week 6-7)
- Team training (Week 7-8)
- Pilot testing (Week 8)
 
C. PMO Processes and Standards
 
1. Planning and Scheduling Process
text
text
Process Steps:
1. Work Breakdown Structure (WBS) Development
   - Break down project into manageable work packages
   - Assign WBS codes (aligned with project numbering)
   - Validate with project team

2. Schedule Development
   - Estimate durations (optimistic, pessimistic, realistic)
   - Identify dependencies
   - Determine critical path
   - Include Sudanese calendar considerations (Ramadan, Eid, etc.)

3. Resource Planning
   - Assign resources to tasks
   - Identify resource constraints
   - Plan for resource leveling

4. Baseline Establishment
   - Get stakeholder approval
   - Set performance measurement baseline
   - Establish change control process

Tools and Templates:
- WBS Template (Excel)
- Schedule Template (MS Project)
- Resource Allocation Matrix
- Milestone Tracker
 
2. Budget Management Process
text
text
Process Steps:
1. Budget Planning
   - Detailed budget breakdown (by work package)
   - Contingency allocation (15%)
   - Phased expenditure planning

2. Budget Tracking
   - Monthly actual vs. planned comparison
   - Variance analysis
   - Forecast to complete

3. Financial Reporting
   - Monthly reports to Steering Committee
   - Quarterly reports to partners
   - Annual audit preparation

4. Change Control
   - Budget change request process
   - Approval thresholds (PMO Director up to $50K, Project Director up to $200K, Steering Committee above $200K)
   - Impact assessment

Tools and Templates:
- Budget Template (Excel with SDG and USD)
- Financial Report Template
- Change Request Form
- Forecasting Model
 
3. Risk Management Process
text
text
Process Steps:
1. Risk Identification
   - Brainstorming sessions (monthly)
   - Risk workshops (quarterly)
   - Stakeholder input

2. Risk Assessment
   - Probability and impact scoring (1-5 scale)
   - Risk score calculation (P×I)
   - Risk categorization

3. Risk Mitigation
   - Develop mitigation strategies
   - Assign risk owners
   - Create contingency plans

4. Risk Monitoring
   - Weekly risk review (Friday, 3 PM)
   - Monthly risk report to Steering Committee
   - Risk register updates

Tools and Templates:
- Risk Register Template
- Risk Assessment Matrix
- Mitigation Plan Template
- Contingency Plan Template
 
4. Quality Management Process
text
text
Process Steps:
1. Quality Planning
   - Define quality standards (ISO 27001, Sudanese standards)
   - Set quality metrics
   - Develop quality checklist

2. Quality Assurance
   - Process audits (monthly)
   - Peer reviews (weekly)
   - Standards compliance checks

3. Quality Control
   - Deliverable inspection (before submission)
   - Testing validation
   - Defect tracking

4. Continuous Improvement
   - Lessons learned (monthly)
   - Process improvement recommendations
   - Best practice sharing

Tools and Templates:
- Quality Checklist Template
- Audit Report Template
- Defect Log
- Lessons Learned Register
 
5. Communication and Stakeholder Management
text
text
Process Steps:
1. Stakeholder Analysis
   - Identify all stakeholders
   - Map influence and interest
   - Develop engagement strategy

2. Communication Planning
   - Define communication methods
   - Set frequency and format
   - Assign communication responsibilities

3. Meeting Management
   - Standard meeting agenda and minutes
   - Action item tracking
   - Decision log

4. Reporting
   - Standard report templates
   - Automated reporting where possible
   - Tailored reports for different stakeholders

Tools and Templates:
- Stakeholder Register
- Communication Plan Template
- Meeting Agenda Template
- Meeting Minutes Template
- Report Templates (monthly, quarterly)
 
D. PMO Execution Support
 
1. Project Planning Support
text
text
Activities:
- Facilitate planning workshops
- Develop integrated project schedule
- Maintain master schedule
- Track dependencies and critical path
- Update schedule based on actual progress

Support Provided:
- MS Project setup and training
- Schedule review and validation
- Resource allocation support
- Schedule compression techniques
 
2. Budget Tracking and Reporting
text
text
Activities:
- Monthly budget vs. actual analysis
- Variance reporting
- Forecast to complete calculations
- Partner financial reporting
- Audit preparation

Support Provided:
- Budget tracking templates
- Financial reporting templates
- Variance analysis guidance
- Partner-specific reporting formats
 
3. Risk Management Support
text
text
Activities:
- Facilitate risk identification workshops
- Maintain risk register
- Track mitigation effectiveness
- Prepare risk reports
- Conduct risk reviews

Support Provided:
- Risk assessment tools
- Mitigation planning templates
- Risk monitoring dashboards
- Escalation procedures
 
4. Quality Assurance Support
text
text
Activities:
- Process audits (monthly)
- Deliverable quality checks
- Testing coordination
- Defect management
- Lessons learned collection

Support Provided:
- Quality checklists
- Audit templates
- Defect tracking system
- Continuous improvement processes
 
5. Communication and Reporting Support
text
text
Activities:
- Prepare Steering Committee reports
- Coordinate stakeholder meetings
- Maintain communication log
- Distribute project updates
- Manage project documentation

Support Provided:
- Report templates
- Meeting management tools
- Document management system
- Communication protocols
 
E. PMO Tools and Technology
 
1. Project Management Software
text
text
Recommended: Microsoft Project Online or similar
Features:
- Master schedule management
- Resource management
- Collaboration features
- Reporting capabilities
- Integration with Office 365

Cost: $15-20 per user/month
Implementation: 2 weeks setup, 1 week training
 
2. Financial Management System
text
text
Recommended: Excel with Power Query or specialized software
Features:
- Budget tracking
- Actual vs. planned reporting
- Partner financial reporting
- Audit trail

Cost: $5,000-10,000 (software + setup)
Implementation: 3 weeks setup, 1 week training
 
3. Risk Management Tool
text
text
Recommended: SharePoint or specialized risk software
Features:
- Risk register
- Risk assessment matrix
- Mitigation tracking
- Reporting

Cost: $2,000-5,000
Implementation: 2 weeks setup, 1 week training
 
4. Communication and Collaboration
text
text
Recommended: Microsoft 365 (SharePoint, Teams, Outlook)
Features:
- Document management
- Meeting coordination
- Team collaboration
- Email integration

Cost: Included in Microsoft 365 subscription
Implementation: 1 week setup, 1 week training
 
5. Reporting and Dashboard
text
text
Recommended: Power BI or similar
Features:
- Automated reporting
- Data visualization
- Real-time dashboards
- Stakeholder-specific views

Cost: $10,000-20,000 (setup + licensing)
Implementation: 4 weeks setup, 1 week training
 
F. PMO Performance Metrics
 
1. PMO Effectiveness Metrics
text
text
1. Schedule Performance:
   - Schedule Variance (SV) = EV - PV
   - Schedule Performance Index (SPI) = EV / PV
   - Target: SPI > 0.95

2. Budget Performance:
   - Cost Variance (CV) = EV - AC
   - Cost Performance Index (CPI) = EV / AC
   - Target: CPI > 0.95

3. Quality Performance:
   - Defect Density (defects per 1,000 lines of code)
   - Rework Effort (percentage of effort)
   - Target: Defect density < 5 per KLOC, rework < 15%

4. Stakeholder Satisfaction:
   - Monthly satisfaction surveys (1-5 scale)
   - Target: > 4.0 average

5. PMO Efficiency:
   - Time spent on administrative tasks vs. value-added activities
   - Report generation time
   - Target: < 30% administrative time
 
2. PMO Deliverables
text
text
Monthly Deliverables:
- Project Status Report (5 pages)
- Budget Variance Report
- Risk Register Update
- Resource Utilization Report
- Quality Metrics Report
- Stakeholder Communication Log

Quarterly Deliverables:
- Comprehensive Quarterly Report (15 pages)
- Financial Statements (audited)
- Mid-term Evaluation Report (if applicable)
- Lessons Learned Report

Annual Deliverables:
- Annual Project Report (30 pages)
- Financial Audit Report
- Impact Assessment Report
- Phase 2 Planning Document
 
G. PMO Budget and Resources
 
PMO Budget (12 months)
text
text
Personnel: $450,000 (8-10 FTEs)
- PMO Director: $90,000
- Planning & Scheduling (2 FTEs): $120,000
- Budget & Finance (2 FTEs): $120,000
- Quality & Risk (2 FTEs): $100,000
- Communication (1 FTE): $60,000
- Tools & Technology (1 FTE): $60,000

Tools and Software: $50,000
- PM software: $20,000
- Financial system: $10,000
- Risk management: $5,000
- Reporting dashboard: $15,000

Training and Development: $20,000
- PM certifications (PMP, PRINCE2): $10,000
- Software training: $5,000
- Process training: $5,000

Office and Operations: $30,000
- Office space (shared): $15,000
- Utilities and supplies: $5,000
- Communication and travel: $10,000

Contingency (10%): $55,000

Total PMO Budget: $605,000 (4% of total project budget)
 
PMO Resource Requirements
text
text
Human Resources:
- PMO Director: Full-time
- Planning & Scheduling: 2 FTEs (1 senior, 1 junior)
- Budget & Finance: 2 FTEs (1 senior, 1 junior)
- Quality & Risk: 2 FTEs (1 senior, 1 junior)
- Communication: 1 FTE
- Tools & Technology: 1 FTE

Total: 9 FTEs

Physical Resources:
- Office space: 50-60 sqm (shared with project team)
- Workstations: 9 desks, computers, peripherals
- Meeting room: Access to project meeting room
- Software licenses: As specified above
 
H. PMO Integration with Project Execution
 
1. Interface with Project Teams
text
text
Daily:
- Team leads provide daily status updates
- PMO tracks progress against schedule
- Issues logged and tracked

Weekly:
- Team leads provide weekly progress reports
- PMO compiles project status report
- Risk review meeting (Friday, 3 PM)

Monthly:
- Team leads participate in PMO review meeting
- PMO prepares Steering Committee report
- Lessons learned session
 
2. Interface with Stakeholders
text
text
Steering Committee:
- PMO prepares monthly reports
- PMO Director attends Steering Committee meetings
- PMO tracks action items and decisions

Agency Partners:
- PMO coordinates with agency PMO counterparts
- PMO tracks integration progress
- PMO facilitates issue resolution

International Partners:
- PMO prepares partner-specific reports
- PMO coordinates with partner PMOs
- PMO tracks partnership deliverables
 
3. Interface with Project Director
text
text
Daily:
- Brief check-ins (15 minutes)
- Issue escalation as needed

Weekly:
- Weekly PMO report
- Resource allocation review
- Risk review

Monthly:
- Comprehensive review of all PMO functions
- Budget review
- Performance assessment
 
I. PMO Success Metrics
 
1. PMO Performance Indicators
text
text
1. Schedule Adherence:
   - Target: 90% of milestones on time
   - Measurement: Monthly milestone tracking

2. Budget Adherence:
   - Target: Within 10% of budget
   - Measurement: Monthly budget variance

3. Quality Metrics:
   - Target: Zero critical defects in production
   - Measurement: Defect tracking system

4. Stakeholder Satisfaction:
   - Target: > 4.0/5.0 average satisfaction
   - Measurement: Monthly surveys

5. PMO Efficiency:
   - Target: < 30% administrative overhead
   - Measurement: Time tracking
 
2. PMO Maturity Assessment
text
text
Quarterly Assessment:
- Level 1: Initial (ad-hoc processes)
- Level 2: Repeatable (standard processes)
- Level 3: Defined (documented processes)
- Level 4: Managed (measured and controlled)
- Level 5: Optimized (continuous improvement)

Target: Reach Level 3 by Month 6, Level 4 by Month 12
 
END OF STEP 3: PMO ESTABLISHMENT
 
 
STEP 4: LAUNCH COMMUNICATION AND CHANGE MANAGEMENT ACTIVITIES
 
COMMUNICATION AND CHANGE MANAGEMENT STRATEGY
 
A. Objectives of Communication and Change Management
 
Primary Objectives
text
text
1. Awareness: Ensure all stakeholders understand the project and its benefits
2. Understanding: Build comprehension of how the system works and their role
3. Acceptance: Gain buy-in and support from all stakeholders
4. Adoption: Encourage and enable use of the new system
5. Advocacy: Create champions who promote the system
 
Secondary Objectives
Build trust and transparency
Manage expectations
Address resistance proactively
Celebrate successes
Create sustainable change
text
text

### **B. Stakeholder Analysis and Segmentation**

#### **Stakeholder Groups and Segments**
1.
Government Stakeholders (Internal)
Senior officials (Ministers, Directors)
Middle management
Front-line staff
IT staff
2.
International Partners
UNDP staff
World Bank staff
Other donor agencies
3.
Private Sector
Telecom providers
Banks
Business associations
SMEs
4.
Civil Society
NGOs
Community-based organizations
Religious institutions
Tribal leaders
5.
General Public
Urban residents
Rural residents
Youth (18-30)
Women
Persons with disabilities
Illiterate population
text
text

#### **Stakeholder Needs Assessment**
Government Stakeholders:
Need: Clear understanding of benefits, roles, responsibilities
Concerns: Additional workload, change to routines, job security
Communication: Formal briefings, detailed documentation, training
 
International Partners:
Need: Progress updates, financial reporting, impact data
Concerns: Transparency, accountability, results
Communication: Regular reports, meetings, site visits
 
Private Sector:
Need: Business benefits, partnership opportunities, ROI
Concerns: Cost, complexity, data privacy
Communication: Business case, partnership agreements, success stories
 
Civil Society:
Need: Inclusion, transparency, accountability
Concerns: Exclusion, misuse of data, corruption
Communication: Community meetings, transparency portals, grievance mechanisms
 
General Public:
Need: Simple explanations, clear benefits, easy access
Concerns: Privacy, complexity, accessibility
Communication: Radio, TV, SMS, community meetings, simple guides
text
text

### **C. Communication Strategy**

#### **1. Communication Principles**
Arabic First: All communications in Arabic (primary language)
Multi-Channel: Use multiple channels to reach diverse audiences
Two-Way: Encourage feedback and dialogue, not just broadcast
Consistent: Consistent messaging across all channels
Timely: Information provided when needed
Transparent: Open about progress, challenges, and decisions
Culturally Appropriate: Respect Sudanese cultural norms and values
Accessible: Ensure information reaches all, including marginalized groups
text
text

#### **2. Communication Channels and Methods**
Formal Channels:
1.
Official Documents (Arabic/English)
Project Charter (Version 2.0)
Monthly progress reports
Quarterly impact reports
Annual reports
2.
Meetings and Workshops
Steering Committee meetings (monthly)
Agency working groups (bi-weekly)
Community consultations (monthly)
Training sessions (ongoing)
3.
Digital Channels
Project website (
www.sgdus.gov.sd
)
Social media (Facebook, Twitter, Instagram)
Email newsletters
WhatsApp groups (for specific stakeholders)
4.
Traditional Media
Radio programs (Sudan Radio, local stations)
TV programs (Sudan TV, private channels)
Newspapers (dailies and weeklies)
Posters and billboards
5.
Community Engagement
Community meetings (mosques, churches, community centers)
Mobile registration vans (for rural areas)
Community champions program
School and university outreach
6.
Direct Communication
SMS/USSD for basic phone users
Hotline for questions and complaints
Help desks at registration points
Field officers for rural areas
text
text

#### **3. Communication Timeline and Activities**
Month 1: Project Launch
Press conference (national TV, radio, newspapers)
Internal announcements to all ministries
Social media campaign launch
Community meetings in pilot areas
 
Month 2-3: Awareness Building
Radio programs (weekly)
TV commercials (prime time)
Social media content (daily)
Community meetings (twice monthly)
Training for government staff
 
Month 4-6: Education and Training
Detailed training for agencies
User guides and manuals (Arabic)
Video tutorials (online and TV)
Community demonstrations
FAQ development and distribution
 
Month 7-9: Support and Adoption
User support channels (helpline, WhatsApp)
Success stories collection and sharing
Community feedback collection
Problem-solving workshops
Regular progress updates
 
Month 10-12: Celebration and Sustainability
Pilot success celebration
Media coverage of successes
Public recognition of champions
Lessons learned documentation
Phase 2 communication planning
text
text

#### **4. Key Messages by Stakeholder Group**
For Government Officials:
"This system will make your work more efficient and transparent"
"You will save time and resources while serving citizens better"
"This is Sudan's path to digital transformation and improved governance"
 
For International Partners:
"Your investment is creating measurable impact for Sudan's development"
"This project is building Sudan's capacity for sustainable digital transformation"
"We are achieving SDG targets through innovative digital solutions"
 
For Private Sector:
"This system will reduce your business registration time from 15 days to 3 days"
"Digital services will expand your market reach and reduce costs"
"Partnership opportunities exist in infrastructure, services, and innovation"
 
For Civil Society:
"This system will increase transparency and reduce corruption"
"Your community will have better access to government services"
"We need your input to ensure the system works for everyone"
 
For General Public:
"Register once, access all government services"
"Save time and money with digital services"
"Your identity is secure and protected"
"Services available on your phone, even without internet"
text
text

### **D. Change Management Strategy**

#### **1. Change Management Framework (ADKAR Model)**
Awareness (of the need for change):
Activities: Communication campaign, stakeholder briefings
Success: >80% of stakeholders aware of project by Month 3
Measurement: Survey of awareness levels
 
Desire (to participate and support the change):
Activities: Benefits communication, involvement in design
Success: >70% of stakeholders express support by Month 4
Measurement: Survey of support levels
 
Knowledge (of how to change):
Activities: Training programs, user guides, demonstrations
Success: >90% of users trained by Month 6
Measurement: Training completion rates, knowledge tests
 
Ability (to implement new skills and behaviors):
Activities: Practice sessions, coaching, support systems
Success: >80% of users able to use system independently by Month 8
Measurement: Usage metrics, support call volumes
 
Reinforcement (to sustain the change):
Activities: Recognition, rewards, continuous support
Success: >75% of users continue using system after 6 months
Measurement: Retention rates, ongoing usage metrics
text
text

#### **2. Change Management Activities by Phase**
Phase 1: Preparation (Months 1-3)
Change impact assessment
Stakeholder analysis
Change management team formation
Communication plan development
Training needs assessment
 
Phase 2: Implementation (Months 4-9)
Training delivery
Change champion network establishment
Support system setup
Feedback collection and response
Resistance management
 
Phase 3: Reinforcement (Months 10-12)
Success celebration
Recognition programs
Continuous improvement
Knowledge transfer
Sustainability planning
text
text

#### **3. Change Champion Network**
Selection:
100 Change Champions (diverse representation)
Include: Government staff, community leaders, youth, women
Geographic representation (Khartoum, Port Sudan, rural areas)
 
Training:
5-day intensive training
Project overview and benefits
Change management techniques
Communication skills
Problem-solving
 
Activities:
Community engagement
Training support
Feedback collection
Success story collection
Advocacy and promotion
 
Incentives:
Recognition certificates
Public acknowledgment
Career development opportunities
Small stipends (if appropriate)
text
text

#### **4. Resistance Management**
Identify Resistance Sources:
Fear of job loss
Comfort with current systems
Lack of skills
Perceived complexity
Privacy concerns
Cultural barriers
 
Resistance Management Strategies:
1.Communication: Address concerns transparently
2.Involvement: Include resisters in solution design
3.Training: Provide adequate training and support
4.Incentives: Recognize early adopters
5.Gradual Implementation: Phased approach to reduce shock
6.Leadership Support: Visible support from senior officials
 
Escalation Process:
Level 1: Team lead addresses individual resistance
Level 2: Change manager addresses group resistance
Level 3: Project Director addresses systemic resistance
Level 4: Steering Committee addresses political resistance
text
text

### **E. Communication and Change Management Budget**

#### **Budget Breakdown (12 months)**
Total Budget: $800,000 (5% of project budget)
 
1.
Communication Activities: $300,000
Media campaigns (radio, TV, print): $150,000
Digital marketing and social media: $50,000
Community engagement (meetings, events): $60,000
Communication materials (production): $40,000
2.
Change Management Activities: $350,000
Training programs (materials, trainers, venues): $200,000
Change champion network: $50,000
Support systems (helpline, help desks): $50,000
Recognition and incentives: $30,000
Evaluation and feedback: $20,000
3.
Tools and Technology: $100,000
Communication platforms: $30,000
Survey tools: $20,000
Video production: $30,000
Translation services: $20,000
4.
Contingency (10%): $50,000
 
Funding Source: Project budget (Marketing & Outreach category)
text
text

#### **Resource Requirements**
Human Resources:
Communication Manager (1 FTE)
Change Management Lead (1 FTE)
Content Creators (2 FTEs)
Community Engagement Officers (4 FTEs)
Trainers (3 FTEs, part-time)
Support Staff (2 FTEs)
 
Total: 8-10 FTEs
 
Physical Resources:
Office space (shared with project)
Training venues (rented as needed)
Media production equipment
Community engagement materials
text
text

### **F. Success Metrics for Communication and Change Management**

#### **1. Awareness Metrics**
Awareness Rate: % of target population aware of project Target: 80% by Month 3, 95% by Month 6 Measurement: Surveys, media reach data
Message Recall: % who can recall key messages Target: 70% by Month 6 Measurement: Survey questions
Media Reach: Number of impressions/views/listeners Target: 5 million impressions by Month 12 Measurement: Media analytics
text
text

#### **2. Understanding Metrics**
Comprehension Rate: % who understand how to use system Target: 70% by Month 6 Measurement: Knowledge tests, observation
Training Completion: % of target users trained Target: 90% by Month 6 Measurement: Training records
Support Requests: Number of support calls/questions Target: Decreasing trend after Month 8 Measurement: Help desk records
text
text

#### **3. Acceptance and Adoption Metrics**
System Usage: % of registered users actively using system Target: 70% by Month 12 Measurement: System analytics
User Satisfaction: Average satisfaction score (1-5) Target: >4.0 by Month 12 Measurement: User surveys
Retention Rate: % of users continuing after 6 months Target: >75% Measurement: Usage analytics
Champion Effectiveness: Number of new users per champion Target: 50 new users per champion Measurement: Tracking system
text
text

#### **4. Advocacy Metrics**
Success Stories: Number of documented success stories Target: 100 by Month 12 Measurement: Collection system
Media Coverage: Positive media coverage Target: 50+ articles/segments Measurement: Media monitoring
Peer Referrals: Number of users referred by others Target: 20% of new users from referrals Measurement: Referral tracking
text
text

### **G. Implementation Timeline**

#### **Month-by-Month Activities**
Month 1: Planning and Setup
Week 1-2: Communication and change management plan development
Week 3-4: Team formation and training
Week 4: Launch communication campaign (press conference)
 
Month 2-3: Awareness Building
Ongoing: Radio programs, TV commercials, social media
Weekly: Community meetings in pilot areas
Bi-weekly: Internal briefings to government staff
Monthly: Progress reports to stakeholders
 
Month 4-6: Education and Training
Weekly: Training sessions for government staff
Bi-weekly: Community demonstrations
Monthly: User feedback collection
Ongoing: Support channel establishment
 
Month 7-9: Support and Adoption
Daily: Help desk operations
Weekly: Success story collection
Monthly: User satisfaction surveys
Ongoing: Problem-solving workshops
 
Month 10-12: Reinforcement and Sustainability
Monthly: Success celebration events
Ongoing: Recognition programs
Quarterly: Impact assessment
Final: Lessons learned documentation
text
text

#### **Critical Success Factors**
1.Leadership Commitment: Visible support from PMO and ministers
2.Cultural Sensitivity: Respect for Sudanese norms and values
3.Multi-Channel Approach: Reach diverse audiences through various channels
4.Two-Way Communication: Listen and respond to feedback
5.Adequate Resources: Sufficient budget and staff for activities
6.Continuous Improvement: Regular assessment and adjustment
7.Stakeholder Involvement: Include stakeholders in design and implementation
text
text

### **H. Sustainability and Exit Strategy**

#### **Sustainable Communication Practices**
1.
Institutionalize Communication:
Integrate into government communication protocols
Train government communication staff
Establish communication standards
2.
Community Ownership:
Empower community champions
Establish community-based support systems
Create local success stories
3.
Digital Channels:
Develop and maintain project website
Establish social media presence
Create automated reporting systems
4.
Capacity Building:
Train government staff in communication
Develop local communication materials
Establish communication monitoring system
text
text

#### **Change Management Sustainability**
1.
Process Integration:
Integrate change management into government processes
Establish change management standards
Train change managers in government
2.
Cultural Integration:
Embed change mindset in organizational culture
Celebrate change successes
Recognize change champions
3.
Continuous Improvement:
Regular feedback collection
Process refinement based on lessons learned
Adaptation to changing context
text
text

**END OF STEP 4: COMMUNICATION AND CHANGE MANAGEMENT**

---

## **INTEGRATED IMPLEMENTATION PLAN**

### **Overall Timeline Summary**
Month 1-2: Foundation ├── Step 1: Begin Implementation (Team setup, legal review, infrastructure) ├── Step 2: Funding Strategy (Proposal development, submission) ├── Step 3: PMO Establishment (PMO director recruitment, team formation) ├── Step 4: Communication Launch (Press conference, awareness campaign)
 
Month 3-6: Development ├── Step 1: Core development sprints 1-4 ├── Step 2: Funding negotiations and agreements ├── Step 3: PMO processes establishment ├── Step 4: Education and training activities
 
Month 7-9: Integration and Testing ├── Step 1: Agency integration and testing ├── Step 2: Funding disbursement management ├── Step 3: PMO execution support ├── Step 4: Support and adoption activities
 
Month 10-12: Pilot Launch and Evaluation ├── Step 1: Pilot launch and evaluation ├── Step 2: Funding reporting and compliance ├── Step 3: PMO performance assessment ├── Step 4: Reinforcement and sustainability
text
text

### **Critical Dependencies**
1.Legal Review must complete before full implementation begins
2.Funding must be secured by Month 3 for full team implementation
3.PMO must be established by Month 2 to support execution
4.Communication must begin in Month 1 to build awareness
text
text

### **Resource Requirements Summary**
Human Resources:
Project Team: 35 FTEs (core team)
PMO: 9 FTEs
Communication/Change: 8-10 FTEs
Total: 52-54 FTEs
 
Budget:
Phase 1 Total: $15.9M
Implementation Activities: $8.5M (Month 1-12)
PMO: $605,000
Communication/Change: $800,000
Funding Strategy: $100,000
 
Physical Resources:
Office space in Khartoum (project HQ)
Training venues (rented as needed)
Development infrastructure (cloud + local)
Community engagement materials
text
text

### **Success Metrics for Integrated Implementation**
1.Schedule Performance: 90% of milestones on time
2.Budget Performance: Within 10% of budget
3.Quality: Zero critical defects in production
4.User Adoption: 500,000 registered users by Month 12
5.Stakeholder Satisfaction: >4.0/5.0 average
6.Funding: 100% of target secured by Month 6
7.Communication: 80% awareness rate by Month 3
8.Change Management: 70% adoption rate by Month 12
text
text

### **Risk Management for Implementation**
High Risks and Mitigations:
1.Political Instability: Multi-party support, phased approach
2.Funding Delays: Diversified sources, government bridge funding
3.Technical Challenges: International experts, agile development
4.Adoption Resistance: Change management, incentives
5.Security Threats: Security-by-design, regular audits
text
text

**END OF INTEGRATED IMPLEMENTATION PLAN**

---

**Next Steps:**
1. **Begin Month 1 activities** as outlined in Step 1
2. **Initiate funding proposals** for UNDP, World Bank, and other partners
3. **Recruit PMO Director and team** as outlined in Step 3
4. **Launch communication campaign** with press conference in Week 1
5. **Establish weekly progress tracking** through PMO

**Would you like me to elaborate on any specific aspect of these four steps or provide additional implementation tools and templates?**
Now help me to go deep to code level, and help me to build the system that contain and embrace all the above mentioned strategies.

SYSTEM ARCHITECTURE & CODE IMPLEMENTATION
 
I'll help you build a comprehensive system that implements all the strategies we've discussed. We'll create a production-ready, scalable architecture with code examples for key components.
 
SYSTEM OVERVIEW
 
Technology Stack
text
text
Backend: Node.js/Express (microservices) + Python (for data processing)
Frontend: React (web) + React Native (mobile)
Database: PostgreSQL (primary) + MongoDB (audit/logs)
Infrastructure: Docker + Kubernetes (for scalability)
Security: OAuth 2.0, JWT, encryption, zero-trust
Monitoring: Prometheus + Grafana + ELK Stack
Communication: Redis (messaging) + WebSockets
 
1. PROJECT STRUCTURE
 
text
text
sgdus-system/
├── backend/
│   ├── api-gateway/
│   ├── identity-service/
│   ├── oid-service/
│   ├── agency-integration/
│ └── admin-dashboard/
├── infrastructure/
│   ├── docker/
│   ├── kubernetes/
│   ├── terraform/
│   └── monitoring/
├── scripts/
│   ├── setup/
│   ├── deployment/
│   └── backup/
└── docs/
 
2. CORE SERVICES IMPLEMENTATION
 
2.1 API Gateway (Kong-based)
 
File: backend/api-gateway/kong.yml
yaml
yaml
_format_version: "1.1"
services:
  - name: identity-service
    url: http://identity-service:3001
    routes:
      - name: identity-routes
        paths: ["/api/v1/identity"]
        methods: ["GET", "POST", "PUT", "DELETE"]
        plugins:
          - name: rate-limiting
            config:
              minute: 60
              hour: 1000
          - name: jwt
            config:
              secret_is_base64: false
              run_on_preflight: false
          - name: cors
            config:
              origins: ["*"]
              methods.0.0.0/8", "192.168.0.0/16"]
 
2.2 OID Service (Core Identity System)
 
File: backend/oid-service/src/app.js
javascript
javascript
const express = require('express');
const { Pool } = require('pg');
const Redis = require('ioredis');
const: ["GET", "POST", "PUT", "DELETE", "OPTIONS"]
              headers: ["Accept", "Content-Type", "Authorization"]

  - name: oid-service
    url: http://oid-service:3002
    routes:
      - name: oid-routes
        paths: ["/api/v1/oid"]
        methods: ["GET", "POST"]
        plugins:
          - name: rate-limiting
            config:
              minute: 120
              hour: 2000

  - name: audit-service
    url: http://audit-service:3006
    routes:
      - name: audit-routes
        paths: ["/api/v1/audit"]
        methods: ["POST"]
        plugins:
          - name: rate-limiting
            config:
              minute: 1000
              hour: 10000

plugins:
  - name: prometheus
  - name: request-transformer
    config:
      add:
        headers:
          - "X-Request-ID:${uuid()}"
          - "X-Client-IP:${client_ip}"
  - name: bot-detection
  - name: ip-restriction
    config:
      deny: ["10 crypto = require('crypto');
const { v4: uuidv4 } = require('uuid');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const { body, validationResult } = require('express-validator');
const winston = require('winston');

const app = express();
app.use(express.json());
app.use(helmet());

// Logger configuration
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});

// Rate limiting for OID generation
const oidLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many OID requests, please try again later.'
});

// Database connection (Sudanese context - hybrid cloud)
const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: process.env.DB_PORT,
  ssl: process.env.DB_SSL === 'true' ? { rejectUnauthorized: false } : false
});

// Redis for caching (Sudan-specific: consider regional Redis)
const redis = new Redis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD
});

// OID Structure for Sudan: 1.3.6.1.4.1.61026.[type].[state].[counter]
// Type: 1=places, 2=citizens, 3=businesses, 4=government, 5=services, 6=documents
// State: 01=Khartoum, 02=Port Sudan, etc.

class OIDService {
  constructor() {
    this.oidPrefix = '1.3.6.1.4.1.61026';
    this.cacheTTL = 3600; // 1 hour
  }

  // Generate unique OID for Sudanese entities
  async generateOID(type, stateCode, entityId, metadata = {}) {
    const cacheKey = `oid:${type}:${stateCode}:${entityId}`;

    // Check cache first
    const cachedOID = await redis.get(cacheKey);
    if (cachedOID) {
      return cachedOID;
    }

    // Get counter from database (per type per state)
    const counterQuery = `
      INSERT INTO oid_counters (type, state_code, counter)
      VALUES ($1, $2, 1)
      ON CONFLICT (type, state_code)
      DO UPDATE SET counter = oid_counters.counter + 1
      RETURNING counter
    `;

    const counterResult = await pool.query(counterQuery, [type, stateCode]);
    const counter = counterResult.rows[0].counter;

    // Generate OID
    const oid = `${this.oidPrefix}.${type}.${stateCode}.${counter.toString().padStart(8, '0')}`;

    // Store in registry
    const registryQuery = `
      INSERT INTO oid_registry (
        oid, type, state_code, entity_id, metadata,
        created_at, updated_at, status
      ) VALUES ($1, $2, $3, $4, $5, NOW(), NOW(), 'active')
    `;

    await pool.query(registryQuery, [oid, type, stateCode, entityId, JSON.stringify(metadata)]);

    // Cache the OID
    await redis.setex(cacheKey, this.cacheTTL, oid);

    // Log for audit
    logger.info('OID generated', {
      oid,
      type,
      stateCode,
      entityId,
      timestamp: new Date().toISOString()
    });

    return oid;
  }

  // Resolve OID to entity data
  async resolveOID(oid) {
    const cacheKey = `oid:resolve:${oid}`;

    // Check cache
    const cachedData = await redis.get(cacheKey);
    if (cachedData) {
      return JSON.parse(cachedData);
    }

    // Query database
    const query = `
      SELECT oid, type, state_code, entity_id, metadata, created_at, status
      FROM oid_registry
      WHERE oid = $1 AND status = 'active'
    `;

    const result = await pool.query(query, [oid]);

    if (result.rows.length === 0) {
      throw new Error(`OID ${oid} not found or inactive`);
    }

    const entity = result.rows[0];

    // Cache the result
    await redis.setex(cacheKey, this.cacheTTL, JSON.stringify(entity));

    return entity;
  }

  // Validate OID format for Sudanese standard
  validateOID(oid) {
    const pattern = /^1\.3\.6\.1\.4\.1\.61026\.(1|2|3|4|5|6)\.\d{2}\.\d{8}$/;
    return pattern.test(oid);
  }

  // Search OIDs by criteria (for administration)
  async searchOIDs(criteria) {
    const { type, stateCode, status, limit = 50, offset = 0 } = criteria;

    let query = `
      SELECT oid, type, state_code, entity_id, created_at, status
      FROM oid_registry
      WHERE 1=1
    `;

    const params = [];
    let paramCount = 1;

    if (type) {
      query += ` AND type = $${paramCount}`;
      params.push(type);
      paramCount++;
    }

    if (stateCode) {
      query += ` AND state_code = $${paramCount}`;
      params.push(stateCode);
      paramCount++;
    }

    if (status) {
      query += ` AND status = $${paramCount}`;
      params.push(status);
      paramCount++;
    }

    query += ` ORDER BY created_at DESC LIMIT $${paramCount} OFFSET $${paramCount + 1}`;
    params.push(limit, offset);

    const result = await pool.query(query, params);
    return result.rows;
  }
}

const oidService = new OIDService();

// API Routes
app.post('/api/v1/oid/generate', oidLimiter, [
  body('type').isIn(['1', '2', '3', '4', '5', '6']).withMessage('Invalid OID type'),
  body('stateCode').isLength({ min: 2, max: 2 }).withMessage('State code must be 2 digits'),
  body('entityId').notEmpty().withMessage('Entity ID is required')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const { type, stateCode, entityId, metadata = {} } = req.body;

    // Validate state code (Sudanese states: 01-18)
    if (parseInt(stateCode) < 1 || parseInt(stateCode) > 18) {
      return res.status(400).json({ error: 'Invalid Sudanese state code (1-18)' });
    }

    const oid = await oidService.generateOID(type, stateCode, entityId, metadata);

    res.status(201).json({
      success: true,
      oid: oid,
      message: 'OID generated successfully',
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('OID generation error', { error: error.message, stack: error.stack });
    res.status(500).json({ error: 'Internal server error', message: error.message });
  }
});

app.get('/api/v1/oid/:oid', async (req, res) => {
  try {
    const { oid } = req.params;

    if (!oidService.validateOID(oid)) {
      return res.status(400).json({ error: 'Invalid OID format' });
    }

    const entity = await oidService.resolveOID(oid);

    res.json({
      success: true,
      data: entity,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    if (error.message.includes('not found')) {
      return res.status(404).json({ error: error.message });
    }
    logger.error('OID resolution error', { error: error.message, stack: error.stack });
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.get('/api/v1/oid/search', async (req, res) => {
  try {
    const { type, stateCode, status, limit, offset } = req.query;

    const criteria = {
      type: type ? parseInt(type) : undefined,
      stateCode: stateCode ? stateCode.toString().padStart(2, '0') : undefined,
      status: status,
      limit: limit ? parseInt(limit) : 50,
      offset: offset ? parseInt(offset) : 0
    };

    const results = await oidService.searchOIDs(criteria);

    res.json({
      success: true,
      count: results.length,
      data: results,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('OID search error', { error: error.message, stack: error.stack });
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    service: 'OID Service',
    timestamp: new Date().toISOString(),
    version: '1.0.0'
  });
});

// Error handling middleware
app.use((err, req, res, next) => {
  logger.error('Unhandled error', { error: err.message, stack: err.stack, url: req.url });
  res.status(500).json({ error: 'Internal server error' });
});

const PORT = process.env.PORT || 3002;
app.listen(PORT, () => {
  logger.info(`OID Service running on port {PORT}`);
  console.log(`OID Service running on port ${PORT}`);
});

module.exports = app;
 
2.3 Identity Service (Citizen & Business Registration)
 
File: backend/identity-service/src/app.js
javascript
javascript
const express = require('express');
const { Pool } = require('pg');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const { body, validationResult } = require('express-validator');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const winston = require('winston');
const axios = require('axios');

const app = express();
app.use(express.json());
app.use(helmet());

// Rate limiting for registration
const registrationLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 10, // 10 registrations per minute per IP
  message: 'Too many registration attempts, please try again later.'
});

// Database connection
const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: process.env.DB_PORT,
  ssl: process.env.DB_SSL === 'true' ? { rejectUnauthorized: false } : false
});

// Logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'identity-errors.log', level: 'error' }),
    new winston.transports.File({ filename: 'identity-combined.log' })
  ]
});

// JWT configuration
const JWT_SECRET = process.env.JWT_SECRET;
const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';

// Sudanese National ID validation (simplified)
function validateSudaneseNationalId(nationalId) {
  // Sudanese National ID format: 10 digits
  return /^\d{10}$/.test(nationalId);
}

// Business Registration Number validation
function validateBusinessRegistrationNumber(regNumber) {
  // Sudanese business registration format: SD-XXXXX
  return /^SD-[A-Z0-9]{5}$/.test(regNumber);
}

// Hash biometric data (simplified - in production use secure biometric templates)
function hashBiometricData(data) {
  return crypto.createHash('sha256').update(data).digest('hex');
}

// Citizen Service
class CitizenService {
  async registerCitizen(citizenData, userOid) {
    const client = await pool.connect();

    try {
      await client.query('BEGIN');

      // Validate national ID
      if (!validateSudaneseNationalId(citizenData.national_id)) {
        throw new Error('Invalid Sudanese National ID format');
      }

      // Check for duplicate
      const duplicateCheck = await client.query(
        'SELECT national_id FROM citizens WHERE national_id = $1',
        [citizenData.national_id]
      );

      if (duplicateCheck.rows.length > 0) {
        throw new Error('Citizen already registered with this National ID');
      }

      // Generate OID via OID Service
      const oidResponse = await axios.post(
        `${process.env.OID_SERVICE_URL}/api/v1/oid/generate`,
        {
          type: '2', // Citizen type
          stateCode: citizenData.state_code || '01', // Default to Khartoum
          entityId: citizenData.national_id,
          metadata: {
            firstName: citizenData.first_name,
            lastName: citizenData.last_name,
            dateOfBirth: citizenData.date_of_birth
          }
        }
      );

      const oid = oidResponse.data.oid;

      // Hash biometric data if provided
      let biometricHash = null;
      if (citizenData.biometric_data) {
        biometricHash = hashBiometricData(citizenData.biometric_data);
      }

      // Insert citizen
      const insertQuery = `
        INSERT INTO citizens (
          oid, national_id, first_name, middle_name, last_name,
          date_of_birth, gender, phone_number, email, address,
          biometric_hash, state_code, created_by, status
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, 'active')
        RETURNING *
      `;

      const result = await client.query(insertQuery, [
        oid,
        citizenData.national_id,
        citizenData.first_name,
        citizenData.middle_name || null,
        citizenData.last_name,
        citizenData.date_of_birth,
        citizenData.gender,
        citizenData.phone_number,
        citizenData.email,
        citizenData.address,
        biometricHash,
        citizenData.state_code || '01',
        userOid
      ]);

      // Create family relationships if provided
      if (citizenData.family_members && citizenData.family_members.length > 0) {
        for (const member of citizenData.family_members) {
          await client.query(
            `INSERT INTO family_relationships
             (citizen_oid, relationship_type, related_citizen_oid)
             VALUES ($1, $2, $3)`,
            [oid, member.relationship_type, member.related_oid]
          );
        }
      }

      // Log to audit service
      await this.logAuditEvent('citizen_registered', userOid, {
        citizen_oid: oid,
        national_id: citizenData.national_id
      });

      await client.query('COMMIT');

      return {
        success: true,
        oid: oid,
        data: result.rows[0],
        message: 'Citizen registered successfully'
      };
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  async logAuditEvent(event, userOid, data) {
    try {
      await axios.post(`${process.env.AUDIT_SERVICE_URL}/api/v1/audit`, {
        event,
        user_oid: userOid,
        data,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      logger.error('Failed to log audit event', { error: error.message });
    }
  }
}

// Business Service
class BusinessService {
  async registerBusiness(businessData, userOid) {
    const client = await pool.connect();

    try {
      await client.query('BEGIN');

      // Validate business registration number
      if (!validateBusinessRegistrationNumber(businessData.registration_number)) {
        throw new Error('Invalid Sudanese business registration number format (SD-XXXXX)');
      }

      // Check for duplicate
      const duplicateCheck = await client.query(
        'SELECT registration_number FROM businesses WHERE registration_number = $1',
        [businessData.registration_number]
      );

      if (duplicateCheck.rows.length > 0) {
        throw new Error('Business already registered with this registration number');
      }

      // Verify owner exists
      const ownerCheck = await client.query(
        'SELECT oid FROM citizens WHERE oid = $1',
        [businessData.owner_oid]
      );

      if (ownerCheck.rows.length === 0) {
        throw new Error('Owner citizen not found');
      }

      // Generate OID via OID Service
      const oidResponse = await axios.post(
        `${process.env.OID_SERVICE_URL}/api/v1/oid/generate`,
        {
          type: '3', // Business type
          stateCode: businessData.state_code || '01',
          entityId: businessData.registration_number,
          metadata: {
            businessName: businessData.business_name,
            businessType: businessData.business_type
          }
        }
      );

      const oid = oidResponse.data.oid;

      // Insert business
      const insertQuery = `
        INSERT INTO businesses (
          oid, registration_number, business_name, business_type,
          owner_oid, tax_id, address, phone_number, email,
          state_code, created_by, status
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, 'active')
        RETURNING *
      `;

      const result = await client.query(insertQuery, [
        oid,
        businessData.registration_number,
        businessData.business_name,
        businessData.business_type,
        businessData.owner_oid,
        businessData.tax_id || null,
        businessData.address,
        businessData.phone_number,
        businessData.email,
        businessData.state_code || '01',
        userOid
      ]);

      // Log to audit service
      await this.logAuditEvent('business_registered', userOid, {
        business_oid: oid,
        registration_number: businessData.registration_number
      });

      await client.query('COMMIT');

      return {
        success: true,
        oid: oid,
        data: result.rows[0],
        message: 'Business registered successfully'
      };
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  async logAuditEvent(event, userOid, data) {
    try {
      await axios.post(`${process.env.AUDIT_SERVICE_URL}/api/v1/audit`, {
        event,
        user_oid: userOid,
        data,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      logger.error('Failed to log audit event', { error: error.message });
    }
  }
}

const citizenService = new CitizenService();
const businessService = new BusinessService();

// Authentication middleware
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }

  jwt.verify(token, JWT_SECRET, (err, decoded) => {
    if (err) {
      return res.status(403).json({ error: 'Invalid token' });
    }
    req.user = decoded;
    next();
  });
};

// API Routes

// Citizen Registration
app.post('/api/v1/identity/citizen/register', registrationLimiter, authenticateToken, [
  body('national_id').notEmpty().withMessage('National ID is required'),
  body('first_name').notEmpty().withMessage('First name is required'),
  body('last_name').notEmpty().withMessage('Last name is required'),
  body('date_of_birth').isISO8601().withMessage('Valid date of birth required'),
  body('gender').isIn(['M', 'F', 'O']).withMessage('Gender must be M, F, or O'),
  body('phone_number').optional().isMobilePhone('any').withMessage('Valid phone number required'),
  body('email').optional().isEmail().withMessage('Valid email required')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const citizenData = req.body;
    const userOid = req.user.oid; // From JWT token

    const result = await citizenService.registerCitizen(citizenData, userOid);

    res.status(201).json(result);
  } catch (error) {
    logger.error('Citizen registration error', { error: error.message, stack: error.stack });
    res.status(500).json({ error: error.message });
  }
});

// Business Registration
app.post('/api/v1/identity/business/register', registrationLimiter, authenticateToken, [
  body('registration_number').notEmpty().withMessage('Registration number is required'),
  body('business_name').notEmpty().withMessage('Business name is required'),
  body('business_type').notEmpty().withMessage('Business type is required'),
  body('owner_oid').notEmpty().withMessage('Owner OID is required'),
  body('address').notEmpty().withMessage('Address is required'),
  body('phone_number').optional().isMobilePhone('any').withMessage('Valid phone number required')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const businessData = req.body;
    const userOid = req.user.oid;

    const result = await businessService.registerBusiness(businessData, userOid);

    res.status(201).json(result);
  } catch (error) {
    logger.error('Business registration error', { error: error.message, stack: error.stack });
    res.status(500).json({ error: error.message });
  }
});

// Get citizen by OID
app.get('/api/v1/identity/citizen/:oid', authenticateToken, async (req, res) => {
  try {
    const { oid } = req.params;

    const query = `
      SELECT
        c.oid, c.national_id, c.first_name, c.middle_name, c.last_name,
        c.date_of_birth, c.gender, c.phone_number, c.email, c.address,
        c.state_code, c.created_at, c.status,
        fr.relationship_type, fr.related_citizen_oid
      FROM citizens c
      LEFT JOIN family_relationships fr ON c.oid = fr.citizen_oid
      WHERE c.oid = $1 AND c.status = 'active'
    `;

    const result = await pool.query(query, [oid]);

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Citizen not found' });
    }

    // Group family relationships
    const citizen = result.rows[0];
    const familyMembers = result.rows
      .filter(row => row.relationship_type)
      .map(row => ({
        relationship_type: row.relationship_type,
        related_citizen_oid: row.related_citizen_oid
      }));

    res.json({
      success: true,
      data: {
        ...citizen,
        family_members: familyMembers
      }
    });
  } catch (error) {
    logger.error('Get citizen error', { error: error.message, stack: error.stack });
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Verify identity (biometric or document)
app.post('/api/v1/identity/verify', authenticateToken, async (req, res) => {
  try {
    const { oid, verification_type, verification_data } = req.body;

    if (!oid || !verification_type || !verification_data) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    // Get citizen
    const citizenQuery = 'SELECT biometric_hash FROM citizens WHERE oid = $1 AND status = 'active'';
    const citizenResult = await pool.query(citizenQuery, [oid]);

    if (citizenResult.rows.length === 0) {
      return res.status(404).json({ error: 'Citizen not found' });
    }

    let verified = false;
    let verificationDetails = {};

    if (verification_type === 'biometric') {
      // Hash the provided biometric data and compare
      const providedHash = hashBiometricData(verification_data);
      verified = providedHash === citizenResult.rows[0].biometric_hash;
      verificationDetails = { type: 'biometric', match: verified };
    } else if (verification_type === 'document') {
      // Simulate document verification (in production, integrate with document verification service)
      // For Sudanese context: could integrate with passport, driver's license, etc.
      verified = true; // Simplified for demonstration
      verificationDetails = { type: 'document', status: 'verified' };
    }

    // Log verification
    await axios.post(`${process.env.AUDIT_SERVICE_URL}/api/v1/audit`, {
      event: 'identity_verified',
      user_oid: req.user.oid,
      data: { citizen_oid: oid, verification_type, verified },
      timestamp: new Date().toISOString()
    });

    res.json({
      success: true,
      verified,
      verification_details: verificationDetails,
      message: verified ? 'Verification successful' : 'Verification failed'
    });
  } catch (error) {
    logger.error('Verification error', { error: error.message, stack: error.stack });
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Health check
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    service: 'Identity Service',
    timestamp: new Date().toISOString(),
    version: '1.0.0'
  });
});

const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  logger.info(`Identity Service running on port ${PORT}`);
  console.log(`Identity Service running on port ${PORT}`);
});

module.exports = app;
 
2.4 Agency Integration Service (Sudanese Government Systems)
 
File: backend/agency-integration/src/app.js
javascript
javascript
const express = require('express');
const { Pool } = require('pg');
const axios = require('axios');
const xml2js = require('xml2js');
const { body, validationResult } = require('express-validator');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const winston = require('winston');

const app = express();
app.use(express.json());
app.use(helmet());

// Rate limiting
const integrationLimiter = rateLimit({
  windowMs: 5 * 60 * 1000, // 5 minutes
  max: 50,
  message: 'Too many integration requests'
});

// Database connection
const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: process.env.DB_PORT
});

// Logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'integration-errors.log', level: 'error' }),
    new winston.transports.File({ filename: 'integration-combined.log' })
  ]
});

// Sudanese Government Agency Configurations
const AGENCIES = {
  CIVIL_REGISTRY: {
    name: 'Civil Registry Department',
    ministry: 'Ministry of Interior',
    endpoint: process.env.CIVIL_REGISTRY_ENDPOINT || 'http://civil-registry:8080/api',
    authType: 'basic',
    credentials: {
      username: process.env.CIVIL_REGISTRY_USERNAME,
      password: process.env.CIVIL_REGISTRY_PASSWORD
    }
  },
  BUSINESS_REGISTRATION: {
    name: 'Business Registration Office',
    ministry: 'Ministry of Trade and Industry',
    endpoint: process.env.BUSINESS_REG_ENDPOINT || 'http://business-reg:8080/api',
    authType: 'token',
    token: process.env.BUSINESS_REG_TOKEN
  },
  TAX_AUTHORITY: {
    name: 'National Tax Authority',
    ministry: 'Ministry of Finance',
    endpoint: process.env.TAX_AUTHORITY_ENDPOINT || 'http://tax-authority:8080/api',
    authType: 'oauth2',
    clientId: process.env.TAX_CLIENT_ID,
    clientSecret: process.env.TAX_CLIENT_SECRET
  },
  CUSTOMS: {
    name: 'Customs Authority',
    ministry: 'Ministry of Finance',
    endpoint: process.env.CUSTOMS_ENDPOINT || 'http://customs:8080/api',
    authType: 'basic',
    credentials: {
      username: process.env.CUSTOMS_USERNAME,
      password: process.env.CUSTOMS_PASSWORD
    }
  },
  LAND_REGISTRY: {
    name: 'Land Registry',
    ministry: 'Ministry of Land and Housing',
    endpoint: process.env.LAND_REGISTRY_ENDPOINT || 'http://land-registry:8080/api',
    authType: 'certificate',
    certPath: process.env.LAND_CERT_PATH
  }
};

// Integration Adapter Base Class
class IntegrationAdapter {
  constructor(agencyConfig) {
    this.config = agencyConfig;
    this.maxRetries = 3;
    this.timeout = 30000; // 30 seconds
  }

  async authenticate() {
    switch (this.config.authType) {
      case 'basic':
        return {
          'Authorization': `Basic ${Buffer.from(`${this.config.credentials.username}:${this.config.credentials.password}`).toString('base64')}`
        };
      case 'token':
        return { 'Authorization': `Bearer ${this.config.token}` };
      case 'oauth2':
        // Get OAuth2 token
        const tokenResponse = await axios.post(`${this.config.endpoint}/oauth/token`, {
          grant_type: 'client_credentials',
          client_id: this.config.clientId,
          client_secret: this.config.clientSecret
        });
        return { 'Authorization': `Bearer ${tokenResponse.data.access_token}` };
      default:
        return {};
    }
  }

  async makeRequest(method, path, data = null, retryCount = 0) {
    try {
      const headers = await this.authenticate();
      headers['Content-Type'] = 'application/json';
      headers['X-Request-ID'] = require('crypto').randomBytes(16).toString('hex');

      const url = `${this.config.endpoint}${path}`;
      const config = {
        method,
        url,
        headers,
        timeout: this.timeout
      };

      if (data) {
        config.data = data;
      }

      const response = await axios(config);
      return response.data;
    } catch (error) {
      logger.error(`Integration request failed`, {
        agency: this.config.name,
        method,
        path,
        error: error.message,
        retryCount
      });

      if (retryCount < this.maxRetries && this.isRetryableError(error)) {
        // Exponential backoff
        const delay = Math.pow(2, retryCount) * 1000;
        await new Promise(resolve => setTimeout(resolve, delay));
        return this.makeRequest(method, path, data, retryCount + 1);
      }

      throw error;
    }
  }

  isRetryableError(error) {
    if (!error.response) return true; // Network errors
    const status = error.response.status;
    return status >= 500 || status === 408 || status === 429;
  }
}

// Civil Registry Adapter (Birth Registration Integration)
class CivilRegistryAdapter extends IntegrationAdapter {
  async registerBirth(birthData) {
    // Convert to Civil Registry format
    const civilRegistryData = {
      national_id: birthData.national_id,
      first_name: birthData.first_name,
      last_name: birthData.last_name,
      date_of_birth: birthData.date_of_birth,
      gender: birthData.gender,
      father_national_id: birthData.father_national_id,
      mother_national_id: birthData.mother_national_id,
      place_of_birth: birthData.place_of_birth,
      registration_date: new Date().toISOString()
    };

    const result = await this.makeRequest('POST', '/birth/register', civilRegistryData);
    return result;
  }

  async verifyCitizen(nationalId) {
    const result = await this.makeRequest('GET', `/citizen/${nationalId}`);
    return result;
  }
}

// Business Registration Adapter
class BusinessRegistrationAdapter extends IntegrationAdapter {
  async registerBusiness(businessData) {
    const businessRegData = {
      registration_number: businessData.registration_number,
      business_name: businessData.business_name,
      business_type: businessData.business_type,
      owner_national_id: businessData.owner_national_id,
      address: businessData.address,
      phone: businessData.phone,
      email: businessData.email,
      tax_id: businessData.tax_id,
      registration_date: new Date().toISOString()
    };

    const result = await this.makeRequest('POST', '/business/register', businessRegData);
    return result;
  }

  async getBusinessStatus(registrationNumber) {
    const result = await this.makeRequest('GET', `/business/${registrationNumber}/status`);
    return result;
  }
}

// Tax Authority Adapter (Tax ID Generation)
class TaxAuthorityAdapter extends IntegrationAdapter {
  async generateTaxId(businessData) {
    const taxData = {
      business_name: businessData.business_name,
      registration_number: businessData.registration_number,
      owner_national_id: businessData.owner_national_id,
      address: businessData.address,
      business_type: businessData.business_type
    };

    const result = await this.makeRequest('POST', '/tax-id/generate', taxData);
    return result;
  }

  async verifyTaxId(taxId) {
    const result = await this.makeRequest('GET', `/tax-id/${taxId}/verify`);
    return result;
  }
}

// Customs Adapter (Export/Import Licensing)
class CustomsAdapter extends IntegrationAdapter {
  async requestExportLicense(exportData) {
    const licenseData = {
      business_oid: exportData.business_oid,
      business_registration_number: exportData.registration_number,
      product_description: exportData.product_description,
      quantity: exportData.quantity,
      destination_country: exportData.destination_country,
      value_usd: exportData.value_usd,
      supporting_documents: exportData.documents
    };

    const result = await this.makeRequest('POST', '/export/license', licenseData);
    return result;
  }

  async getLicenseStatus(licenseNumber) {
    const result = await this.makeRequest('GET', `/export/license/${licenseNumber}/status`);
    return result;
  }
}

// Land Registry Adapter
class LandRegistryAdapter extends IntegrationAdapter {
  async registerProperty(propertyData) {
    const propertyRegData = {
      property_id: propertyData.property_id,
      owner_oid: propertyData.owner_oid,
      address: propertyData.address,
      plot_number: propertyData.plot_number,
      area_sqm: propertyData.area_sqm,
      title_deed_number: propertyData.title_deed_number,
      registration_date: new Date().toISOString()
    };

    const result = await this.makeRequest('POST', '/property/register', propertyRegData);
    return result;
  }

  async getPropertyStatus(propertyId) {
    const result = await this.makeRequest('GET', `/property/${propertyId}/status`);
    return result;
  }
}

// Initialize adapters
const adapters = {
  CIVIL_REGISTRY: new CivilRegistryAdapter(AGENCIES.CIVIL_REGISTRY),
  BUSINESS_REGISTRATION: new BusinessRegistrationAdapter(AGENCIES.BUSINESS_REGISTRATION),
  TAX_AUTHORITY: new TaxAuthorityAdapter(AGENCIES.TAX_AUTHORITY),
  CUSTOMS: new CustomsAdapter(AGENCIES.CUSTOMS),
  LAND_REGISTRY: new LandRegistryAdapter(AGENCIES.LAND_REGISTRY)
};

// API Routes

// Civil Registry Integration
app.post('/api/v1/integration/civil-registry/birth', integrationLimiter, [
  body('national_id').notEmpty(),
  body('first_name').notEmpty(),
  body('last_name').notEmpty(),
  body('date_of_birth').isISO8601(),
  body('gender').isIn(['M', 'F', 'O'])
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const result = await adapters.CIVIL_REGISTRY.registerBirth(req.body);
    res.json({ success: true, data: result });
  } catch (error) {
    logger.error('Civil Registry integration error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Business Registration Integration
app.post('/api/v1/integration/business/register', integrationLimiter, [
  body('registration_number').notEmpty(),
  body('business_name').notEmpty(),
  body('business_type').notEmpty(),
  body('owner_national_id').notEmpty()
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const result = await adapters.BUSINESS_REGISTRATION.registerBusiness(req.body);
    res.json({ success: true, data: result });
  } catch (error) {
    logger.error('Business registration integration error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Tax Authority Integration
app.post('/api/v1/integration/tax-id/generate', integrationLimiter, [
  body('business_name').notEmpty(),
  body('registration_number').notEmpty(),
  body('owner_national_id').notEmpty()
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const result = await adapters.TAX_AUTHORITY.generateTaxId(req.body);
    res.json({ success: true, data: result });
  } catch (error) {
    logger.error('Tax ID generation error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Customs Integration
app.post('/api/v1/integration/customs/export-license', integrationLimiter, [
  body('business_oid').notEmpty(),
  body('product_description').notEmpty(),
  body('destination_country').notEmpty()
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const result = await adapters.CUSTOMS.requestExportLicense(req.body);
    res.json({ success: true, data: result });
  } catch (error) {
    logger.error('Customs integration error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Land Registry Integration
app.post('/api/v1/integration/land/register', integrationLimiter, [
  body('property_id').notEmpty(),
  body('owner_oid').notEmpty(),
  body('address').notEmpty()
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const result = await adapters.LAND_REGISTRY.registerProperty(req.body);
    res.json({ success: true, data: result });
  } catch (error) {
    logger.error('Land registry integration error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Bulk integration for pilot (register citizen across multiple agencies)
app.post('/api/v1/integration/bulk/register', integrationLimiter, async (req, res) => {
  try {
    const { citizen_data, business_data } = req.body;

    const results = {};

    // Register in Civil Registry
    if (citizen_data) {
      results.civilRegistry = await adapters.CIVIL_REGISTRY.registerBirth(citizen_data);
    }

    // Register business and get Tax ID
    if (business_data) {
      results.businessRegistration = await adapters.BUSINESS_REGISTRATION.registerBusiness(business_data);

      if (results.businessRegistration.success) {
        results.taxId = await adapters.TAX_AUTHORITY.generateTaxId({
          ...business_data,
          registration_number: results.businessRegistration.registration_number
        });
      }
    }

    res.json({ success: true, results });
  } catch (error) {
    logger.error('Bulk integration error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Health check
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    service: 'Agency Integration Service',
    timestamp: new Date().toISOString(),
    version: '1.0.0'
  });
});

const PORT = process.env.PORT || 3005;
app.listen(PORT, () => {
  logger.info(`Agency Integration Service running on port ${PORT}`);
  console.log(`Agency Integration Service running on port ${PORT}`);
});

module.exports = app;
 
2.5 USSD Service (For Basic Phones)
 
File: backend/ussd-service/src/app.js
javascript
javascript
const express = require('express');
const bodyParser = require('body-parser');
const axios = require('axios');
const { Pool } = require('pg');
const winston = require('winston');

const app = express();
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

// Database connection
const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: process.env.DB_PORT
});

// Logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'ussd-errors.log', level: 'error' }),
    new winston.transports.File({ filename: 'ussd-combined.log' })
  ]
});

// USSD Session Management
class USSDSession {
  constructor(sessionId, phoneNumber) {
    this.sessionId = sessionId;
    this.phoneNumber = phoneNumber;
    this.state = 'MENU';
    this.step = 0;
    this.data = {};
    this.createdAt = new Date();
    this.lastActivity = new Date();
  }

  updateLastActivity() {
    this.lastActivity = new Date();
  }

  setState(state) {
    this.state = state;
    this.step = 0;
    this.updateLastActivity();
  }

  setStep(step) {
    this.step = step;
    this.updateLastActivity();
  }

  setData(key, value) {
    this.data[key] = value;
    this.updateLastActivity();
  }

  getData(key) {
    return this.data[key];
  }

  clear() {
    this.state = 'MENU';
    this.step = 0;
    this.data = {};
    this.updateLastActivity();
  }
}

// Session storage (in production, use Redis)
const sessions = new Map();

// Get or create session
function getSession(sessionId, phoneNumber) {
  if (!sessions.has(sessionId)) {
    sessions.set(sessionId, new USSDSession(sessionId, phoneNumber));
  }
  return sessions.get(sessionId);
}

// Clean old sessions (every 30 minutes)
setInterval(() => {
  const now = new Date();
  for (const [sessionId, session] of sessions.entries()) {
    const diff = now - session.lastActivity;
    if (diff > 30 * 60 * 1000) { // 30 minutes
      sessions.delete(sessionId);
    }
  }
}, 30 * 60 * 1000);

// USSD Response Builder
function buildResponse(messages, end = false) {
  const response = messages.join('\n');
  return end ? `END ${response}` : `CON ${response}`;
}

// Main USSD Handler
app.post('/api/v1/ussd', async (req, res) => {
  try {
    const { sessionId, phoneNumber, text } = req.body;

    // Validate input
    if (!sessionId || !phoneNumber) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const session = getSession(sessionId, phoneNumber);
    const userInput = text ? text.split('*') : [];
    const lastInput = userInput[userInput.length - 1] || '';

    // Log USSD request
    logger.info('USSD Request', {
      sessionId,
      phoneNumber,
      text,
      state: session.state,
      step: session.step
    });

    let response = '';
    let end = false;

    // State machine for USSD flow
    switch (session.state) {
      case 'MENU':
        response = buildResponse([
          'Welcome to SGDUS',
          '1. Register as Citizen',
          '2. Register as Business',
          '3. Verify Identity',
          '4. Check Status',
          '5. Help'
        ]);
        session.setState('MENU_SELECTION');
        break;

      case 'MENU_SELECTION':
        if (lastInput === '1') {
          response = buildResponse([
            'Enter National ID (10 digits):'
          ]);
          session.setState('CITIZEN_REGISTRATION');
          session.setStep(1);
        } else if (lastInput === '2') {
          response = buildResponse([
            'Enter Business Registration Number (SD-XXXXX):'
          ]);
          session.setState('BUSINESS_REGISTRATION');
          session.setStep(1);
        } else if (lastInput === '3') {
          response = buildResponse([
            'Enter your OID:'
          ]);
          session.setState('IDENTITY_VERIFICATION');
          session.setStep(1);
        } else if (lastInput === '4') {
          response = buildResponse([
            'Enter your National ID or Business Registration Number:'
          ]);
          session.setState('STATUS_CHECK');
          session.setStep(1);
        } else if (lastInput === '5') {
          response = buildResponse([
            'SGDUS Help:',
            'Register citizens/businesses',
            'Verify identity',
            'Check registration status',
            'For assistance call: 123456789'
          ], true);
          session.clear();
        } else {
          response = buildResponse([
            'Invalid option',
            'Please select 1-5'
          ]);
          session.setState('MENU');
        }
        break;

      case 'CITIZEN_REGISTRATION':
        if (session.step === 1) {
          // Validate National ID
          if (!/^\d{10}$/.test(lastInput)) {
            response = buildResponse([
              'Invalid National ID',
              'Must be 10 digits',
              'Enter National ID:'
            ]);
          } else {
            session.setData('national_id', lastInput);
            response = buildResponse([
              'Enter First Name:'
            ]);
            session.setStep(2);
          }
        } else if (session.step === 2) {
          if (!lastInput.trim()) {
            response = buildResponse([
              'Invalid name',
              'Enter First Name:'
            ]);
          } else {
            session.setData('first_name', lastInput);
            response = buildResponse([
              'Enter Last Name:'
            ]);
            session.setStep(3);
          }
        } else if (session.step === 3) {
          if (!lastInput.trim()) {
            response = buildResponse([
              'Invalid name',
              'Enter Last Name:'
            ]);
          } else {
            session.setData('last_name', lastInput);
            response = buildResponse([
              'Enter Date of Birth (YYYY-MM-DD):'
            ]);
            session.setStep(4);
          }
        } else if (session.step === 4) {
          // Simple date validation
          if (!/^\d{4}-\d{2}-\d{2}$/.test(lastInput)) {
            response = buildResponse([
              'Invalid date format',
              'Use YYYY-MM-DD',
              'Enter Date of Birth:'
            ]);
          } else {
            session.setData('date_of_birth', lastInput);
            response = buildResponse([
              'Enter Gender (M/F):'
            ]);
            session.setStep(5);
          }
        } else if (session.step === 5) {
          if (lastInput.toUpperCase() !== 'M' && lastInput.toUpperCase() !== 'F') {
            response = buildResponse([
              'Invalid gender',
              'Enter M or F:'
            ]);
          } else {
            session.setData('gender', lastInput.toUpperCase());

            // Call Identity Service API
            try {
              const apiResponse = await axios.post(
                `${process.env.IDENTITY_SERVICE_URL}/api/v1/identity/citizen/register`,
                {
                  national_id: session.getData('national_id'),
                  first_name: session.getData('first_name'),
                  last_name: session.getData('last_name'),
                  date_of_birth: session.getData('date_of_birth'),
                  gender: session.getData('gender'),
                  phone_number: phoneNumber
                },
                {
                  headers: {
                    'Authorization': `Bearer ${process.env.API_TOKEN}`
                  }
                }
              );

              if (apiResponse.data.success) {
                response = buildResponse([
                  'Registration Successful!',
                  `Your OID: ${apiResponse.data.oid}`,
                  'Save this OID for future use'
                ], true);

                // Send SMS with OID (simulated)
                logger.info('SMS sent', {
                  phone: phoneNumber,
                  message: `SGDUS Registration: Your OID is ${apiResponse.data.oid}`
                });
              } else {
                response = buildResponse([
                  'Registration Failed',
                  apiResponse.data.error || 'Unknown error'
                ], true);
              }
            } catch (error) {
              logger.error('Citizen registration API error', { error: error.message });
              response = buildResponse([
                'System Error',
                'Please try again later'
              ], true);
            }

            session.clear();
          }
        }
        break;

      case 'BUSINESS_REGISTRATION':
        if (session.step === 1) {
          // Validate Business Registration Number
          if (!/^SD-[A-Z0-9]{5}$/.test(lastInput)) {
            response = buildResponse([
              'Invalid format',
              'Use SD-XXXXX',
              'Enter Registration Number:'
            ]);
          } else {
            session.setData('registration_number', lastInput);
            response = buildResponse([
              'Enter Business Name:'
            ]);
            session.setStep(2);
          }
        } else if (session.step === 2) {
          if (!lastInput.trim()) {
            response = buildResponse([
              'Invalid name',
              'Enter Business Name:'
            ]);
          } else {
            session.setData('business_name', lastInput);
            response = buildResponse([
              'Enter Owner OID:'
            ]);
            session.setStep(3);
          }
        } else if (session.step === 3) {
          // Simple OID validation
          if (!lastInput.startsWith('1.3.6.1.4.1.61026.')) {
            response = buildResponse([
              'Invalid OID format',
              'Enter Owner OID:'
            ]);
          } else {
            session.setData('owner_oid', lastInput);

            // Call Business Registration API
            try {
              const apiResponse = await axios.post(
                `${process.env.IDENTITY_SERVICE_URL}/api/v1/identity/business/register`,
                {
                  registration_number: session.getData('registration_number'),
                  business_name: session.getData('business_name'),
                  owner_oid: session.getData('owner_oid'),
                  phone_number: phoneNumber
                },
                {
                  headers: {
                    'Authorization': `Bearer ${process.env.API_TOKEN}`
                  }
                }
              );

              if (apiResponse.data.success) {
                response = buildResponse([
                  'Business Registration Successful!',
                  `Business OID: ${apiResponse.data.oid}`,
                  'Save this OID for future use'
                ], true);
              } else {
                response = buildResponse([
                  'Registration Failed',
                  apiResponse.data.error || 'Unknown error'
                ], true);
              }
            } catch (error) {
              logger.error('Business registration API error', { error: error.message });
              response = buildResponse([
                'System Error',
                'Please try again later'
              ], true);
            }

            session.clear();
          }
        }
        break;

      case 'IDENTITY_VERIFICATION':
        if (session.step === 1) {
          if (!lastInput.startsWith('1.3.6.1.4.1.61026.')) {
            response = buildResponse([
              'Invalid OID format',
              'Enter OID:'
            ]);
          } else {
            session.setData('oid', lastInput);
            response = buildResponse([
              'Enter Biometric Hash (simulated):'
            ]);
            session.setStep(2);
          }
        } else if (session.step === 2) {
          // Simulate biometric verification
          session.setData('biometric_hash', lastInput);

          // Call verification API
          try {
            const apiResponse = await axios.post(
              `${process.env.IDENTITY_SERVICE_URL}/api/v1/identity/verify`,
              {
                oid: session.getData('oid'),
                verification_type: 'biometric',
                verification_data: session.getData('biometric_hash')
              },
              {
                headers: {
                  'Authorization': `Bearer ${process.env.API_TOKEN}`
                }
              }
            );

            if (apiResponse.data.verified) {
              response = buildResponse([
                'Verification Successful',
                'Identity confirmed'
              ], true);
            } else {
              response = buildResponse([
                'Verification Failed',
                'Biometric mismatch'
              ], true);
            }
          } catch (error) {
            logger.error('Verification API error', { error: error.message });
            response = buildResponse([
              'System Error',
              'Please try again later'
            ], true);
          }

          session.clear();
        }
        break;

      case 'STATUS_CHECK':
        if (session.step === 1) {
          if (!lastInput.trim()) {
            response = buildResponse([
              'Invalid input',
              'Enter ID:'
            ]);
          } else {
            session.setData('id', lastInput);

            // Determine if it's a National ID or Business Registration
            const isNationalId = /^\d{10}$/.test(lastInput);
            const isBusinessReg = /^SD-[A-Z0-9]{5}$/.test(lastInput);

            if (isNationalId) {
              // Check citizen status
              try {
                const apiResponse = await axios.get(
                  `${process.env.IDENTITY_SERVICE_URL}/api/v'
                  ], true);
                }
              } catch (error) {
                logger.error('Status check API error', { error: error.message });
                response = buildResponse([
                  'System Error',
                  'Please try again later'
                ], true);
              }
            } else {
              response = buildResponse([
                'Invalid ID',
                'Enter National ID (10 digits) or Business Registration (SD-XXXXX)'
              ], true);
            }

            session.clear();
          }
        }
        break;

      default:
        response = buildResponse([
          'Invalid session',
          'Please start over'
        ], true);
        session.clear();
    }

    res.set('Content-Type', 'text/plain');
    res.send(response);
  } catch (error) {
    logger.error('USSD handler error', { error: error.message, stack: error.stack });
    res.set('Content-Type', 'text/plain');
    res.send('END System Error. Please try again later.');
  }
});

// Health check
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    service: 'USSD Service',
    timestamp: new Date().toISOString(),
    version: '1.0.0'
  });
});

const PORT = process.env.PORT || 3007;
app.listen(PORT, () => {
  logger.info(`USSD Service running on port ${PORT}`);
  console.log(`USSD Service running on port ${PORT}`);
});

module.exports = app;
 
**2.6 Frontend - Web Portal (1/identity/citizen/by-national-id/${lastInput}`,
text
text
              {
                headers: {
                  'Authorization': `Bearer ${process.env.API_TOKEN}`
                }
              }
            );

            if (apiResponse.data.success) {
              response = buildResponse([
                'Citizen Status',
                `OID: ${apiResponse.data.oid}`,
                `Name: ${apiResponse.data.first_name} ${apiResponse.data.last_name}`,
                `Status: ${apiResponse.data.status}`
              ], true);
            } else {
              response = buildResponse([
                'Not Found',
                'Citizen not registered'
              ], true);
            }
          } catch (error) {
            logger.error('Status check API error', { error: error.message });
            response = buildResponse([
              'System Error',
              'Please try again later'
            ], true);
          }
        } else if (isBusinessReg) {
          // Check business status
          try {
            const apiResponse = await axios.get(
              `${process.env.IDENTITY_SERVICE_URL}/api/v1/identity/business/by-registration-number/${lastInput}`,
              {
                headers: {
                  'Authorization': `Bearer ${process.env.API_TOKEN}`
                }
              }
            );

            if (apiResponse.data.success) {
              response = buildResponse([
                'Business Status',
                `OID: ${apiResponse.data.oid}`,
                `Name: ${apiResponse.data.business_name}`,
                `Status: ${apiResponse.data.status}`
              ], true);
            } else {
              response = buildResponse([
                'Not Found',
                'Business not registered,
Typography, TextField, Button, Grid, FormControl, InputLabel, Select, MenuItem, Alert, CircularProgress, Stepper, Step, StepLabel, Box } from '@mui/material'; import { LocalizationProvider, DatePicker } from '@mui/x-date-pickers'; import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
 
const API_GATEWAY = process.env.REACT_APP_API_GATEWAY || '
http://localhost:3000
';
 
const CitizenRegistration = () => { const [activeStep, setActiveStep] = useState(0); const [loading, setLoading] = useState(false); const [error, setError] = useState(''); const [success, setSuccess] = useState(''); const [formData, setFormData] = useState({ national_id: '', first_name: '', middle_name: '', last_name: '', date_of_birth: null, gender: '', phone_number: '', email: '', address: '', state_code: '01', // Khartoum default biometric_data: '' });
 
const steps = ['Personal Information', 'Contact Details', 'Address & State', 'Biometric (Optional)', 'Review'];
 
const handleChange = (field, value) => { setFormData(prev => ({ ...prev, [field]: value })); };
 
const validateStep = (step) => { switch (step) { case 0: return formData.national_id && formData.first_name && formData.last_name && formData.date_of_birth && formData.gender; case 1: return formData.phone_number; case 2: return formData.address; default: return true; } };
 
const handleNext = () => { if (validateStep(activeStep)) { setActiveStep(prev => prev + 1); setError(''); } else { setError('Please fill in all required fields'); } };
 
const handleBack = () => { setActiveStep(prev => prev - 1); setError(''); };
 
const handleSubmit = async () => { setLoading(true); setError(''); setSuccess('');
 
text
text
try {
  // Get auth token (in real app, from login)
  const token = localStorage.getItem('authToken') || process.env.REACT_APP_API_TOKEN;

  const response = await axios.post(
    `${API_GATEWAY}/api/v1/identity/citizen/register`,
    formData,
    {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-TypeReact)**
 
File: frontend/web-portal/src/components/CitizenRegistration.js
javascript
javascript
import React, { useState } from 'react';
import axios from 'axios';
import {
  Container,
  Paper': 'application/json'
          }
        }
      );

      if (response.data.success) {
        setSuccess(`CitMenuItem value="0izen registered successfully! OID: ${response.data.oid}`);
        setFormData({
          national_id: '',
          first_name: '',
          middle_name: '',
          last_name: '',
          date_of_birth: null,
          gender: '',
          phone_number: '',
          email: '',
          address: '',
          state_code: '01',
          biometric_data: ''
        });
        setActiveStep(0);
      } else {
        setError(response.data.error || 'Registration failed');
      }
    } catch (error) {
      console.error('Registration error:', error);
      setError(error.response?.data?.error || 'An error occurred. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const getStepContent = (step) => {
    switch (step) {
      case 0:
        return (
          <Grid container spacing={2}>
            <Grid item xs={12} md={6}>
              <TextField
                fullWidth
                label="National ID (10 digits)"
                value={formData.national_id}
                onChange={(e) => handleChange('national_id', e.target.value)}
                required
                inputProps={{ pattern: '\\d{10}' }}
                helperText="Sudanese National ID must be 10 digits"
              />
            </Grid>
            <Grid item xs={12} md={6}>
              <TextField
                fullWidth
                label="First Name"
                value={formData.first_name}
                onChange={(e) => handleChange('first_name', e.target.value)}
                required
              />
            </Grid>
            <Grid item xs={12} md={6}>
              <TextField
                fullWidth
                label="Middle Name"
                value={formData.middle_name}
                onChange={(e) => handleChange('middle_name', e.target.value)}
              />
            </Grid>
            <Grid item xs={12} md={6}>
              <TextField
                fullWidth
                label="Last Name"
                value={formData.last_name}
                onChange={(e) => handleChange('last_name', e.target.value)}
                required
              />
            </Grid>
            <Grid item xs={12} md={6}>
              <LocalizationProvider dateAdapter={AdapterDateFns}>
                <DatePicker
                  label="Date of Birth"
                  value={formData.date_of_birth}
                  onChange={(newValue) => handleChange('date_of_birth', newValue)}
                  renderInput={(params) => <TextField {...params} fullWidth required />}
                />
              </LocalizationProvider>
            </Grid>
            <Grid item xs={12} md={6}>
              <FormControl fullWidth required>
                <InputLabel>Gender</InputLabel>
                <Select
                  value={formData.gender}
                  onChange={(e) => handleChange('gender', e.target.value)}
                  label="Gender"
                >
                  <MenuItem value="M">Male</MenuItem>
                  <MenuItem value="F">Female</MenuItem>
                  <MenuItem value="O">Other</MenuItem>
                </Select>
              </FormControl>
            </Grid>
          </Grid>
        );

      case 1:
        return (
          <Grid container spacing={2}>
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Phone Number"
                value={formData.phone_number}
                onChange={(e) => handleChange('phone_number', e.target.value)}
                required
                helperText="Sudanese mobile number (e.g., +249XXXXXXXXX)"
              />
            </Grid>
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Email"
                typeKassala',
="email"
                value={formData.email}
                onChange={(e) => handleChange('email', e.target.value)}
              />
            </Grid>
          </Grid>
        );

      case 2:
        return (
          <Grid container spacing={2}>
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Address"
                multiline
                rows={3}
                value={formData.address}
                onChange={(e) => handleChange('address', e.target.value)}
                required
              />
            </Grid>
            <Grid item xs={12}>
              <FormControl fullWidth required>
                <InputLabel>State</InputLabel>
                <Select
                  value={formData.state_code}
                  onChange={(e) => handleChange('state_code', e.target.value)}
                  label="State"
                >
                  <MenuItem value="01">Khartoum</MenuItem>
                  <MenuItem value="02">Port Sudan</MenuItem>
                  <MenuItem value="03">North Kordofan</MenuItem>
                  <MenuItem value="04">South Kordofan</MenuItem>
                  <MenuItem value="05">West Kordofan</MenuItem>
                  <6">North Dar Nile</MenuItem>
                  <MenuItem value="12">Blue Nile</MenuItem>
                  <MenuItem value="13">River Nile</MenuItem>
                  <MenuItem value="14">Kassala</parameter>
                  <MenuItem value="15">Red Sea</parameter>
                  <MenuItem value="16">Gezira</parameter>
                  <MenuItem value="17">Sennar</parameter>
                  <MenuItem value="18">Al Qadarif</parameter>
                </Select>
              </FormControl>
            </Grid>
          </Grid>
        );

      case 3:
        return (
          <Grid container spacing={2}>
            <Grid item xs={12}>
              <Typography variant="body2" color="textSecondary" gutterBottom>
                Optional: For enhanced verification, you can provide biometric data (fingerprint template).
                This helps prevent identity fraud and is stored securely.
              </Typography>
              <TextField
                fullWidth
                label="Biometric Data (Fingerprint Hash)"
                value={formData.biometric_data}
                onChange={(e) => handleChange('biometric_data', e.target.value)}
                helperText="Enter fingerprint template hash if available"
              />
            </Grid>
          </Grid>
        );

      case 4:
        return (
          <Box>
            <Typography variant="h6" gutterBottom>Review Your Information</Typography>
            <Grid container spacing={1}>
              <Grid item xs={6}><strong>National ID:</strong> {formData.national_id}</Grid>
              <Grid item xs={6}><strong>Name:</strong> {formData.first_name} {formData.middle_name} {formData.last_name}</Grid>
              <Grid item xs={6}><strong>Date of Birth:</strong> {formData.date_of_birth?.toLocaleDateString()}</Grid>
              <Grid item xs={6}><strong>Gender:</strong> {formData.gender}</Grid>
              <Grid item xs={6}><strong>Phone:</strong> {formData.phone_number}</Grid>
              <Grid item xs={6}><strong>Email:</strong> {formData.email || 'Not provided'}</Grid>
              <Grid item xs={12}><strong>Address:</ const response = awaitstrong> {formData.address}</Grid>
              <Grid item xs={12}><strong>State:</strong> {formData.state_code} - {getStateName(formData.state_code)}</Grid>
              <Grid item xs={12}><strong>Biometric:</strong> {formData.biometric_data ? 'Provided' : 'Not provided'}</Grid>
            </Grid>
          </Box>
        );

      default:
        return 'Unknown step';
    }
  };

  const getStateName = (code) => {
    const states = {
      '01': 'Khartoum',
      '02': 'Port Sudan',
      '03': 'North Kordofan',
      '04': 'South Kordofan',
      '05': 'West Kordofan',
      '06': 'North Darfur',
      '07': 'South Darfur',
      '08': 'East Darfur',
      '09': 'West Darfur',
      '10': 'Central Darfur',
      '11': 'White Nile',
      '12': 'Blue Nile',
      '13': 'River Nile',
      '14': '      '15 <Alert severity="error" sx={{ mb: 2 }}>
            {error}
          </Alert>
        )}

        {success && (
          <Alert severity="success" sx={{ mb: 2 }}>
            {success}
          </Alert>
        )}

        <Box sx={{ mb: 4 }}>
          {getStepContent(activeStep)}
        </Box>

        <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
          <Button
            disabled={activeStep === 0}
            onClick={handleBack}
            variant="outlined"
          >
            Back
          </Button>

          <Box>
            {activeStep === steps.length - 1 ? (
              <Button
                onClick={handleSubmit}
                disabled={loading}
                variant="contained"
                color="primary"
                startIcon={loading && <CircularProgress size={20} />}
              >
                {loading ? 'Registering...' : 'Submit Registration'}
              </Button>
            ) : (
              <Button
                onClick={handleNext}
                variant="contained"
                color="primary"
              >
                Next
              </Button>
            )}
          </Box>
        </Box>
      </Paper>
    </Container>
  );
};

export default CitizenRegistration;
 
2.7 Mobile App (React Native)
 
File: frontend/mobile-app/src/screens/CitizenRegistrationScreen.js
javascript
javascript
import React, { useState } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  ScrollView,
  Alert,
  StyleSheet,
  ActivityIndicator
} from 'react-native';
import { Picker } from '@react-native-picker/picker';
import DateTimePicker from '@react-native-community/datetimepicker';
import axios from 'axios';

const API_GATEWAY = process.env.REACT_APP_API_GATEWAY || 'http://localhost:3000';

const CitizenRegistrationScreen = () => {
  const [loading, setLoading] = useState(false);
  const [step, setStep] = useState(1);
  const [formData, setFormData] = useState({
    national_id: '',
    first_name: '',
    middle_name: '',
    last_name: '',
    date_of_birth: new Date(),
    showDatePicker: false,
    gender: '',
    phone_number: '',
    email: '',
    address: '',
    state_code: '01',
    biometric_data: ''
  });

  const handleChange = (field, value) => {
    setFormData(prev => ({ ...prev, [field]: value }));
  };

  const validateStep = (stepNum) => {
    switch (stepNum) {
      case 1:
        return formData.national_id && formData.first_name && formData.last_name && formData.gender;
      case 2:
        return formData.phone_number;
      case 3:
        return formData.address;
      default:
        return true;
    }
  };

  const handleNext = () => {
    if (validateStep(step)) {
      setStep(prev => prev + 1);
    } else {
      Alert.alert('Validation Error', 'Please fill in all required fields');
    }
  };

  const handleBack = () => {
    if (step > 1) setStep(prev => prev - 1);
  };

  const handleSubmit = async () => {
    setLoading(true);

    try {
      const token = process.env.REACT_APP_API_TOKEN || 'your-token-here';

      axios.post(
 formData.address,
          state_code: formData.state_code,
          biometric_data: formData.biometric_data
        },
        {
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        }
      );

      if (response.data.success) {
        Alert.alert(
          'Success',
          `Citizen registered successfully!\nOID: ${response.data.oid}\n\nPlease save this OID.`,
          [
            {
              text: 'OK',
              onPress: () => {
                // Reset form
                setFormData({
                  national_id: '',
                  first_name: '',
                  middle_name: '',
                  last_name: '',
                  date_of_birth: new Date(),
                  showDatePicker: false,
                  gender: '',
                  phone_number: '',
                  email: '',
                  address: '',
                  state_code: '01',
                  biometric_data: ''
                });
                setStep(1);
              }
            }
          ]
        );
      } else {
        Alert.alert('Error', response.data.error || 'Registration failed');
      }
    } catch (error) {
      console.error('Registration error:', error);
      Alert.alert('Error', error.response?.data?.error || 'An error occurred. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const renderStep = () => {
    switch (step) {
      case 1:
        return (
          <View style={styles.stepContainer}>
            <Text style={styles.stepTitle}>Personal Information</Text>

            <TextInput
              style={styles.input}
              placeholder="National ID (10 digits)"
              value={formData.national_id}
              onChangeText={(text) => handleChange('national_id', text)}
              keyboardType="numeric"
              maxLength={10}
            />

            <TextInput
              style={styles.input}
              placeholder="First Name"
              value={formData.first_name}
              onChangeText={(text) => handleChange('first_name', text)}
            />

            <TextInput
              style={styles.input}
              placeholder="Middle Name"
              value={formData.middle_name}
              onChangeText={(text) => handleChange('middle_name', text)}
            />

            <TextInput
              style={styles.input}
              placeholder="Last Name"
              value={formData.last_name}
              onChangeText={(text) => handleChange('last_name', text)}
            />

            < style={styles.reviewTouchableOpacity
              style={styles.dateButton}
              onPress={() => handleChange('showDatePicker', true)}
            >
              <Text style={styles.dateButtonText}>
                {formData.date_of_birth.toLocaleDateString()}
              </Text>
            </TouchableOpacity>

            {formData.showDatePicker && (
              <DateTimePicker
                value={formData.date_of_birth}
                mode="date"
                display="default"
                onChange={(event, selectedDate) => {
                  handleChange('showDatePicker', false);
                  if (selectedDate) {
                    handleChange('date_of_birth', selectedDate);
                  }
                }}
              />
            )}

            <View style={styles.pickerContainer}>
              <Text style={styles.label}>Gender</Text>
              <Picker
                selectedValue={formData.gender}
                onValueChange={(value) => handleChange('gender', value)}
                style={styles.picker}
              >
                <Picker.Item label="Select Gender" value="" />
                <Picker.Item label="Male" value="M" />
                <Picker.Item label="Female" value="F" />
                <Picker.Item label="Other" value="O" />
              </Picker>
            </View>
          </View>
        );

      case 2:
        return (
          <View style={styles.stepContainer}>
            <Text style={styles.stepTitle}>Contact Details</Text>

            <TextInput
              style={styles.input}
              placeholder="Phone Number"
              value={formData.phone_number}
              onChangeText={(text) => handleChange('phone_number', text)}
              keyboardType="phone-pad"
            />

            <TextInput
              style={styles.input}
              placeholder="Email (Optional)"
              value={formData.email}
              onChangeText={(text) => handleChange('email', text)}
              keyboardType="email-address"
            />
          </View>
        );

      case 3:
        return (
          <View style={styles.stepContainer}>
            <Text style={styles.stepTitle}>Address & State</Text>

            <TextInput
              style={[styles.input, styles.textArea]}
              placeholder="Address"
              value={formData.address}
              onChangeText={(text) => handleChange('address', text)}
              multiline
              numberOfLines={3}
            />

            <View style={styles.pickerContainer}>
              <Text style={styles.label}>State</Text>
              <Picker
                selectedValue={formData.state_code}
                onValueChange={(value) => handleChange('state_code', value)}
                style={styles.picker}
              >
                <Picker.Item label="Khartoum" value="01" />
                <Picker.Item label="Port Sudan" value="02" />
                <Picker.Item label="North Kordofan" value="03" />
                <Picker.Item label="South Kordofan" value="04" />
                <Picker.Item label="West Kordofan" value="05" />
                <Picker.Item label="North Darfur" value="06" />
                <Picker.Item label="South Darfur" value="07" />
                <Picker.Item label="East Darfur" value="08" />
                <Picker.Item label="West Darfur" value="09" />
                <Picker.Item label="Central Darfur" value="10" />
                <Picker.Item label="White Nile" value="11" />
                <Picker.Item label="Blue Nile" value="12" />
                <Picker.Item label="River Nile" value="13" />
                <Picker.Item label="Kassala" value="14" />
                <Picker.Item label="Red Sea" value            onPress="15" />
                <Picker.Item label="Gezira" value="16" />
                <Picker.Item label="Sennar" value="17" />
                <Picker.Item label="Al Qadarif" value="18" />
              </Picker>
            </View>
          </View>
        );

      case 4:
        return (
          <View style={styles.stepContainer}>
            <Text style={styles.stepTitle}>Biometric (Optional)</Text>

            <TextInput
              style={[styles.input, styles.textArea]}
              placeholder="Biometric Data (Fingerprint Hash)"
              value={formData.biometric_data}
              onChangeText={(text) => handleChange('biometric_data', text)}
              multiline
              numberOfLines={2}
            />

            <Text style={styles.helpText}>
              Optional: For enhanced verification, you can provide biometric data.
              This helps prevent identity fraud and is stored securely.
            </Text>
          </View>
        );

      case 5:
        return (
          <View style={styles.stepContainer}>
            <Text style={styles.stepTitle}>Review Information</Text>

            <View style={styles.reviewItem}>
              <TextLabel}>National ID </View>

            <View style={styles.reviewItem}>
              <Text style={styles.reviewLabel}>Name:</Text>
              <Text style={styles.reviewValue}>
                {formData.first_name} {formData.middle_name} {formData.last_name}
              </Text>
            </View>

            <View style={styles.reviewItem}>
              <Text style={styles.reviewLabel}>Date of Birth:</Text>
              <Text style={styles.reviewValue}>
                {formData.date_of_birth.toLocaleDateString()}
              </Text>
            </View>

            <View style={styles.reviewItem}>
              <Text style={styles.reviewLabel}>Gender:</Text>
              <Text style={styles.reviewValue}>
                {formData.gender === 'M' ? 'Male' : formData.gender === 'F' ? 'Female' : 'Other'}
              </Text>
            </View>

            <View style={styles.reviewItem}>
              <Text style={styles.reviewLabel}>Phone:</Text>
              <Text style={styles.reviewValue}>{formData.phone_number}</Text>
            </View>

            <View style={styles.reviewItem}>
              <Text style={styles.reviewLabel}>Address:</Text>
              <Text style={styles.reviewValue}>{formData.address}</Text>
            </View>

            <View style={styles.reviewItem}>
              <Text style={styles.reviewLabel}>State:</Text>
              <Text style={styles.reviewValue}>
                {formData.state_code} - {getStateName(formData.state_code)}
              </Text>
            </View>
          </View>
        );

      default:
        return null;
    }
  };

  const getStateName = (code) => {
    const states = {
      '01': 'Khartoum',
      '02': 'Port Sudan',
      '03': 'North Kordofan',
      '04': 'South Kordofan',
      '05': 'West Kordofan',
      '06': 'North Darfur',
      '07': 'South Darfur',
      '08': 'East Darfur',
      '09': 'West Darfur',
      '10': 'Central Darfur',
      '11': 'White Nile',
      '12': 'Blue Nile',
      '13': 'River Nile',
      '14': 'Kassala',
      '15': 'Red Sea',
      '16': 'Gezira',
      '17': 'Sennar',
      '18': 'Al Qadarif'
    };
    return states[code] || 'Unknown';
  };

  return (
    <View style={styles.container}>
      <ScrollView contentContainerStyle={styles.scrollView}>
        <Text style={styles.header}>SGDUS - Citizen Registration</Text>
        <Text style={styles.stepIndicator}>Step {step} of 5</Text>

        {renderStep()}

        {loading && (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color="#007bff" />
            <Text style={styles.loadingText}>Processing...</Text>
          </View>
        )}

        <View style={styles.buttonContainer}>
          <TouchableOpacity
            style={[styles.button, styles.backButton, step === 1 && styles.disabledButton]}
            onPress={handleBack}
            disabled={step === 1 || loading}
          >
            <Text style={styles.buttonText}>Back</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={[styles.button, styles.nextButton]}
={step === Color: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 2,
  },
  stepTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 15,
    color: '#333',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 6,
    padding: 12,
    marginBottom: 12,
    fontSize: 16,
    backgroundColor: '#fff',
  },
  textArea: {
    height: 80,
    textAlignVertical: 'top',
  },
  pickerContainer: {
    marginBottom: 12,
  },
  label: {
    fontSize: 16,
    marginBottom: 8,
    color: '#333',
  },
  picker: {
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 6,
  },
  dateButton: {
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 6,
    padding: 12,
    marginBottom: 12,
    alignItems: 'center',
  },
  dateButtonText: {
    fontSize: 16,
    color: '#333',
  },
  helpText: {
    fontSize: 14,
    color: '#666',
    marginTop: 8,
    fontStyle: 'italic',
  },
  reviewItem: {
    flexDirection: 'row',
    marginBottom: 8,
    flexWrap: 'wrap',
  },
  reviewLabel: {
    fontWeight: 'bold',
    width: '40%',
    color: '#333',
  },
  reviewValue: {
    width: '60%',
    color: '#555',
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 20,
  },
  button: {
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 6,
    minWidth: 120,
    alignItems: 'center',
  },
  backButton: {
    backgroundColor: '#6c757d',
  },
  nextButton: {
    backgroundColor: '#007bff',
  },
  disabledButton: {
    backgroundColor: '#ccc',
  },
  buttonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  loadingContainer: {
    alignItems: 'center',
    marginVertical: 20,
  },
  loadingText: {
    marginTop: 10,
    fontSize: 16,
    color: '#666',
  },
});

export default CitizenRegistrationScreen;
 
2.8 Database Schema (PostgreSQL)
 
File: infrastructure/database/schema.sql
sql
sql
-- Enable extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pg_trgm"; -- For fuzzy search

-- OID Counters Table
CREATE TABLE oid_counters (
    type INTEGER NOT NULL,
    state_code VARCHAR(2) NOT NULL,
    counter INTEGER NOT NULL DEFAULT 1,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (type, state_code)
);

-- OID Registry Table
CREATE TABLE oid_registry (
    oid VARCHAR(255) PRIMARY KEY,
    type INTEGER NOT NULL,
    state_code VARCHAR(2) NOT NULL,
    entity_id VARCHAR(100) NOT NULL,
    metadata JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(20) DEFAULT 'active',

    -- Indexes for performance
    INDEX idx_oid_type (type),
    INDEX idx_oid_state (state_code),
    INDEX idx_oid_status (status),
    INDEX idx_oid_entity (entity_id),
    INDEX idx_oid_created (created_at)
);

-- Citizens Table (Sudanese Context)
CREATE TABLE citizens (
    id SERIAL PRIMARY KEY,
    oid VARCHAR(255) UNIQUE NOT NULL REFERENCES oid_registry(oid),
    national_id VARCHAR(50) UNIQUE NOT NULL,
    first_name VARCHAR(100) NOT NULL,
    middle_name VARCHAR(100),
    last_name VARCHAR(100) NOT NULL,
    date_of_birth DATE NOT NULL,
    gender VARCHAR(10) NOT NULL,
    phone_number VARCHAR(20),
    email VARCHAR(100),
    address TEXT NOT NULL,
    biometric_hash VARCHAR(255),
    state_code VARCHAR(2) NOT NULL,
    created_by VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(20) DEFAULT 'active',

    -- Indexes
    INDEX idx_citizens_national_id (national_id),
    INDEX idx_citizens_oid (oid),
    INDEX idx_citizens_state (state_code),
    INDEX idx_citizens_status (status),
    INDEX idx_citizens_created (created_at),
    INDEX idx_citizens_name (first_name, last_name),
    INDEX idx_citizens_phone (phone_number),
    INDEX idx_citizens_email (email)
);

-- Businesses Table (Sudanese Context)
CREATE TABLE businesses (
    id SERIAL PRIMARY KEY,
    oid VARCHAR(255) UNIQUE NOT NULL REFERENCES oid_registry(oid),
    registration_number VARCHAR(50) UNIQUE NOT NULL,
    business_name VARCHAR(200) NOT NULL,
    business_type VARCHAR(50) NOT NULL,
    owner_oid VARCHAR(255) NOT NULL REFERENCES citizens(oid),
    tax_id VARCHAR(50),
    address TEXT NOT NULL,
    phone_number VARCHAR(20),
    email VARCHAR(100),
    state_code VARCHAR(2) NOT NULL,
    created_by VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(20) DEFAULT 'active',

    -- Indexes
    INDEX idx_businesses_registration (registration_number),
    INDEX idx_businesses_oid (oid),
    INDEX idx_businesses_owner (owner_oid),
    INDEX idx_businesses_state (state_code),
    INDEX idx_businesses_status (status),
    INDEX idx_businesses_created (created_at),
    INDEX idx_businesses_name (business_name)
);

-- Family Relationships Table
CREATE TABLE family_relationships (
    id SERIAL PRIMARY KEY,
    citizen_oid VARCHAR(255) NOT NULL REFERENCES citizens(oid),
    relationship_type VARCHAR(50) NOT NULL, -- 'spouse', 'parent', 'child', 'sibling'
    related_citizen_oid VARCHAR(255) NOT NULL REFERENCES citizens(oid),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- Ensure unique relationships
    UNIQUE(citizen_oid, related_citizen_oid, relationship_type),

    -- Indexes
    INDEX idx_family_citizen (citizen_oid),
    INDEX idx_family_related (related_citizen_oid),
    INDEX idx_family_type (relationship_type)
);

-- Audit Logs Table (for compliance and tracking)
CREATE TABLE audit_logs (
    id SERIAL PRIMARY KEY,
    event VARCHAR(100) NOT NULL,
    user_oid VARCHAR(255),
    entity_oid VARCHAR(255),
    entity_type VARCHAR(50),
    old_value JSONB,
    new_value JSONB,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- Indexes for querying
    INDEX idx_audit_event (event),
    INDEX idx_audit_user (user_oid),
    INDEX idx_audit_entity (entity_oid),
    INDEX idx_audit_created (created_at)
);

-- Agency Integration Logs Table
CREATE TABLE agency_integration_logs (
    id SERIAL PRIMARY KEY,
    agency_name VARCHAR(100) NOT NULL,
    operation VARCHAR(50) NOT NULL,
    entity_oid VARCHAR(255),
    request_data JSONB,
    response_data JSONB,
    status VARCHAR(20) NOT NULL,
    error_message TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- Indexes
    INDEX idx_agency_name (agency_name),
    INDEX idx_agency_operation (operation),
    INDEX idx_agency_status (status),
    INDEX idx_agency_created (created_at)
);

-- USSD Sessions Table (for USSD service)
CREATE TABLE ussd_sessions (
    id SERIAL PRIMARY KEY,
    session_id VARCHAR(100) UNIQUE NOT NULL,
    phone_number VARCHAR(20) NOT NULL,
    state VARCHAR(50) NOT NULL,
    step INTEGER DEFAULT 0,
    data JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ended_at TIMESTAMP,

    -- Indexes
    INDEX idx_ussd_session (session_id),
    INDEX idx_ussd_phone (phone_number),
    INDEX idx_ussd_state (state),
    INDEX idx_ussd_created (created_at)
);

-- Data Quality Rules Table
CREATE TABLE data_quality_rules (
    id SERIAL PRIMARY KEY,
    table_name VARCHAR(50) NOT NULL,
    column_name VARCHAR(50) NOT NULL,
    rule_type VARCHAR(50) NOT NULL, -- 'regex', 'range', 'required', 'unique'
    rule_value JSONB,
    error_message TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- Indexes
    INDEX idx_quality_table (table_name),
    INDEX idx_quality_column (column_name)
);

-- Insert sample data quality rules for Sudanese context
INSERT INTO data_quality_rules (table_name, column_name, rule_type, rule_value, error_message) VALUES
('citizens', 'national_id', 'regex', '{"pattern": "^\\\\d{10}$"}', 'National ID must be 10 digits'),
('citizens', 'phone_number', 'regex', '{"pattern": "^\\\\+249\\\\d{9}$"}', 'Phone must start with +249 and have 9 digits'),
('businesses', 'registration_number', 'regex', '{"pattern": "^SD-[A-Z0-9]{5}$"}', 'Registration must be SD-XXXXX format'),
('citizens', 'date_of_birth', 'range', '{"min": "1900-01-01", "max": "2023-12-31"}', 'Date of birth must be between 1900 and 2023'),
('citizens', 'national_id', 'unique', '{}', 'National ID already exists'),
('businesses', 'registration_number', 'unique', '{}', 'Registration number already exists');

-- Views for reporting
CREATE VIEW citizen_summary AS
SELECT
    state_code,
    COUNT(*) as total_citizens,
    COUNT(CASE WHEN gender = 'M' THEN 1 END) as males,
    COUNT(CASE WHEN gender = 'F' THEN 1 END) as females,
    COUNT(CASE WHEN status = 'active' THEN 1 END) as active_citizens,
    MIN(created_at) as earliest_registration,
    MAX(created_at) as latest_registration
FROM citizens
GROUP BY state_code;

CREATE VIEW business_summary AS
SELECT
    state_code,
    business_type,
    COUNT(*) as total_businesses,
    COUNT(CASE WHEN status = 'active' THEN 1 END) as active_businesses,
    MIN(created_at) as earliest_registration,
    MAX(created_at) as latest_registration
FROM businesses
GROUP BY state_code, business_type;

-- Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$$$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_oid_registry_updated_at BEFORE UPDATE ON oid_registry
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_citizens_updated_at BEFORE UPDATE ON citizens
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_businesses_updated_at BEFORE UPDATE ON businesses
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ussd_sessions_updated_at BEFORE UPDATE ON ussd_sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to generate unique OID (alternative to microservice)
CREATE OR REPLACE FUNCTION generate_oid(type INTEGER, state_code VARCHAR(2), entity_id VARCHAR(100))
RETURNS VARCHAR AS $$
DECLARE
    current_counter INTEGER;
    new_oid VARCHAR(255);
BEGIN
    -- Get current counter
    SELECT counter INTO current_counter
    FROM oid_counters
    WHERE type = generate_oid.type AND state_code = generate_oid.state_code;

    IF current_counter IS NULL THEN
        current_counter := 1;
        INSERT INTO oid_counters (type, state_code, counter)
        VALUES (type, state_code, current_counter);
    ELSE
        current_counter := current_counter + 1;
        UPDATE oid_counters
        SET counter = current_counter,
            updated_at = CURRENT_TIMESTAMP
        WHERE type = generate_oid.type AND state_code = generate_oid.state_code;
    END IF;

    -- Generate OID: 1.3.6.1.4.1.61026.[type].[state_code].[counter]
    new_oid := '1.3.6.1.4.1.61026.' || type || '.' || state_code || '.' || LPAD(current_counter::TEXT, 8, '0');

    -- Insert into registry
    INSERT INTO oid_registry (oid, type, state_code, entity_id)
    VALUES (new_oid, type, state_code, entity_id);

    RETURN new_oid;
END;
$$ LANGUAGE plpgsql;

-- Function to check data quality
CREATE OR REPLACE FUNCTION check_data_quality(table_name TEXT, column_name TEXT, value TEXT)
RETURNS BOOLEAN AS $$
DECLARE
    rule RECORD;
    is_valid BOOLEAN := TRUE;
BEGIN
    FOR rule IN
        SELECT * FROM data_quality_rules
        WHERE data_quality_rules.table_name = check_data_quality.table_name
        AND data_quality_rules.column_name = check_data_quality.column_name
    LOOP
        CASE rule.rule_type
            WHEN 'regex' THEN
                IF NOT (value ~ (rule.rule_value->>'pattern')) THEN
                    is_valid := FALSE;
                END IF;
            WHEN 'range' THEN
                IF rule.rule_value->>'min' IS NOT NULL AND value < (rule.rule_value->>'min') THEN
                    is_valid := FALSE;
                END IF;
                IF rule.rule_value->>'max' IS NOT NULL AND value > (rule.rule_value->>'max') THEN
                    is_valid := FALSE;
                END IF;
            ELSE
                -- Other rule types would need implementation
                NULL;
        END CASE;
    END LOOP;

    RETURN is_valid;
END;
$$ LANGUAGE plpgsql;

-- Grant permissions (adjust based on your security requirements)
-- GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO sgdus_app;
-- GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO sgdus_app;
 
2.9 Docker Compose for Local Development
 
File: inf sgdus-networkrastructure/docker/docker-compose.yml
yaml
yaml
version: '3.8'

services:
  # PostgreSQL Database
  postgres:
    image: postgres:14-alpine
    environment:
      POSTGRES_USER: sgdus
      POSTGRES_PASSWORD: ${DB_PASSWORD:-sgdus123}
      POSTGRES_DB: sgdus
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - sgdus-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U sgdus"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis for caching and sessions
  redis:
    image: redis:7-alpine
    command: redis-server --requirepass ${REDIS_PASSWORD:-redis123}
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - sgdus-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # MongoDB for audit logs
  mongodb:
    image: mongo:5
    environment:
      MONGO_INITDB_ROOT_USERNAME: ${MONGO_USER:-root}
      MONGO_INITDB_ROOT_PASSWORD: ${MONGO_PASSWORD:-mongo123}
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
    networks:
      - sgdus-network

  # API Gateway (Kong)
  kong:
    image: kong:3.2-alpine
    environment:
      KONG_DATABASE: postgres
      KONG_PG_HOST: postgres
      KONG_PG_USER: sgdus
      KONG_PG_PASSWORD: ${DB_PASSWORD:-sgdus123}
      KONG_CASSANDRA_CONTACT_POINTS: postgres
      KONG_PROXY_ACCESS_LOG: /dev/stdout
      KONG_ADMIN_ACCESS_LOG: /dev/stdout
      KONG_PROXY_ERROR_LOG: /dev/stderr
      KONG_ADMIN_ERROR_LOG: /dev/stderr
      KONG_ADMIN_LISTEN: 0.0.0.0:8001
    ports:
      - "8000:8000"
      - "8001:8001"
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - sgdus-network
    volumes:
      - ./kong.yml:/usr/local/kong/declarative/kong.yml

  # OID Service
  oid-service:
    build:
      context: ../../backend/oid-service
      dockerfile: Dockerfile
    ports:
      - "3002:3002"
    environment:
      DB_HOST: postgres
      DB_USER: sgdus
      DB_PASSWORD: ${DB_PASSWORD:-sgdus123}
      DB_NAME: sgdus
      DB_PORT: 5432
      REDIS_HOST: redis
      REDIS_PORT: 6379
      REDIS_PASSWORD: ${REDIS_PASSWORD:-redis123}
      PORT: 3002
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - sgdus-network

  # Identity Service
  identity-service:
    build:
      context: ../../backend/identity-service
      dockerfile: Dockerfile
    ports:
      - "3001:3001"
    environment:
      DB_HOST: postgres
      DB_USER: sgdus
      DB_PASSWORD: ${DB_PASSWORD:-sgdus123}
      DB_NAME: sgdus
      DB_PORT: 5432
      OID_SERVICE_URL: http://oid-service:3002
      AUDIT_SERVICE_URL: http://audit-service:3006
      JWT_SECRET: ${JWT_SECRET:-your-jwt-secret-key}
      PORT: 3001
    depends_on:
      postgres:
        condition: service_healthy
      oid-service:
        condition: service_started
    networks:
      -

  # Agency - "3005:3005"
    environment:
      DB_HOST: postgres
      DB_USER: sgdus
      DB_PASSWORD: ${DB_PASSWORD:-sgdus123}
      DB_NAME: sgdus
      DB_PORT: 5432
      CIVIL_REGISTRY_ENDPOINT: ${CIVIL_REGISTRY_ENDPOINT:-http://civil-registry:8080/api}
      BUSINESS_REG_ENDPOINT: ${BUSINESS_REG_ENDPOINT:-http://business-reg:8080/api}
      TAX_AUTHORITY_ENDPOINT: ${TAX_AUTHORITY_ENDPOINT:-http://tax-authority:8080/api}
      CUSTOMS_ENDPOINT: ${CUSTOMS_ENDPOINT:-http://customs:8080/api}
      LAND_REGISTRY_ENDPOINT: ${LAND_REGISTRY_ENDPOINT:-http://land-registry:8080/api}
      PORT: 3005
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - sgdus-network

  # Audit Service
  audit-service:
    build:
      context: ../../backend/audit-service
      dockerfile: Dockerfile
    ports:
      - "3006:3006"
    environment:
      MONGO_URL: mongodb://${MONGO_USER:-root}:${MONGO_PASSWORD:-mongo123}@mongodb:27017
      MONGO_DB: sgdus_audit
      PORT: 3006
    depends_on:
      mongodb:
        condition: service_started
    networks:
      - sgdus-network

  # USSD Service
  ussd-service:
    build:
      context: ../../backend/ussd-service
      dockerfile: Dockerfile
    ports:
      - "3007:3007"
    environment:
      DB_HOST: postgres
      DB_USER: sgdus
      DB_PASSWORD: ${DB_PASSWORD:-sgdus123}
      DB_NAME: sgdus
      DB_PORT: 5432
      IDENTITY_SERVICE_URL: http://identity-service:3001
      API_TOKEN: ${API_TOKEN:-api-token-123}
      PORT: 3007
    depends_on:
      postgres:
        condition: service_healthy
      identity-service:
        condition: service_started
    networks:
      - sgdus-network

  # Web Portal
  web-portal:
    build:
      context: ../../frontend/web-portal
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      REACT_APP_API_GATEWAY: http://kong:8000
      REACT_APP_API_TOKEN: ${API_TOKEN:-api-token-123}
    depends_on:
      kong:
        condition: service_started
    networks:
      - sgdus-network

  # Admin Dashboard
  admin-dashboard:
    build:
      context: ../../frontend/admin-dashboard
      dockerfile: Dockerfile
    ports:
      - "3008:3000"
    environment:
      REACT_APP_API_GATEWAY: http://kong:8000
      REACT_APP_API_TOKEN: ${API_TOKEN:-api-token-123}
    depends_on:
      kong:
        condition: service_started
    networks:
      - sgdus-network

  # Monitoring (Prometheus + Grafana)
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--storage.tsdb.retention.time=200h'
      - '--web.enable-lifecycle'
    networks:
      - sgdus-network

  grafana:
    image: grafana/grafana:latest
    ports:
      - "3003:3000"
    environment:
      GF_SECURITY_ADMIN_PASSWORD: ${GRAFANA_PASSWORD:-admin123}
    volumes:
      - grafana_data:/var/lib/grafana
      - ./grafana/provisioning:/etc/grafana/provisioning
    depends_on:
      - prometheus
    networks:
      - sgdus-network

  # Nginx for SSL termination (optional for production)
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/ssl:/etc/nginx/ssl
    depends_on:
      - kong
    networks:
      - sgdus-network

volumes:
  postgres_data:
  redis_data:
  mongodb_data:
  prometheus_data:
  grafana_data:

networks:
  sgdus-network:
    driver: bridge
 
2.10 Kubernetes Deployment (Production)
 
File: infrastructure/kubernetes/deployment.yaml
yaml
yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: sgdus-oid-service
  namespace: sgdus
  labels:
    app: sgdus
    component: oid-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: sgdus
      component: oid-service
  template:
    metadata:
      labels:
        app: sgdus
        component: oid-service
    spec:
      containers:
      - name: oid-service
        image: sgdus/oid-service:latest
        ports:
        - containerPort: 3002
        env:
        - name: DB_HOST
          valueFrom:
            secretKeyRef:
              name: sgdus-secrets
              key: db-host
        - name: DB_USER
          valueFrom:
            secretKeyRef:
              name: sgdus-secrets
              key: db-user
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: sgdus-secrets
              key: db-password
        - name: DB_NAME
          value: "sgdus"
        - name: REDIS_HOST
          value: "redis-master.sgdus.svc.cluster.local"
        - name: REDIS_PASSWORD
          valueFrom:
            secretKeyRef:
              name: sgdus-secrets
              key: redis-password
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3002
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3002
          initialDelaySeconds: 5
          periodSeconds: 5
        volumeMounts:
        - name: config
          mountPath: /app/config
      volumes:
      - name: config
        configMap:
          name: oid-service-config
---
apiVersion: v1
kind: Service
metadata:
  name: oid-service
  namespace: sgdus
spec:
  selector:
    app: sgdus
    component: oid-service
  ports:
  - port: 3002
    targetPort: 3002
  type: ClusterIP
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: oid-service-hpa
  namespace: sgdus
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: sgdus-oid-service
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
 
2.11 Security Configuration
 
File: backend/shared/security.js
javascript
javascript
const crypto = require('crypto');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const rateLimit = require('express-rate-limit');
const helmet = require('helmet');
const { body } = require('express-validator');

// JWT Configuration
const JWT_CONFIG = {
  secret: process.env.JWT_SECRET || 'your-secret-key-change-in-production',
  expiresIn: process.env.JWT_EXPIRES_IN || '7d',
  algorithm: 'HS256'
};

// Password Configuration
const PASSWORD_CONFIG = {
  saltRounds: 12,
  minLength: 8,
  requireUppercase: true,
  requireLowercase: true,
  requireNumbers: true,
  requireSpecialChars: true
};

// Rate Limiting Configuration
const RATE_LIMIT_CONFIG = {
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  standardHeaders: true,
  legacyHeaders: false,
  message: {
    error: 'Too many requests',
    message: 'Please try again later'
  }
};

// Encryption Configuration
const ENCRYPTION_CONFIG = {
  algorithm: 'aes-256-gcm',
  keyLength: 32,
  ivLength: 16
};

class SecurityService {
  // Generate JWT token
  static generateToken(payload, options = {}) {
    const defaultOptions = {
      expiresIn: JWT_CONFIG.expiresIn,
      algorithm: JWT_CONFIG.algorithm
    };

    return jwt.sign(payload, JWT_CONFIG.secret, { ...defaultOptions, ...options });
  }

  // Verify JWT token
  static verifyToken(token) {
    try {
      return jwt.verify(token, JWT_CONFIG.secret);
    } catch (error) {
      throw new Error('Invalid or expired token');
    }
  }

  // Hash password
  static async hashPassword(password) {
    if (!this.validatePassword(password)) {
      throw new Error('Password does not meet requirements');
    }
    return bcrypt.hash(password, PASSWORD_CONFIG.saltRounds);
  }

  // Compare password
  static async comparePassword(password, hash) {
    return bcrypt.compare(password, hash);
  }

  // Validate password
  static validatePassword(password) {
    if (password.length < PASSWORD_CONFIG.minLength) {
      return false;
    }

    if (PASSWORD_CONFIG.requireUppercase && !/[A-Z]/.test(password)) {
      return false;
    }

    if (PASSWORD_CONFIG.requireLowercase && !/[a-z]/.test(password)) {
      return false;
    }

    if (PASSWORD_CONFIG.requireNumbers && !/\d/.test(password)) {
      return false;
    }

    if (PASSWORD_CONFIG.requireSpecialChars && !/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
      return false;
    }

    return true;
  }

  // Encrypt data
  static encrypt(data, key) {
    const iv = crypto.randomBytes(ENCRYPTION_CONFIG.ivLength);
    const cipher = crypto.createCipheriv(
      ENCRYPTION_CONFIG.algorithm,
      Buffer.from(key, 'hex'),
      iv
    );

    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    const authTag = cipher.getAuthTag();

    return {
      iv: iv.toString('hex'),
      authTag: authTag.toString('hex'),
      encryptedData: encrypted
    };
  }

  // Decrypt data
  static decrypt(encryptedData, iv, authTag, key) {
    const decipher = crypto.createDecipheriv(
      ENCRYPTION_CONFIG.algorithm,
      Buffer.from(key, 'hex'),
      Buffer.from(iv, 'hex')
    );

    decipher.setAuthTag(Buffer.from(authTag, 'hex'));

    let decrypted = decipher.update(encryptedData, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }

  // Generate secure random string
  static generateSecureString(length = 32) {
    return crypto.randomBytes(length).toString('hex');
  }

  // Create rate limiter middleware
  static createRateLimiter(options = {}) {
    return rateLimit({
      ...RATE_LIMIT_CONFIG,
      ...options
    });
  }

  // Security headers middleware
  static securityHeaders() {
    return helmet({
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          styleSrc: ["'self'", "'unsafe-inline'"],
          scriptSrc: ["'self'"],
          imgSrc: ["'self'", "data:", "https:"],
          connectSrc: ["'self'"],
          fontSrc: ["'self'"],
          objectSrc: ["'none'"],
          mediaSrc: ["'self'"],
          frameSrc: ["'none'"]
        }
      },
      hsts: {
        maxAge: 31536000,
        includeSubDomains: true,
        preload: true
      },
      noSniff: true,
      frameguard: { action: 'deny' },
      xssFilter: true,
      referrerPolicy: { policy: 'same-origin' }
    });
  }

  // Input validation for Sudanese data
  static sudaneseValidators() {
    return {
      nationalId: body('national_id').isLength({ min: 10, max: 10 }).withMessage('National ID must be 10 digits'),
      phone: body('phone_number').optional().isMobilePhone('any').withMessage('Invalid phone number'),
      businessReg: body('registration_number').matches(/^SD-[A-Z0-9]{5}$/).withMessage('Business registration must be SD-XXXXX'),
      email: body('email').optional().isEmail().withMessage('Invalid email'),
      dateOfBirth: body('date_of_birth').isISO8601().withMessage('Invalid date format'),
      gender: body('gender').isIn(['M', 'F', 'O']).withMessage('Gender must be M, F, or O')
    };
  }

  // Audit logging
  static async auditLog(event, userOid, data, ip, userAgent) {
    const auditEntry = {
      event,
      user_oid: userOid,
      data,
      ip_address: ip,
      user_agent: userAgent,
      timestamp: new Date().toISOString()
    };

    // Send to audit service
    try {
      const axios = require('axios');
      await axios.post(
        `${process.env.AUDIT_SERVICE_URL}/api/v1/audit`,
        auditEntry
      );
    } catch (error) {
      console.error('Audit log failed:', error);
    }

    return auditEntry;
  }

  // Role-based access control (RBAC)
  static checkPermission(userRole, requiredPermission) {
    const permissions = {
      'citizen': ['read:self', 'update:self'],
      'business': ['read:self', 'update:self', 'register:business'],
      'government_staff': ['read:all', 'write:all', 'approve:all'],
      'admin': ['read:all', 'write:all', 'approve:all', 'delete:all']
    };

    return permissions[userRole]?.includes(requiredPermission) || false;
  }

  // GDPR-like data protection (for Sudanese context)
  static anonymizeData(data, fieldsToAnonymize = ['national_id', 'phone_number', 'email']) {
    const anonymized = { ...data };

    fieldsToAnonymize.forEach(field => {
      if (anonymized[field]) {
        if (field === 'national_id') {
          anonymized[field] = '****' + anonymized[field].slice(-4);
        } else if (field === 'phone_number') {
          anonymized[field] = anonymized[field].replace(/(\d{3})\d{4}(\d{3})/, '****$2');
        } else if (field === 'email') {
          const [local, domain] = anonymized[field].split('@');
          anonymized[field] = `${local[0]}***@${domain}`;
        }
      }
    });

    return anonymized;
  }

  // Data retention policy (Sudanese context - 7 years for legal compliance)
  static checkDataRetention(createdAt, entityType) {
    const retentionPeriods = {
      'citizen': 7 * 365 * 24 * 60 * 60 * 1000, // 7 years
      'business': 10 * 365 * 24 * 60 * 60 * 1000, // 10 years
      'audit': 7 * 365 * 24 * 60 * 60 * 1000 // 7 years
    };

    const retention = retentionPeriods[entityType] || 7 * 365 * 24 * 60 * 60 * 1000;
    const now = new Date().getTime();
    const created = new Date(createdAt).getTime();

    return now - created < retention;
  }
}

module.exports = SecurityService;
 
3. DEPLOYMENT SCRIPTS
 
3.1 Docker Build and Push Script
 
File: scripts/deployment/build-and-push.sh
bash
bash
#!/bin/bash

set -e

# Configuration
REGISTRY="your-registry.com"
VERSION="1.0.0"
SERVICES=("oid-service" "identity-service" "agency-integration" "audit-service" "ussd-service")

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${GREEN}Starting build and push process...${NC}"

# Build and push each service
for service in "${SERVICES[@]}"; do
    echo -e "${YELLOW}Building ${service}...${NC}"

    # Build Docker image
    docker build -t ${REGISTRY}/${service}:${VERSION} -t ${REGISTRY}/${service}:latest -f backend/${service}/Dockerfile backend/${service}/

    if [ $? -eq 0 ]; then
        echo -e "${GREEN}✓ ${service} built successfully${NC}"
    else
        echo -e "${RED}✗ Failed to build ${service}${NC}"
        exit 1
    fi

    # Push to registry
    echo -e "${YELLOW}Pushing ${service} to registry...${NC}"
    docker push ${REGISTRY}/${service}:${VERSION}
    docker push ${REGISTRY}/${service}:latest

    if [ $? -eq 0 ]; then
        echo -e "${GREEN}✓ ${service} pushed successfully${NC}"
    else
        echo -e "${RED}✗ Failed to push ${service}${NC}"
        exit 1
    fi
done

# Build frontend
echo -e "${YELLOW}Building web portal...${NC}"
docker build -t ${REGISTRY}/web-portal:${VERSION} -t ${REGISTRY}/web-portal:latest -f frontend/web-portal/Dockerfile frontend/web-portal/

if [ $? -eq 0 ]; then
    echo -e "${GREEN}✓ Web portal built successfully${NC}"
    docker push ${REGISTRY}/web-portal:${VERSION}
    docker push ${REGISTRY}/web-portal:latest
    echo -e "${GREEN}✓ Web portal pushed successfully${NC}"
else
    echo -e "${RED}✗ Failed to build web portal${NC}"
    exit 1
fi

echo -e "${GREEN}All services built and pushed successfully!${NC}"
 
3.2 Database Migration Script
 
File: scripts/deployment/migrate.sh
bash
bash
#!/bin/bash

set -e

# Configuration
DB_HOST=${DB_HOST:-localhost}
DB_PORT=${DB_PORT:-5432}
DB_NAME=${DB_NAME:-sgdus}
DB_USER=${DB_USER:-sgdus}
DB_PASSWORD=${DB_PASSWORD:-sgdus123}

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m'

echo -e "${YELLOW}Starting database migration...${NC}"

# Export password for psql
export PGPASSWORD=$DB_PASSWORD

# Check if database exists
if ! psql -h $DB_HOST -p $DB_PORT -U $DB_USER -lqt | cut -d \| -f 1 | grep -qw $DB_NAME; then
    echo -e "${YELLOW}Creating database ${DB_NAME}...${NC}"
    createdb -h $DB_HOST -p $DB_PORT -U $DB_USER $DB_NAME
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}✓ Database created${NC}"
    else
        echo -e "${RED}✗ Failed to create database${NC}"
        exit 1
    fi
fi

# Run schema migration
echo -e "${YELLOW}Running schema migration...${NC}"
psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME -f infrastructure/database/schema.sql

if [ $? -eq 0 ]; then
    echo -e "${GREEN}✓ Schema migration completed${NC}"
else
    echo -e "${RED}✗ Schema migration failed${NC}"
    exit 1
fi

# Run data migration (if any)
if [ -f "infrastructure/database/migrations/$(date +%Y%m%d).sql" ]; then
    echo -e "${YELLOW}Running data migration...${NC}"
    psql -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME -f "infrastructure/database/migrations/$(date +%Y%m%d).sql"

    if [ $? -eq 0 ]; then
        echo -e "${GREEN}✓ Data migration completed${NC}"
    else
        echo -e "${RED}✗ Data migration failed${NC}"
        exit 1
    fi
fi

echo -e "${GREEN}Database migration completed successfully!${NC}"
 
3.3 Environment Configuration
 
File: infrastructure/docker/.env.example
env
env
# Database Configuration
DB_HOST=postgres
DB_PORT=5432
DB_NAME=sgdus
DB_USER=sgdus
DB_PASSWORD=sgdus123

# Redis Configuration
REDIS_HOST=redis
REDIS_PORT=6379
REDIS_PASSWORD=redis123

# MongoDB Configuration
MONGO_USER=root
MONGO_PASSWORD=mongo123

# JWT Configuration
JWT_SECRET=your-super-secret-jwt-key-change-this-in-production
JWT_EXPIRES_IN=7d

# API Token for internal services
API_TOKEN=your-internal-api-token-123

# OID Service Configuration
OID_SERVICE_URL=http://oid-service:3002

# Identity Service Configuration
IDENTITY_SERVICE_URL=http://identity-service:3001

# Audit Service Configuration
AUDIT_SERVICE_URL=http://audit-service:3006

# Agency Endpoints (for integration)
CIVIL_REGISTRY_ENDPOINT=http://civil-registry:8080/api
BUSINESS_REG_ENDPOINT=http://business-reg:8080/api
TAX_AUTHORITY_ENDPOINT=http://tax-authority:8080/api
CUSTOMS_ENDPOINT=http://customs:8080/api
LAND_REGISTRY_ENDPOINT=http://land-registry:8080/api

# Agency Credentials (for simulation)
CIVIL_REGISTRY_USERNAME=civil_user
CIVIL_REGISTRY_PASSWORD=civil_pass
BUSINESS_REG_TOKEN=business_token_123
TAX_CLIENT_ID=tax_client_id
TAX_CLIENT_SECRET=tax_client_secret
CUSTOMS_USERNAME=customs_user
CUSTOMS_PASSWORD=customs_pass

# Frontend Configuration
REACT_APP_API_GATEWAY=http://kong:8000
REACT_APP_API_TOKEN=your-frontend-api-token-123

# Monitoring
GRAFANA_PASSWORD=admin123

# Security
CORS_ORIGIN=http://localhost:3000,http://localhost:3008
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100
 
4. MONITORING AND LOGGING
 
4.1 Prometheus Configuration
 
File: infrastructure/monitoring/prometheus.yml
yaml
yaml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "alerts.yml"

scrape_configs:
  - job_name: 'sgdus-services'
    static_configs:
      - targets: ['oid-service:3002']
        labels:
          service: 'oid-service'
      - targets: ['identity-service:3001']
        labels:
          service: 'identity-service'
      - targets: ['agency-integration:3005']
        labels:
          service: 'agency-integration'
      - targets: ['audit-service:3006']
        labels:
          service: 'audit-service'
      - targets: ['ussd-service:3007']
        labels:
          service: 'ussd-service'
      - targets: ['kong:8001']
        labels:
          service: 'kong'
    metrics_path: /metrics
    scrape_interval: 10s

  - job_name: 'postgres'
    static_configs:
      - targets: ['postgres-exporter:9187']
    scrape_interval: 10s

  - job_name: 'redis'
    static_configs:
      - targets: ['redis-exporter:9121']
    scrape_interval: 10s

  - job_name: 'node-exporter'
    static_configs:
      - targets: ['node-exporter:9100']
    scrape_interval: 10s
 
4.2 Grafana Dashboard Configuration
 
File: infrastructure/monitoring/grafana/dashboard.json
json
json
{
  "dashboard": {
    "title": "SGDUS System Dashboard",
    "panels": [
      {
        "title": "Service Health",
        "type": "stat",
        "targets": [{
          "expr": "up{job=\"sgdus-services\"}",
          "legendFormat": "{{service}}"
        }],
        "thresholds": {
          "steps": [
            {"color": "red", "value": 0},
            {"color": "green", "value": 1}
          ]
        }
      },
      {
        "title": "Request Rate",
        "type": "graph",
        "targets": [{
          "expr": "rate(http_requests_total[5m])",
          "legendFormat": "{{service}}"
        }]
      },
      {
        "title": "Response Time",
        "type": "graph",
        "targets": [{
          "expr": "histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))",
          "legendFormat": "{{service}}"
        }]
      },
      {
        "title": "Database Connections",
        "type": "stat",
        "targets": [{
          "expr": "pg_stat_database_numbackends{datname=\"sgdus\"}"
        }]
      },
      {
        "title": "OID Generation Rate",
        "type": "graph",
        "targets": [{
          "expr": "rate(oid_generated_total[5m])",
          "legendFormat": "OID Generation"
        }]
      },
      {
        "title": "Citizen Registrations",
        "type": "graph",
        "targets": [{
          "expr": "rate(citizen_registered_total[5m])",
          "legendFormat": "Citizen Registration"
        }]
      }
    ],
    "refresh": "30s",
    "time": {
      "from": "now-1h",
      "to": "now"
    }
  }
}
 
5. SECURITY HARDENING
 
5.1 Nginx Configuration for SSL/TLS
 
File: infrastructure/nginx/nginx.conf
nginx
nginx
events {
    worker_connections 1024;
}

http {
    upstream kong {
        server kong:8000;
    }

    server {
        listen 80;
        server_name localhost;

        # Redirect to HTTPS
        return 301 https://$server_name$request_uri;
    }

    server {
        listen 443 ssl http2;
        server_name localhost;

        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;

        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
        ssl_prefer_server_ciphers off;
        ssl_session_cache shared:SSL:10m;
        ssl_session_timeout 10m;

        # Security headers
        add_header X-Frame-Options "DENY" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;
        add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';" always;

        # Rate limiting
        limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;

        location / {
            limit_req zone=api burst=20 nodelay;
            proxy_pass http://kong;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # Timeouts
            proxy_connect_timeout 60s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;
        }

        # Health check endpoint
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }
    }
}
 
6. IMPLEMENTATION STEPS
 
Step 1: Environment Setup
bash
bash
# Clone the repository
git clone https://github.com/your-org/sgdus-system.git
cd sgdus-system

# Copy environment file
cp infrastructure/docker/.env.example infrastructure/docker/.env

# Edit environment variables
nano infrastructure/docker/.env

# Make scripts executable
chmod +x scripts/deployment/*.sh
 
Step 2: Database Setup
bash
bash
# Run database migration
./scripts/deployment/migrate.sh

# Or manually with Docker Compose
docker-compose -f infrastructure/docker/docker-compose.yml up -d postgres
 
Step 3: Build and Deploy
bash
bash
# Build all services
./scripts/deployment/build-and-push.sh

# Deploy with Docker Compose
docker-compose -f infrastructure/docker/docker-compose.yml up -d

# Or deploy to Kubernetes
kubectl apply -f infrastructure/kubernetes/
 
Step 4: Initialize System
bash
bash
# Initialize OID counters
curl -X POST http://localhost:3002/api/v1/oid/initialize \
  -H "Content-Type: application/json" \
  -d '{"types": [1,2,3,4,5,6], "states": ["01","02","03","04","05","06","07","08","09","10","11","12","13","14","15","16","17","18"]}'

# Create admin user
curl -X POST http://localhost:3001/api/v1/auth/admin/setup \
  -H "Content-Type: application/json" \
  -d '{"username": "admin", "password": "Admin@123", "email": "admin@sgdus.gov.sd"}'
 
Step 5: Test the System
bash
bash
# Test OID generation
curl -X POST http://localhost:3002/api/v1/oid/generate \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer your-token" \
  -d '{"type": "2", "stateCode": "01", "entityId": "1234567890"}'

# Test citizen registration
curl -X POST http://localhost:3001/api/v1/identity/citizen/register \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer your-token" \
  -d '{
    "national_id": "1234567890",
    "first_name": "Ahmed",
    "last_name": "Mohamed",
    "date_of_birth": "1990-01-01",
    "gender": "M",
    "phone_number": "+249123456789",
    "address": "Khartoum, Sudan",
    "state_code": "01"
  }'

# Test USSD flow
curl -X POST http://localhost:3007/api/v1/ussd \
  -H "Content-Type: application/json" \
  -d '{
    "sessionId": "session123",
    "phoneNumber": "+249123456789",
    "text": "1*1234567890*Ahmed*Mohamed*1990-01-01*M"
  }'
 
7. SECURITY CONSIDERATIONS FOR SUDANESE CONTEXT
 
Data Protection
Encryption: All PII encrypted at rest and in transit
Access Control: Role-based access (citizen, business, government staff, admin)
Audit Trail: Complete logging of all access and changes
Data Retention: 7 years for legal compliance (aligned with Sudanese law)
 
Cultural Adaptations
Arabic Interface: All interfaces in Arabic with RTL support
Offline Capability: USSD/SMS for low-connectivity areas
Gender Considerations: Separate registration areas for women where culturally appropriate
Tribal Integration: Support for tribal affiliations in data model
 
Legal Compliance
Sudanese Laws: Compliance with Electronic Transactions Act 2007, Civil Registry Act 1994
Data Sovereignty: Sensitive data stored on-premise in Sudan
International Standards: GDPR-like principles for data protection
Audit Requirements: Complete audit trails for government oversight
 
8. SCALABILITY AND PERFORMANCE
 
Horizontal Scaling
Kubernetes: Auto-scaling based on CPU/memory usage
Database Sharding: By state code for citizen/business data
CDN: For static assets and media
Load Balancing: Multiple API gateway instances
 
Performance Optimization
Caching: Redis for OID resolution and session data
Database Indexing: Optimized indexes for common queries
Connection Pooling: For database connections
Asynchronous Processing: For non-critical tasks (audit logging, notifications)
 
9. MONITORING AND ALERTING
 
Key Metrics to Monitor
1.System Health: Service availability, response times
2.Business Metrics: Registration rates, user adoption
3.Security Metrics: Failed authentication attempts, suspicious activity
4.Performance Metrics: Database query times, API response times
5.Financial Metrics: Cost per registration, infrastructure costs
 
Alerting Rules
yaml
yaml
# Example alert rules
groups:
  - name: sgdus-alerts
    rules:
      - alert: ServiceDown
        expr: up == 0
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "Service {{ $labels.service }} is down"

      - alert: HighErrorRate
        expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.1
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "High error rate on {{ $labels.service }}"

      - alert: SlowResponseTime
        expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "Slow response time on {{ $labels.service }}"
 
10. DISASTER RECOVERY
 
Backup Strategy
Database: Daily full backups, hourly incremental backups
Application: Configuration backups, code repository
Logs: Centralized log storage with 90-day retention
Off-site: Backups to different region (consider UAE for regional redundancy)
 
Recovery Procedures
1.Database Recovery: Point-in-time recovery up to 15 minutes
2.Service Recovery: Kubernetes pod restart, auto-scaling
3.Data Loss: Restore from backup, replay audit logs
4.Security Incident: Isolate affected systems, rotate credentials
 
This comprehensive system implements all the strategies we discussed, from legal compliance and cultural adaptation to technical implementation and monitoring. The system is designed to be scalable, secure, and aligned with Sudanese context and requirements.
 
Would you like me to elaborate on any specific component or provide additional code for other services?
Creatively add more integrated automated modules to our existing building strategies

INTEGRATED AUTOMATED MODULES FOR SGDUS
 
I'll create 10 innovative, integrated automated modules that enhance our existing system with intelligent automation, predictive capabilities, and self-healing features. Each module will be designed to work seamlessly with the core system architecture we've built.
 
1. INTELLIGENT DATA QUALITY & CLEANSING ENGINE
 
Module Overview
Automated data validation, cleansing, and enrichment with AI-driven quality scoring.
 
File: backend/data-quality-engine/src/app.js
javascript
javascript
const express = require('express');
const { Pool } = require('pg');
const axios = require('axios');
const natural = require('natural');
const { v4: uuidv4 } = require('uuid');
const winston = require('winston');

const app = express();
app.use(express.json());

// NLP and ML libraries
const classifier = new natural.BayesClassifier();
const tokenizer = new natural.WordTokenizer();

// Database connection
const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: process.env.DB_PORT
});

// Logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'data-quality-errors.log', level: 'error' }),
    new winston.transports.File({ filename: 'data-quality-combined.log' })
  ]
});

// Data Quality Engine
class DataQualityEngine {
  constructor() {
    this.qualityRules = new Map();
    this.mlModels = new Map();
    this.initializeRules();
    this.trainMLModels();
  }

 services can be built  initializeRules() {
    // Sudanese-specific data quality rules
    this.qualityRules.set('national_id', [
      { type: 'regex', pattern: /^\d{10}$/, message: 'Must be 10 digits' },
      { type: 'checksum', algorithm: 'luhn', message: 'Invalid checksum' },
      { type: 'range', min: 1000000000, max: 9999999999, message: 'Invalid range' }
    ]);

    this.qualityRules.set('phone_number', [
      { type: 'regex', pattern: /^\+249\d{9}$/, message: 'Must start with +249 and have 9 digits' },
      { type: 'format', format: 'international', message: 'Invalid international format' }
    ]);

    this.qualityRules.set('business_registration_number', [
      { type: 'regex', pattern: /^SD-[A-Z0-9]{5}$/, message: 'Must be SD-XXXXX format' },
      { type: 'prefix', prefix: 'SD-', message: 'Must start with SD-' }
    ]);

    this.qualityRules.set('date_of_birth', [
      { type: 'range', min: '1900-01-01', max: new Date().toISOString().split('T')[0], message: 'Invalid date range' },
      { type: 'format', format: 'ISO8601', message: 'Must be in YYYY-MM-DD format' }
    ]);

    this.qualityRules.set('name', [
      { type: 'length', min: 2, max: 100, message: 'Name must be between 2-100 characters' },
      { type: 'characters', allowed: /^[a-zA-Z\s\-]+$/, message: 'Only letters, spaces, and hyphens allowed' }
    ]);

    this.qualityRules.set('address', [
      { type: 'length', min: 10, max: 500, message: 'Address must be between 10-500 characters' },
      { type: 'sudanese_location', message: 'Must contain valid Sudanese location' }
    ]);
  }

  trainMLModels() {
    // Train ML model for name validation (Arabic names)
    const trainingData = [
      { text: 'أحمد محمد', class: 'valid' },
      { text: 'خالد علي', class: 'valid' },
      { text: '1234567890', class: 'invalid' },
      { text: 'Test Name', class: 'valid' },
      { text: 'Invalid@Name', class: 'invalid' }
    ];

    trainingData.forEach(item => {
      classifier.addDocument(item.text, item.class);
    });
    classifier.train();
  }

  async validateField(fieldName, value, context = {}) {
    const rules = this.qualityRules.get(fieldName);
    if (!rules) {
      return { valid: true, score: 1.0, issues: [] };
    }

    const issues = [];
    let score = 1.0;

    for (const rule of rules) {
      const result = await this.applyRule(rule, value, context);
      if (!result.valid) {
        issues.push(result.issue);
        score -= result.penalty || 0.2;
      }
    }

    // ML-based validation for names
    if (fieldName === 'name' && typeof value === 'string') {
      const mlResult = classifier.classify(value);
      if (mlResult === 'invalid') {
        issues.push('Name format suspicious (ML detection)');
        score -= 0.3;
      }
    }

    // Context-aware validation
    if (context.stateCode && fieldName === 'address') {
      const stateValidation = await this.validateAddressForState(value, context.stateCode);
      if (!stateValidation.valid) {
        issues.push(...stateValidation.issues);
        score -= 0.1;
      }
    }

    return {
      valid: issues.length === 0,
      score: Math.max(0, score),
      issues,
      recommendations: this.generateRecommendations(fieldName, value, issues)
    };
  }

  async applyRule(rule, value, context) {
    switch (rule.type) {
      case 'regex':
        const regex = new RegExp(rule.pattern);
        if (!regex.test(value)) {
          return { valid: false, issue: rule.message, penalty: 0.2 };
        }
        break;

      case 'checksum':
        if (rule.algorithm === 'luhn') {
          if (!this.luhnCheck(value)) {
            return { valid: false, issue: rule.message, penalty: 0.3 };
          }
        }
        break;

      case 'range':
        if (rule.min && rule.max) {
          const numValue = typeof value === 'number' ? value : parseFloat(value);
          const min = typeof rule.min === 'string' ? new Date(rule.min) : rule.min;
          const max = typeof rule.max === 'string' ? new Date(rule.max) : rule.max;

          if (numValue < min || numValue > max) {
            return { valid: false, issue: rule.message, penalty: 0.15 };
          }
        }
        break;

      case 'length':
        if (value.length < rule.min || value.length > rule.max) {
          return { valid: false, issue: rule.message, penalty: 0.1 };
        }
        break;

      case 'characters':
        if (!rule.allowed.test(value)) {
          return { valid: false, issue: rule.message, penalty: 0.2 };
        }
        break;

      case 'sudanese_location':
        if (!await this.validateSudaneseLocation(value)) {
          return { valid: false, issue: rule.message, penalty: 0.15 };
        }
        break;
    }

    return { valid: true };
  }

  luhnCheck(value) {
    let sum = 0;
    let shouldDouble = false;

    for (let i = value.length - 1; i >= 0; i--) {
      let digit = parseInt(value.charAt(i));

      if (shouldDouble) {
        digit *= 2;
        if (digit > 9) digit -= 9;
      }

      sum += digit;
      shouldDouble = !shouldDouble;
    }

    return sum % 10 === 0;
  }

  async validateSudaneseLocation(address) {
    // Check against known Sudanese locations
    const locations = ['Khartoum', 'Port Sudan', 'Kassala', 'Dongola', 'Kosti', 'Wad Madani'];
    return locations.some(loc => address.toLowerCase().includes(loc.toLowerCase()));
  }

  async validateAddressForState(address, stateCode) {
    // Validate address matches state
    const stateMap = {
      '01': ['Khartoum', 'Omdurman', 'Khartoum North'],
      '02': ['Port Sudan', 'Suakin'],
      '03': ['El Obeid', 'Barah'],
      '14': ['Kassala', 'Aroma']
    };

    const expectedLocations = stateMap[stateCode] || [];
    const hasMatch = expectedLocations.some(loc =>
      address.toLowerCase().includes(loc.toLowerCase())
    );

    if (!hasMatch && expectedLocations.length > 0) {
      return { valid: false, issues: [`Address doesn't match state ${stateCode}`] };
    }

    return { valid: true, issues: [] };
  }

  generateRecommendations(fieldName, value, issues) {
    const recommendations = [];

    if (fieldName === 'national_id' && issues.includes('Invalid checksum')) {
      recommendations.push('Check the last digit of the National ID');
    }

    if (fieldName === 'phone_number' && issues.length > 0) {
      recommendations.push('Ensure format is +249XXXXXXXXX');
    }

    if (fieldName === 'name' && issues.length > 0) {
      recommendations.push('Use Arabic or English characters only');
    }

    return recommendations;
  }

  async cleanseData(data, entityType) {
    const cleansedData = { ...data };
    const qualityReport = {
      overallScore: 1.0,
      fieldScores: {},
      issues: [],
      corrections: []
    };

    // Field-specific cleansing
    if (cleansedData.national_id) {
      cleansedData.national_id = cleansedData.national_id.replace(/\s/g, '');
    }

    if (cleansedData.phone_number) {
      // Normalize phone number
      cleansedData.phone_number = cleansedData.phone_number.replace(/[^0-9+]/g, '');
      if (!cleansedData.phone_number.startsWith('+249')) {
        if (cleansedData.phone_number.startsWith('0')) {
          cleansedData.phone_number = '+249' + cleansedData.phone_number.substring(1);
        }
      }
    }

    if (cleansedData.first_name) {
      // Capitalize first letter
      cleansedData.first_name = cleansedData.first_name.charAt(0).toUpperCase() +
                                cleansedData.first_name.slice(1).toLowerCase();
    }

    if (cleansedData.last_name) {
      cleansedData.last_name = cleansedData.last_name.charAt(0).toUpperCase() +
                              cleansedData.last_name.slice(1).toLowerCase();
    }

    // Validate all fields
    const validationPromises = Object.keys(cleansedData).map(async (field) => {
      if (field === 'biometric_data') return; // Skip biometric data
      const validation = await this.validateField(field, cleansedData[field], {
        stateCode: cleansedData.stateCode,
        entityType
      });

      qualityReport.fieldScores[field] = validation.score;
      if (!validation.valid) {
        qualityReport.issues.push(...validation.issues);
        qualityReport.overallScore = Math.min(qualityReport.overallScore, validation.score);
      }

      return validation;
    });

    await Promise.all(validationPromises);

    // Calculate overall quality score
    const scores = Object.values(qualityReport.fieldScores);
    if (scores.length > 0) {
      qualityReport.overallScore = scores.reduce((a, b) => a + b, 0) / scores.length;
    }

    // Generate quality badge
    qualityReport.badge = this.generateQualityBadge(qualityReport.overallScore);

    return {
      cleansedData,
      qualityReport
    };
  }

  generateQualityBadge(score) {
    if (score >= 0.9) return 'A+';
    if (score >= 0.8) return 'A';
    if (score >= 0.7) return 'B+';
    if (score >= 0.6) return 'B';
    if (score >= 0.5) return 'C';
    return 'D';
  }

  async enrichData(data, entityType) {
    const enrichedData = { ...data };

    // Add timestamp
    enrichedData.quality_checked_at = new Date().toISOString();
    enrichedData.quality_engine_version = '1.0.0';

    // Add source tracking
    if (!enrichedData.source) {
      enrichedData.source = 'automated_validation';
    }

    // Add confidence scores
    if (entityType === 'citizen') {
      enrichedData.confidence_scores = {
        national_id: await this.calculateConfidence('national_id', data.national_id),
        name: await this.calculateConfidence('name', `${data.first_name} ${data.last_name}`),
        address: await this.calculateConfidence('address', data.address)
      };
    }

    return enrichedData;
  }

  async calculateConfidence(fieldType, value) {
    // Simulate confidence calculation based on data quality
    const validation = await this.validateField(fieldType, value);
    return validation.score;
  }

  async detectAnomalies(data, entityType) {
    const anomalies = [];

    // Check for duplicate National IDs
    if (data.national_id) {
      const duplicateCheck = await pool.query(
        'SELECT oid FROM citizens WHERE national_id = $1 AND oid != $2',
        [data.national_id, data.oid || '']
      );

      if (duplicateCheck.rows.length > 0) {
        anomalies.push({
          type: 'DUPLICATE_NATIONAL_ID',
          severity: 'HIGH',
          message: `National ID ${data.national_id} already exists`,
          existing_oid: duplicateCheck.rows[0].oid
        });
      }
    }

    // Check for suspicious patterns
    if (data.phone_number && data.address) {
      const phoneInAddress = data.address.includes(data.phone_number.replace(/\D/g, ''));
      if (phoneInAddress) {
        anomalies.push({
          type: 'PATTERN_SUSPICION',
          severity: 'MEDIUM',
          message: 'Phone number appears in address - possible data entry error'
        });
      }
    }

    // Check for age inconsistencies
    if (data.date_of_birth) {
      const birthDate = new Date(data.date_of_birth);
      const age = Math.floor((new Date() - birthDate) / (365.25 * 24 * 60 * 60 * 1000));

      if (age < 0 || age > 150) {
        anomalies.push({
          type: 'AGE_ANOMALY',
          severity: 'HIGH',
          message: `Age ${age} is unrealistic`,
          suggested_correction: 'Verify date of birth'
        });
      }
    }

    return anomalies;
  }
}

const qualityEngine = new DataQualityEngine();

// API Endpoints

// Validate data endpoint
app.post('/api/v1/data-quality/validate', async (req, res) => {
  try {
    const { data, entityType } = req.body;

    if (!data || !entityType) {
      return res.status(400).json({ error: 'Missing data or entityType' });
    }

    const validationResults = {};
    const issues = [];
    let overallScore = 1.0;

    // Validate each field
    for (const [field, value] of Object.entries(data)) {
      if (field === 'biometric_data') continue;

      const validation = await qualityEngine.validateField(field, value, {
        stateCode: data.stateCode,
        entityType
      });

      validationResults[field] = validation;

      if (!validation.valid) {
        issues.push(...validation.issues);
        overallScore = Math.min(overallScore, validation.score);
      }
    }

    // Detect anomalies
    const anomalies = await qualityEngine.detectAnomalies(data, entityType);

    res.json({
      success: true,
      validationResults,
      overallScore,
      badge: qualityEngine.generateQualityBadge(overallScore),
      issues,
      anomalies,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Validation error', { error: error.message });
    res.status(500).json({ error: 'Validation failed' });
  }
});

// Cleanse data endpoint
app.post('/api/v1/data-quality/cleanse', async (req, res) => {
  try {
    const { data, entityType } = req.body;

    if (!data || !entityType) {
      return res.status(400).json({ error: 'Missing data or entityType' });
    }

    const result = await qualityEngine.cleanseData(data, entityType);

    res.json({
      success: true,
      cleansedData: result.cleansedData,
      qualityReport: result.qualityReport,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Cleansing error', { error: error.message });
    res.status(500).json({ error: 'Cleansing failed' });
  }
});

// Enrich data endpoint
app.post('/api/v1/data-quality/enrich', async (req, res) => {
  try {
    const { data, entityType } = req.body;

    if (!data || !entityType) {
      return res.status(400).json({ error: 'Missing data or entityType' });
    }

    const enrichedData = await qualityEngine.enrichData(data, entityType);

    res.json({
      success: true,
      enrichedData,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Enrichment error', { error: error.message });
    res.status(500).json({ error: 'Enrichment failed' });
  }
});

// Batch quality check endpoint
app.post('/api/v1/data-quality/batch-check', async (req, res) => {
  try {
    const { records, entityType } = req.body;

    if (!records || !Array.isArray(records) || !entityType) {
      return res.status(400).json({ error: 'Invalid request' });
    }

    const results = await Promise.all(
      records.map(async (record, index) => {
        const validation = await qualityEngine.cleanseData(record, entityType);
        return {
          index,
          recordId: record.oid || record.national_id || record.registration_number,
          ...validation
        };
      })
    );

    const summary = {
      totalRecords: results.length,
      passed: results.filter(r => r.qualityReport.overallScore >= 0.7).length,
      failed: results.filter(r => r.qualityReport.overallScore < 0.7).length,
      averageScore: results.reduce((sum, r) => sum + r.qualityReport.overallScore, 0) / results.length,
      topIssues: this.aggregateIssues(results)
    };

    res.json({
      success: true,
      results,
      summary,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Batch check error', { error: error.message });
    res.status(500).json({ error: 'Batch check failed' });
  }
});

// Health check
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    service: 'Data Quality Engine',
    timestamp: new Date().toISOString(),
    version: '1.0.0',
    mlModels: Array.from(qualityEngine.mlModels.keys())
  });
});

const PORT = process.env.PORT || 3011;
app.listen(PORT, () => {
  logger.info(`Data Quality Engine running on port ${PORT}`);
  console.log(`Data Quality Engine running on port ${PORT}`);
});

module.exports = app;
 
2. AUTOMATED FRAUD DETECTION & ANOMALY DETECTION SYSTEM
 
Module Overview
Real-time fraud detection using machine learning and rule-based systems with predictive analytics.
 
File: backend/fraud-detection-system/src/app.js
javascript
javascript
const express = require('express');
const { Pool } = require('pg');
const Redis = require('ioredis');
const axios = require('axios');
const { Kafka } = require('kafkajs');
const winston = require('winston');
const tf = require('@tensorflow/tfjs-node');
const { v4: uuidv4 } = require('uuid');

const app = express();
app.use(express.json());

// Kafka setup
const kafka = new Kafka({
  clientId: 'fraud-detection-system',
  brokers: process.env.KAFKA_BROKERS?.split(',') || ['localhost:9092']
});

// Database connection
const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: process.env.DB_PORT
});

// Redis for caching
const redis = new Redis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD
});

// Logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'fraud-errors.log', level: 'error' }),
    new winston.transports.File({ filename: 'fraud-combined.log' })
  ]
});

// Fraud Detection System
class FraudDetectionSystem {
  constructor() {
    this.models = new Map();
    this.rules = [];
    this.anomalyDetectors = new Map();
    this.initializeRules();
    this.initializeMLModels();
  }

  initializeRules() {
    // Rule-based fraud detection
    this.rules = [
      {
        name: 'DUPLICATE_NATIONAL_ID',
        condition: async (data) => {
          const cacheKey = `fraud:national_id:${data.national_id}`;
          const cached = await redis.get(cacheKey);

          if (cached) {
            return { fraud: true, confidence: 0.95, reason: 'Duplicate National ID in cache' };
          }

          const result = await pool.query(
            'SELECT COUNT(*) as count FROM citizens WHERE national_id = $1',
            [data.national_id]
          );

          if (result.rows[0].count > 0) {
            await redis.setex(cacheKey, 3600, 'duplicate');
            return { fraud: true, confidence: 0.9, reason: 'Duplicate National ID in database' };
          }

          return { fraud: false };
        }
      },
      {
        name: 'SUSPICIOUS_IP_PATTERN',
        condition: async (data) => {
          const ip = data.ip_address;
          if (!ip) return { fraud: false };

          // Check for rapid registrations from same IP
          const cacheKey = `fraud:ip:${ip}`;
          const count = await redis.incr(cacheKey);
          await redis.expire(cacheKey, 300); // 5 minutes

          if (count > 5) {
            return {
              fraud: true,
              confidence: 0.8,
              reason: `High registration rate from IP ${ip}: ${count} registrations in 5 minutes`
            };
          }

          return { fraud: false };
        }
      },
      {
        name: 'GEOGRAPHIC_ANOMALY',
        condition: async (data) => {
          // Check if address matches registered state
          if (!data.state_code || !data.address) return { fraud: false };

          const stateMap = {
            '01': ['Khartoum', 'Omdurman', 'Khartoum North'],
            '02': ['Port Sudan', 'Suakin'],
            '03': ['El Obeid', 'Barah']
          };

          const expectedLocations = stateMap[data.state_code] || [];
          const addressLower = data.address.toLowerCase();

          const hasMatch = expectedLocations.some(loc =>
            addressLower.includes(loc.toLowerCase())
          );

          if (!hasMatch && expectedLocations.length > 0) {
            return {
              fraud: true,
              confidence: 0.7,
              reason: `Address doesn't match state ${data.state_code}`
            };
          }

          return { fraud: false };
        }
      },
      {
        name: 'AGE_ANOMALY',
        condition: async (data) => {
          if (!data.date_of_birth) return { fraud: false };

          const birthDate = new Date(data.date_of_birth);
          const age = Math.floor((new Date() - birthDate) / (365.25 * 24 * 60 * 60 * 1000));

          if (age < 0 || age > 150) {
            return {
              fraud: true,
              confidence: 0.95,
              reason: `Age ${age} is unrealistic`
            };
          }

          // Check for age inconsistencies with registration date
          if (data.registration_date) {
            const regDate = new Date(data.registration_date);
            const ageAtRegistration = Math.floor((regDate - birthDate) / (365.25 * 24 * 60 * 60 * 1000));

            if (ageAtRegistration < 18) {
              return {
                fraud: true,
                confidence: 0.85,
                reason: `Age ${ageAtRegistration} at registration is below legal age`
              };
            }
          }

          return { fraud: false };
        }
      },
      {
        name: 'BIOMETRIC_ANOMALY',
        condition: async (data) => {
          if (!data.biometric_data) return { fraud: false };

          // Check for biometric duplication
          const biometricHash = this.hashBiometric(data.biometric_data);
          const cacheKey = `fraud:biometric:${biometricHash}`;
          const cached = await redis.get(cacheKey);

          if (cached) {
            return {
              fraud: true,
              confidence: 0.95,
              reason: 'Biometric data matches existing record'
            };
          }

          await redis.setex(cacheKey, 86400, 'exists'); // 24 hours

          return { fraud: false };
        }
      },
      {
        name: 'PATTERN_ANOMALY',
        condition: async (data) => {
          // Detect suspicious patterns
          const patterns = [
            { pattern: /^\d{10}$/, field: 'national_id', reason: 'National ID is all digits' },
            { pattern: /^12345/, field: 'national_id', reason: 'National ID starts with 12345' },
            { pattern: /test/i, field: 'first_name', reason: 'Name contains "test"' },
            { pattern: /admin/i, field: 'first_name', reason: 'Name contains "admin"' }
          ];

          for (const { pattern, field, reason } of patterns) {
            if (data[field] && pattern.test(data[field])) {
              return {
                fraud: true,
                confidence: 0.8,
                reason: reason
              };
            }
          }

          return { fraud: false };
        }
      }
    ];
  }

  initializeMLModels() {
    // Initialize TensorFlow.js models for anomaly detection
    // In production, these would be trained models loaded from storage
    this.models.set('anomaly_detector', {
      predict: (features) => {
        // Simplified anomaly score calculation
        // In production, this would use a trained model
        const anomalyScore = this.calculateAnomalyScore(features);
        return { score: anomalyScore, isAnomaly: anomalyScore > 0.7 };
      }
    });
  }

  hashBiometric(biometricData) {
    const crypto = require('crypto');
    return crypto.createHash('sha256').update(biometricData).digest('hex');
  }

  calculateAnomalyScore(features) {
    // Simplified anomaly scoring
    // In production, this would use a trained ML model
    let score = 0;

    // Check for multiple registrations
    if (features.registration_count > 3) score += 0.3;

    // Check for suspicious IP patterns
    if (features.ip_reputation === 'low') score += 0.2;

    // Check for data inconsistencies
    if (features.data_consistency < 0.5) score += 0.3;

    // Check for temporal patterns
    if (features.time_of_day === 'unusual') score += 0.2;

    return Math.min(score, 1.0);
  }

  async detectFraud(data, context = {}) {
    const detectionResults = [];
    let overallConfidence = 0;
    let fraudDetected = false;

    // Run rule-based detection
    for (const rule of this.rules) {
      try {
        const result = await rule.condition(data);
        if (result.fraud) {
          detectionResults.push({
            rule: rule.name,
            fraud: true,
            confidence: result.confidence,
            reason: result.reason
          });

          overallConfidence = Math.max(overallConfidence, result.confidence);
          fraudDetected = true;
        }
      } catch (error) {
        logger.error(`Rule ${rule.name} failed`, { error: error.message });
      }
    }

    // Run ML-based anomaly detection
    const features = await this.extractFeatures(data, context);
    const mlResult = this.models.get('anomaly_detector').predict(features);

    if (mlResult.isAnomaly) {
      detectionResults.push({
        rule: 'ML_ANOMALY_DETECTOR',
        fraud: true,
        confidence: mlResult.score,
        reason: 'ML model detected anomalous pattern'
      });

      overallConfidence = Math.max(overallConfidence, mlResult.score);
      fraudDetected = true;
    }

    // Calculate overall risk score
    const riskScore = this.calculateRiskScore(detectionResults);

    // Determine action
    const action = this.determineAction(riskScore, context);

    return {
      fraudDetected,
      overallConfidence,
      riskScore,
      action,
      detectionResults,
      timestamp: new Date().toISOString(),
      requestId: uuidv4()
    };
  }

  async extractFeatures(data, context) {
    const features = {
      registration_count: await this.getRegistrationCount(data),
      ip_reputation: await this.checkIPReputation(context.ip_address),
      data_consistency: await this.calculateDataConsistency(data),
      time_of_day: this.getTimeOfDayPattern(),
      geographic_consistency: await this.checkGeographicConsistency(data),
      biometric_quality: data.biometric_data ? 0.8 : 0.2,
      velocity: await this.checkRegistrationVelocity(context.ip_address)
    };

    return features;
  }

  async getRegistrationCount(data) {
    const cacheKey = `reg_count:${data.national_id || data.phone_number || data.email}`;
    const cached = await redis.get(cacheKey);
    if (cached) return parseInt(cached);

    // Query database for registration count
    let count = 0;
    if (data.national_id) {
      const result = await pool.query(
        'SELECT COUNT(*) FROM citizens WHERE national_id = $1',
        [data.national_id]
      );
      count = parseInt(result.rows[0].count);
    }

    await redis.setex(cacheKey, 300, count.toString());
    return count;
  }

  async checkIPReputation(ip) {
    if (!ip) return 'unknown';

    // Simulate IP reputation check
    // In production, integrate with IP reputation service
    const suspiciousIPs = ['10.0.0.1', '192.168.1.100'];
    if (suspiciousIPs.includes(ip)) return 'low';

    return 'high';
  }

  async calculateDataConsistency(data) {
    // Check for data consistency across fields
    let score = 1.0;

    // Check if name contains numbers
    if (/[0-9]/.test(data.first_name || '') || /[0-9]/.test(data.last_name || '')) {
      score -= 0.3;
    }

    // Check if address is too short
    if (data.address && data.address.length < 20) {
      score -= 0.2;
    }

    // Check for realistic age
    if (data.date_of_birth) {
      const age = Math.floor((new Date() - new Date(data.date_of_birth)) / (365.25 * 24 * 60 * 60 * 1000));
      if (age < 18 || age > 100) {
        score -= 0.3;
      }
    }

    return Math.max(score, 0);
  }

  getTimeOfDayPattern() {
    const hour = new Date().getHours();
    // Normal business hours
    if (hour >= 9 && hour <= 17) return 'normal';
    // Unusual hours
    return 'unusual';
  }

  async checkGeographicConsistency(data) {
    if (!data.state_code || !data.address) return 1.0;

    const stateMap = {
      '01': ['Khartoum', 'Omdurman', 'Khartoum North'],
      '02': ['Port Sudan', 'Suakin'],
      '03': ['El Obeid', 'Barah']
    };

    const expectedLocations = stateMap[data.state_code] || [];
    const addressLower = data.address.toLowerCase();

    const hasMatch = expectedLocations.some(loc =>
      addressLower.includes(loc.toLowerCase())
    );

    return hasMatch ? 1.0 : 0.5;
  }

  async checkRegistrationVelocity(ip) {
    if (!ip) return 0;

    const cacheKey = `velocity:${ip}`;
    const count = await redis.incr(cacheKey);
    await redis.expire(cacheKey, 60); // 1 minute

    return Math.min(count / 5, 1.0); // Normalize to 0-1
  }

  calculateRiskScore(results) {
    if (results.length === 0) return 0;

    const weightedScore = results.reduce((sum, result) => {
      return sum + (result.confidence * (result.rule === 'ML_ANOMALY_DETECTOR' ? 1.5 : 1));
    }, 0) / results.length;

    return Math.min(weightedScore, 1.0);
  }

  determineAction(riskScore, context) {
    if (riskScore >= 0.9) {
      return {
        type: 'BLOCK',
        message: 'Registration blocked due to high fraud risk',
        requiresManualReview: true,
        notify: ['security', 'admin']
      };
    } else if (riskScore >= 0.7) {
      return {
        type: 'FLAG',
        message: 'Registration flagged for review',
        requiresManualReview: true,
        notify: ['reviewer'],
        additionalChecks: ['biometric', 'document']
      };
    } else if (riskScore >= 0.5) {
      return {
        type: 'REVIEW',
        message: 'Registration requires additional verification',
        requiresManualReview: false,
        additionalChecks: ['phone_verification', 'email_verification']
      };
    } else {
      return {
        type: 'APPROVE',
        message: 'Registration approved',
        requiresManualReview: false
      };
    }
  }

  async logFraudAttempt(data, detectionResult) {
    const logEntry = {
      id: uuidv4(),
      timestamp: new Date().toISOString(),
      data: this.anonymizeData(data),
      detectionResult,
      context: {
        ip_address: data.ip_address,
        user_agent: data.user_agent,
        session_id: data.session_id
      }
    };

    // Store in database
    await pool.query(
      `INSERT INTO fraud_logs
       (id, timestamp, data, detection_result, context)
       VALUES ($1, $2, $3, $4, $5)`,
      [
        logEntry.id,
        logEntry.timestamp,
        JSON.stringify(logEntry.data),
        JSON.stringify(logEntry.detectionResult),
        JSON.stringify(logEntry.context)
      ]
    );

    // Publish to Kafka for real-time alerting
    const producer = kafka.producer();
    await producer.connect();
    await producer.send({
      topic: 'fraud-events',
      messages: [{ value: JSON.stringify(logEntry) }]
    });
    await producer.disconnect();

    return logEntry;
  }

  anonymizeData(data) {
    const sensitiveFields = ['national_id', 'phone_number', 'email', 'biometric_data'];
    const anonymized = { ...data };

    sensitiveFields.forEach(field => {
      if (anonymized[field]) {
        if (field === 'national_id') {
          anonymized[field] = '****' + anonymized[field].slice(-4);
        } else if (field === 'phone_number') {
          anonymized[field] = anonymized[field].replace(/(\d{3})\d{4}(\d{3})/, '****$2');
        } else if (field === 'email') {
          const [local, domain] = anonymized[field].split('@');
          anonymized[field] = `${local[0]}***@${domain}`;
        } else {
          anonymized[field] = '***';
        }
      }
    });

    return anonymized;
  }

  async trainModel(newData) {
    // In production, this would train the ML model with new data
    // For now, we'll just log the training request
    logger.info('Model training requested', {
      dataPoints: newData.length,
      timestamp: new Date().toISOString()
    });

    return { trained: true, modelVersion: '1.0.1' };
  }

  async updateRules(newRules) {
    // Update detection rules dynamically
    this.rules.push(...newRules);
    logger.info('Rules updated', { newRuleCount: newRules.length });

    return { updated: true, totalRules: this.rules.length };
  }
}

const fraudSystem = new FraudDetectionSystem();

// API Endpoints

// Real-time fraud detection
app.post('/api/v1/fraud/detect', async (req, res) => {
  try {
    const { data, context } = req.body;

    if (!data) {
      return res.status(400).json({ error: 'Missing data' });
    }

    // Add context from request
    const enrichedContext = {
      ...context,
      ip_address: req.ip,
      user_agent: req.get('User-Agent'),
      timestamp: new Date().toISOString()
    };

    const detectionResult = await fraudSystem.detectFraud(data, enrichedContext);

    // Log the attempt
    if (detectionResult.fraudDetected) {
      await fraudSystem.logFraudAttempt(data, detectionResult);

      // Send alert if high risk
      if (detectionResult.riskScore >= 0.8) {
        await this.sendAlert(detectionResult, data);
      }
    }

    res.json({
      success: true,
      ...detectionResult,
      data: fraudSystem.anonymizeData(data)
    });
  } catch (error) {
    logger.error('Fraud detection error', { error: error.message });
    res.status(500).json({ error: 'Fraud detection failed' });
  }
});

// Batch fraud detection
app.post('/api/v1/fraud/batch-detect', async (req, res) => {
  try {
    const { records, context } = req.body;

    if (!records || !Array.isArray(records)) {
      return res.status(400).json({ error: 'Invalid request' });
    }

    const results = await Promise.all(
      records.map(async (record, index) => {
        const detectionResult = await fraudSystem.detectFraud(record, context);

        if (detectionResult.fraudDetected) {
          await fraudSystem.logFraudAttempt(record, detectionResult);
        }

        return {
          index,
          recordId: record.oid || record.national_id || record.registration_number,
          ...detectionResult
        };
      })
    );

    const summary = {
      totalRecords: results.length,
      fraudDetected: results.filter(r => r.fraudDetected).length,
      highRisk: results.filter(r => r.riskScore >= 0.8).length,
      averageRiskScore: results.reduce((sum, r) => sum + r.riskScore, 0) / results.length
    };

    res.json({
      success: true,
      results,
      summary,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Batch fraud detection error', { error: error.message });
    res.status(500).json({ error: 'Batch detection failed' });
  }
});

// Update ML model
app.post('/api/v1/fraud/train-model', async (req, res) => {
  try {
    const { trainingData } = req.body;

    if (!trainingData || !Array.isArray(trainingData)) {
      return res.status(400).json({ error: 'Invalid training data' });
    }

    const result = await fraudSystem.trainModel(trainingData);

    res.json({
      success: true,
      ...result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Model training error', { error: error.message });
    res.status(500).json({ error: 'Model training failed' });
  }
});

// Update detection rules
app.post('/api/v1/fraud/update-rules', async (req, res) => {
  try {
    const { rules } = req.body;

    if (!rules || !Array.isArray(rules)) {
      return res.status(400).json({ error: 'Invalid rules' });
    }

    const result = await fraudSystem.updateRules(rules);

    res.json({
      success: true,
      ...result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Rule update error', { error: error.message });
    res.status(500).json({ error: 'Rule update failed' });
  }
});

// Get fraud statistics
app.get('/api/v1/fraud/statistics', async (req, res) => {
  try {
    const { days = 30 } = req.query;

    const result = await pool.query(`
      SELECT
        DATE(timestamp) as date,
        COUNT(*) as total_attempts,
        COUNT(CASE WHEN (detection_result->>'fraudDetected')::boolean = true THEN 1 END) as fraud_detected,
        AVG((detection_result->>'riskScore')::numeric) as avg_risk_score,
        COUNT(CASE WHEN (detection_result->>'action'->>'type') = 'BLOCK' THEN 1 END) as blocked
      FROM fraud_logs
      WHERE timestamp >= NOW() - INTERVAL '${days} days'
      GROUP BY DATE(timestamp)
      ORDER BY date DESC
    `);

    res.json({
      success: true,
      statistics: result.rows,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Statistics error', { error: error.message });
    res.status(500).json({ error: 'Failed to get statistics' });
  }
});

// Health check
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    service: 'Fraud Detection System',
    timestamp: new Date().toISOString(),
    version: '1.0.0',
    rulesCount: fraudSystem.rules.length,
    modelsCount: fraudSystem.models.size
  });
});

const PORT = process.env.PORT || 3012;
app.listen(PORT, () => {
  logger.info(`Fraud Detection System running on port ${PORT}`);
  console.log(`Fraud Detection System running on port ${PORT}`);
});

module.exports = app;
 
3. INTELLIGENT REPORTING & ANALYTICS ENGINE
 
Module Overview
Automated report generation, predictive analytics, and business intelligence with Sudanese-specific metrics.
 
File: backend/reporting-analytics-engine/src/app.js
javascript
javascript
const express = require('express');
const { Pool } = require('pg');
const Redis = require('ioredis');
const axios = require('axios');
const { Kafka } = require('kafkajs');
const winston = require('winston');
const { v4: uuidv4 } = require('uuid');
const { exec } = require('child_process');
const fs = require('fs').promises;
const path = require('path');

const app = express();
app.use(express.json());

// Database connection
const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: process.env.DB_PORT
});

// Redis for caching
const redis = new Redis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD
});

// Kafka for real-time analytics
const kafka = new Kafka({
  clientId: 'reporting-analytics-engine',
  brokers: process.env.KAFKA_BROKERS?.split(',') || ['localhost:9092']
});

// Logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'analytics-errors.log', level: 'error' }),
    new winston.transports.File({ filename: 'analytics-combined.log' })
  ]
});

// Reporting & Analytics Engine
class ReportingAnalyticsEngine {
  constructor() {
    this.reportTemplates = new Map();
    this.analyticalModels = new Map();
    this.initializeReportTemplates();
    this.initializeAnalyticalModels();
  }

  initializeReportTemplates() {
    // Sudanese-specific report templates
    this.reportTemplates.set('citizen_registration_daily', {
      name: 'Daily Citizen Registration Report',
      type: 'time_series',
      metrics: ['total_registrations', 'by_gender', 'by_state', 'by_age_group'],
      filters: ['date_range', 'state', 'gender'],
      visualization: 'line_chart',
      frequency: 'daily',
      format: ['pdf', 'excel', 'json']
    });

    this.reportTemplates.set('business_registration_trend', {
      name: 'Business Registration Trend',
      type: 'trend_analysis',
      metrics: ['new_registrations', 'by_business_type', 'by_state', 'growth_rate'],
      filters: ['date_range', 'state', 'business_type'],
      visualization: 'bar_chart',
      frequency: 'weekly',
      format: ['pdf', 'excel', 'json']
    });

    this.reportTemplates.set('fraud_detection_summary', {
      name: 'Fraud Detection Summary',
      type: 'security_report',
      metrics: ['total_attempts', 'fraud_detected', 'blocked', 'risk_scores'],
      filters: ['date_range', 'risk_level', 'detection_method'],
      visualization: 'pie_chart',
      frequency: 'daily',
      format: ['pdf', 'json']
    });

    this.reportTemplates.set('system_performance', {
      name: 'System Performance Report',
      type: 'technical_report',
      metrics: ['api_response_time', 'error_rate', 'uptime', 'resource_usage'],
      filters: ['date_range', 'service'],
      visualization: 'dashboard',
      frequency: 'hourly',
      format: ['json', 'csv']
    });

    this.reportTemplates.set('economic_impact', {
      name: 'Economic Impact Analysis',
      type: 'economic_report',
      metrics: ['formalization_rate', 'tax_revenue_potential', 'job_creation', 'gdp_contribution'],
      filters: ['date_range', 'sector', 'region'],
      visualization: 'multi_chart',
      frequency: 'monthly',
      format: ['pdf', 'excel', 'json']
    });

    this.reportTemplates.set('sdg_progress', {
      name: 'SDG Progress Report',
      type: 'sdg_report',
      metrics: ['sdg_8', 'sdg_9', 'sdg_10', 'sdg_16', 'sdg_17'],
      filters: ['date_range', 'sdg_goal', 'indicator'],
      visualization: 'radar_chart',
      frequency: 'quarterly',
      format: ['pdf', 'json']
    });
  }

  initializeAnalyticalModels() {
    // Predictive models for analytics
    this.analyticalModels.set('registration_forecast', {
      name: 'Registration Forecast Model',
      type: 'time_series_forecast',
      algorithm: 'arima',
      features: ['historical_registrations', 'seasonality', 'external_factors'],
      predict: async (periods = 30) => {
        return await this.predictRegistrations(periods);
      }
    });

    this.analyticalModels.set('fraud_risk_prediction', {
      name: 'Fraud Risk Prediction Model',
      type: 'classification',
      algorithm: 'random_forest',
      features: ['ip_pattern', 'data_consistency', 'temporal_pattern'],
      predict: async (data) => {
        return await this.predictFraudRisk(data);
      }
    });

    this.analyticalModels.set('economic_impact_prediction', {
      name: 'Economic Impact Prediction Model',
      type: 'regression',
      algorithm: 'gradient_boosting',
      features: ['registration_growth', 'formalization_rate', 'sector_distribution'],
      predict: async (periods = 12) => {
        return await this.predictEconomicImpact(periods);
      }
    });
  }

  async generateReport(reportType, filters, format = 'json') {
    const template = this.reportTemplates.get(reportType);

    if (!template) {
      throw new Error(`Unknown report type: ${reportType}`);
    }

    // Check cache first
    const cacheKey = `report:${reportType}:${JSON.stringify(filters)}`;
    const cached = await redis.get(cacheKey);

    if (cached) {
      logger.info(`Serving cached report for ${reportType}`);
      return JSON.parse(cached);
    }

    // Generate report data
    const reportData = await this.generateReportData(template, filters);

    // Apply analytical models if needed
    if (template.type === 'economic_report' || template.type === 'sdg_report') {
      reportData.predictions = await this.applyAnalyticalModels(template, filters);
    }

    // Format report
    const formattedReport = await this.formatReport(reportData, format);

    // Cache the report (1 hour TTL)
    await redis.setex(cacheKey, 3600, JSON.stringify(formattedReport));

    // Store in database for audit
    await this.storeReportAudit(reportType, filters, formattedReport);

    return formattedReport;
  }

  async generateReportData(template, filters) {
    const data = {
      metadata: {
        reportType: template.name,
        generatedAt: new Date().toISOString(),
        filters: filters,
        version: '1.0.0'
      },
      metrics: {},
      charts: [],
      tables: []
    };

    // Generate metrics based on template
    for (const metric of template.metrics) {
      data.metrics[metric] = await this.calculateMetric(metric, filters);
    }

    // Generate visualizations
    data.charts = await this.generateCharts(template.visualization, data.metrics);

    // Generate tables
    data.tables = await this.generateTables(template, filters);

    return data;
  }

  async calculateMetric(metricName, filters) {
    switch (metricName) {
      case 'total_registrations':
        return await this.getTotalRegistrations(filters);

      case 'by_gender':
        return await this.getRegistrationsByGender(filters);

      case 'by_state':
        return await this.getRegistrationsByState(filters);

      case 'by_age_group':
        return await this.getRegistrationsByAgeGroup(filters);

      case 'new_registrations':
        return await this.getNewRegistrations(filters);

      case 'by_business_type':
        return await this.getBusinessRegistrationsByType(filters);

      case 'growth_rate':
        return await this.calculateGrowthRate(filters);

      case 'total_attempts':
        return await this.getFraudAttempts(filters);

      case 'fraud_detected':
        return await this.getFraudDetected(filters);

      case 'blocked':
        return await this.getBlockedRegistrations(filters);

      case 'risk_scores':
        return await this.getRiskScoreDistribution(filters);

      case 'api_response_time':
        return await this.getApiResponseTimes(filters);

      case 'error_rate':
        return await this.getErrorRate(filters);

      case 'uptime':
        return await this.getUptime(filters);

      case 'formalization_rate':
        return await this.getFormalizationRate(filters);

      case 'tax_revenue_potential':
        return await this.getTaxRevenuePotential(filters);

      case 'job_creation':
        return await this.getJobCreation(filters);

      case 'gdp_contribution':
        return await this.getGDPContribution(filters);

      case 'sdg_8':
        return await this.getSDG8Progress(filters);

      case 'sdg_9':
        return await this.getSDG9Progress(filters);

      case 'sdg_10':
        return await this.getSDG10Progress(filters);

      case 'sdg_16':
        return await this.getSDG16Progress(filters);

      case 'sdg_17':
        return await this.getSDG17Progress(filters);

      default:
        return { value: 0, description: 'Metric not implemented' };
    }
  }

  async getTotalRegistrations(filters) {
    const { date_range, state, gender } = filters;

    let query = `
      SELECT
        COUNT(*) as total,
        COUNT(CASE WHEN c.gender = 'M' THEN 1 END) as males,
        COUNT(CASE WHEN c.gender = 'F' THEN 1 END) as females,
        COUNT(CASE WHEN c.gender = 'O' THEN 1 END) as other
      FROM citizens c
      WHERE c.status = 'active'
    `;

    const params = [];
    let paramCount = 1;

    if (date_range) {
      const [start, end] = date_range.split(' to ');
      query += ` AND c.created_at BETWEEN $${paramCount} AND $${paramCount + 1}`;
      params.push(start, end);
      paramCount += 2;
    }

    if (state) {
      query += ` AND c.state_code = $${paramCount}`;
      params.push(state);
      paramCount++;
    }

    if (gender) {
      query += ` AND c.gender = $${paramCount}`;
      params.push(gender);
      paramCount++;
    }

    const result = await pool.query(query, params);
    return result.rows[0];
  }

  async getRegistrationsByState(filters) {
    const { date_range } = filters;

    let query = `
      SELECT
        c.state_code,
        s.name as state_name,
        COUNT(*) as total,
        COUNT(CASE WHEN c.gender = 'M' THEN 1 END) as males,
        COUNT(CASE WHEN c.gender = 'F' THEN 1 END) as females
      FROM citizens c
      JOIN sudanese_states s ON c.state_code = s.code
      WHERE c.status = 'active'
    `;

    const params = [];
    let paramCount = 1;

    if (date_range) {
      const [start, end] = date_range.split(' to ');
      query += ` AND c.created_at BETWEEN $${paramCount} AND $${paramCount + 1}`;
      params.push(start, end);
      paramCount += 2;
    }

    query += ` GROUP BY c.state_code, s.name ORDER BY total DESC`;

    const result = await pool.query(query, params);
    return result.rows;
  }

  async getFormalizationRate(filters) {
    const { date_range, sector } = filters;

    // Calculate formalization rate (businesses / total potential)
    let query = `
      SELECT
        COUNT(DISTINCT b.oid) as formalized_businesses,
        COUNT(DISTINCT c.oid) as total_citizens,
        ROUND(
          (COUNT(DISTINCT b.oid)::float / NULLIF(COUNT(DISTINCT c.oid), 0)) * 100,
          2
        ) as formalization_rate
      FROM citizens c
      LEFT JOIN businesses b ON c.oid = b.owner_oid
      WHERE c.status = 'active'
    `;

    const params = [];
    let paramCount = 1;

    if (date_range) {
      const [start, end] = date_range.split(' to ');
      query += ` AND c.created_at BETWEEN $${paramCount} AND $${paramCount + 1}`;
      params.push(start, end);
      paramCount += 2;
    }

    if (sector) {
      query += ` AND b.business_type = $${paramCount}`;
      params.push(sector);
      paramCount++;
    }

    const result = await pool.query(query, params);
    return result.rows[0];
  }

  async getTaxRevenuePotential(filters) {
    const { date_range, business_type } = filters;

    // Estimate tax revenue based on business registrations
    let query = `
      SELECT
        COUNT(*) as business_count,
        AVG(
          CASE
            WHEN b.business_type = 'small' THEN 50000
            WHEN b.business_type = 'medium' THEN 200000
            WHEN b.business_type = 'large' THEN 1000000
            ELSE 100000
          END
        ) as avg_revenue,
        SUM(
          CASE
            WHEN b.business_type = 'small' THEN 50000
            WHEN b.business_type = 'medium' THEN 200000
            WHEN b.business_type = 'large' THEN 1000000
            ELSE 100000
          END
        ) as total_revenue_potential,
        SUM(
          CASE
            WHEN b.business_type = 'small' THEN 50000 * 0.15
            WHEN b.business_type = 'medium' THEN 200000 * 0.20
            WHEN b.business_type = 'large' THEN 1000000 * 0.25
            ELSE 100000 * 0.18
          END
        ) as tax_revenue_potential
      FROM businesses b
      WHERE b.status = 'active'
    `;

    const params = [];
    let paramCount = 1;

    if (date_range) {
      const [start, end] = date_range.split(' to ');
      query += ` AND b.created_at BETWEEN $${paramCount} AND $${paramCount + 1}`;
      params.push(start, end);
      paramCount += 2;
    }

    if (business_type) {
      query += ` AND b.business_type = $${paramCount}`;
      params.push(business_type);
      paramCount++;
    }

    const result = await pool.query(query, params);
    return result.rows[0];
  }

  async getSDG8Progress(filters) {
    // SDG 8: Decent Work and Economic Growth
    const { date_range } = filters;

    const result = await pool.query(`
      SELECT
        COUNT(DISTINCT b.oid) as formalized_businesses,
        COUNT(DISTINCT c.oid) as total_citizens,
        ROUND(
          (COUNT(DISTINCT b.oid)::float / NULLIF(COUNT(DISTINCT c.oid), 0)) * 100,
          2
        ) as formalization_rate,
        ROUND(
          (COUNT(DISTINCT b.oid)::float / NULLIF(COUNT(DISTINCT c.oid), 0)) * 25,
          2
        ) as target_8_3_progress
      FROM citizens c
      LEFT JOIN businesses b ON c.oid = b.owner_oid
      WHERE c.status = 'active'
      AND c.created_at >= NOW() - INTERVAL '1 year'
    `);

    return result.rows[0];
  }

  async getSDG16Progress(filters) {
    // SDG 16: Peace, Justice and Strong Institutions
    const { date_range } = filters;

    const result = await pool.query(`
      SELECT
        COUNT(*) as total_transactions,
        COUNT(CASE WHEN (detection_result->>'fraudDetected')::boolean = true THEN 1 END) as fraud_attempts,
        COUNT(CASE WHEN (detection_result->>'action'->>'type') = 'BLOCK' THEN 1 END) as blocked,
        ROUND(
          (COUNT(CASE WHEN (detection_result->>'action'->>'type') = 'BLOCK' THEN 1 END)::float /
           NULLIF(COUNT(*), 0)) * 100,
          2
        ) as fraud_prevention_rate
      FROM fraud_logs
      WHERE timestamp >= NOW() - INTERVAL '1 year'
    `);

    return result.rows[0];
  }

  async predictRegistrations(periods) {
    // Simple time series forecasting
    const historicalData = await pool.query(`
      SELECT
        DATE(created_at) as date,
        COUNT(*) as registrations
      FROM citizens
      WHERE created_at >= NOW() - INTERVAL '180 days'
      GROUP BY DATE(created_at)
      ORDER BY date
    `);

    const data = historicalData.rows;

    // Calculate moving average for forecasting
    const movingAverage = data.slice(-30).reduce((sum, d) => sum + d.registrations, 0) / 30;

    const forecast = [];
    for (let i = 1; i <= periods; i++) {
      const date = new Date();
      date.setDate(date.getDate() + i);

      // Add some seasonality (higher on weekdays, lower on weekends)
      const dayOfWeek = date.getDay();
      const seasonality = dayOfWeek === 0 || dayOfWeek === 6 ? 0.7 : 1.2;

      forecast.push({
        date: date.toISOString().split('T')[0],
        predicted: Math.round(movingAverage * seasonality),
        confidence: 0.85
      });
    }

    return forecast;
  }

  async predictFraudRisk(data) {
    // Simplified fraud risk prediction
    let riskScore = 0;

    if (data.ip_pattern === 'suspicious') riskScore += 0.3;
    if (data.data_consistency < 0.5) riskScore += 0.3;
    if (data.temporal_pattern === 'unusual') riskScore += 0.2;

    return {
      riskScore: Math.min(riskScore, 1.0),
      riskLevel: riskScore > 0.7 ? 'HIGH' : riskScore > 0.4 ? 'MEDIUM' : 'LOW',
      recommendations: riskScore > 0.7 ? ['Enhanced verification required'] : []
    };
  }

  async predictEconomicImpact(periods) {
    // Predict economic impact
    const currentMetrics = await this.getEconomicMetrics();

    const predictions = [];
    for (let i = 1; i <= periods; i++) {
      const growthRate = 0.05 + (Math.random() * 0.03); // 5-8% monthly growth
      const projected = {
        month: i,
        formalization_rate: currentMetrics.formalization_rate * (1 + growthRate * i),
        tax_revenue_potential: currentMetrics.tax_revenue_potential * (1 + growthRate * i * 1.2),
        job_creation: currentMetrics.job_creation * (1 + growthRate * i * 0.8)
      };

      predictions.push(projected);
    }

    return predictions;
  }

  async getEconomicMetrics() {
    const result = await pool.query(`
      SELECT
        COUNT(DISTINCT b.oid) as business_count,
        COUNT(DISTINCT c.oid) as citizen_count,
        ROUND(
          (COUNT(DISTINCT b.oid)::float / NULLIF(COUNT(DISTINCT c.oid), 0)) * 100,
          2
        ) as formalization_rate,
        SUM(
          CASE
            WHEN b.business_type = 'small' THEN 50000 * 0.15
            WHEN b.business_type = 'medium' THEN 200000 * 0.20
            WHEN b.business_type = 'large' THEN 1000000 * 0.25
            ELSE 100000 * 0.18
          END
        ) as tax_revenue_potential,
        COUNT(DISTINCT b.oid) * 2 as job_creation
      FROM citizens c
      LEFT JOIN businesses b ON c.oid = b.owner_oid
      WHERE c.status = 'active'
    `);

    return result.rows[0];
  }

  async applyAnalyticalModels(template, filters) {
    const predictions = {};

    if (template.type === 'economic_report') {
      const economicModel = this.analyticalModels.get('economic_impact_prediction');
      if (economicModel) {
        predictions.economic_impact = await economicModel.predict(12);
      }
    }

    if (template.type === 'sdg_report') {
      // Apply SDG prediction models
      predictions.sdg_forecast = await this.predictSDGProgress(filters);
    }

    return predictions;
  }

  async predictSDGProgress(filters) {
    // Predict SDG progress based on current trends
    const currentProgress = await this.getCurrentSDGProgress();

    const forecast = {};
    for (const [sdg, value] of Object.entries(currentProgress)) {
      forecast[sdg] = {
        current: value,
        projected_1year: value * 1.15, // 15% improvement
        projected_3year: value * 1.5, // 50% improvement
        target: 100
      };
    }

    return forecast;
  }

  async getCurrentSDGProgress() {
    const result = await pool.query(`
      SELECT
        ROUND(
          (COUNT(DISTINCT b.oid)::float / NULLIF(COUNT(DISTINCT c.oid), 0)) * 100,
          2
        ) as sdg_8,
        75 as sdg_9, -- Placeholder
        ROUND(
          (COUNT(DISTINCT c.oid)::float / NULLIF(45000000, 0)) * 100,
          2
        ) as sdg_10,
        ROUND(
          (COUNT(CASE WHEN (detection_result->>'fraudDetected')::boolean = false THEN 1 END)::float /
           NULLIF(COUNT(*), 0)) * 100,
          2
        ) as sdg_16,
        80 as sdg_17 -- Placeholder
      FROM citizens c
      LEFT JOIN businesses b ON c.oid = b.owner_oid
      LEFT JOIN fraud_logs f ON 1=1
      WHERE c.status = 'active'
    `);

    return result.rows[0];
  }

  async generateCharts(visualizationType, metrics) {
    const charts = [];

    switch (visualizationType) {
      case 'line_chart':
        charts.push({
          type: 'line',
          title: 'Registration Trends',
          data: metrics.total_registrations,
          x_axis: 'date',
          y_axis: 'registrations'
        });
        break;

      case 'bar_chart':
        charts.push({
          type: 'bar',
          title: 'Registrations by State',
          data: metrics.by_state,
          x_axis: 'state_name',
          y_axis: 'total'
        });
        break;

      case 'pie_chart':
        charts.push({
          type: 'pie',
          title: 'Fraud Detection Distribution',
          data: [
            { label: 'Legitimate', value: metrics.total_attempts - metrics.fraud_detected },
            { label: 'Fraud Detected', value: metrics.fraud_detected },
            { label: 'Blocked', value: metrics.blocked }
          ]
        });
        break;

      case 'radar_chart':
        charts.push({
          type: 'radar',
          title: 'SDG Progress',
          data: [
            { metric: 'SDG 8', value: metrics.sdg_8 },
            { metric: 'SDG 9', value: metrics.sdg_9 },
            { metric: 'SDG 10', value: metrics.sdg_10 },
            { metric: 'SDG 16', value: metrics.sdg_16 },
            { metric: 'SDG 17', value: metrics.sdg_17 }
          ]
        });
        break;

      case 'dashboard':
        charts.push({
          type: 'dashboard',
          title: 'System Performance',
          metrics: metrics
        });
        break;

      case 'multi_chart':
        charts.push({
          type: 'multi',
          title: 'Economic Impact',
          data: metrics
        });
        break;
    }

    return charts;
  }

  async generateTables(template, filters) {
    const tables = [];

    if (template.filters.includes('state')) {
      const stateData = await this.getRegistrationsByState(filters);
      tables.push({
        title: 'Registrations by State',
        columns: ['State Code', 'State Name', 'Total', 'Males', 'Females'],
        data: stateData.map(row => [
          row.state_code,
          row.state_name,
          row.total,
          row.males,
          row.females
        ])
      });
    }

    if (template.metrics.includes('by_business_type')) {
      const businessData = await this.getBusinessRegistrationsByType(filters);
      tables.push({
        title: 'Business Registrations by Type',
        columns: ['Business Type', 'Count', 'Percentage'],
        data: businessData.map(row => [
          row.business_type,
          row.count,
          `${row.percentage}%`
        ])
      });
    }

    return tables;
  }

  async formatReport(reportData, format) {
    switch (format) {
      case 'json':
        return reportData;

      case 'pdf':
        return await this.generatePDF(reportData);

      case 'excel':
        return await this.generateExcel(reportData);

      case 'csv':
        return await this.generateCSV(reportData);

      default:
        return reportData;
    }
  }

  async generatePDF(reportData) {
    // In production, use a PDF generation library like pdfkit
    // For now, return a simplified structure
    return {
      ...reportData,
      format: 'pdf',
      download_url: `/api/v1/reports/download/${uuidv4()}.pdf`
    };
  }

  async generateExcel(reportData) {
    // In production, use exceljs or similar
    return {
      ...reportData,
      format: 'excel',
      download_url: `/api/v1/reports/download/${uuidv4()}.xlsx`
    };
  }

  async generateCSV(reportData) {
    // Convert to CSV
    const csvData = [];

    // Add headers
    if (reportData.tables && reportData.tables.length > 0) {
      const table = reportData.tables[0];
      csvData.push(table.columns.join(','));

      // Add data rows
      table.data.forEach(row => {
        csvData.push(row.join(','));
      });
    }

    return {
      ...reportData,
      format: 'csv',
      csv_content: csvData.join('\n'),
      download_url: `/api/v1/reports/download/${uuidv4()}.csv`
    };
  }

  async storeReportAudit(reportType, filters, reportData) {
    await pool.query(
      `INSERT INTO report_audits
       (id, report_type, filters, report_data, generated_at)
       VALUES ($1, $2, $3, $4, $5)`,
      [
        uuidv4(),
        reportType,
        JSON.stringify(filters),
        JSON.stringify(reportData),
        new Date().toISOString()
      ]
    );
  }

  async getBusinessRegistrationsByType(filters) {
    const { date_range, business_type } = filters;

    let query = `
      SELECT
        b.business_type,
        COUNT(*) as count,
        ROUND(
          (COUNT(*)::float / SUM(COUNT(*)) OVER () * 100),
          2
        ) as percentage
      FROM businesses b
      WHERE b.status = 'active'
    `;

    const params = [];
    let paramCount = 1;

    if (date_range) {
      const [start, end] = date_range.split(' to ');
      query += ` AND b.created_at BETWEEN $${paramCount} AND $${paramCount + 1}`;
      params.push(start, end);
      paramCount += 2;
    }

    if (business_type) {
      query += ` AND b.business_type = $${paramCount}`;
      params.push(business_type);
      paramCount++;
    }

    query += ` GROUP BY b.business_type ORDER BY count DESC`;

    const result = await pool.query(query, params);
    return result.rows;
  }

  async getNewRegistrations(filters) {
    const { date_range } = filters;

    let query = `
      SELECT
        COUNT(*) as total,
        COUNT(CASE WHEN created_at >= NOW() - INTERVAL '7 days' THEN 1 END) as last_7_days,
        COUNT(CASE WHEN created_at >= NOW() - INTERVAL '30 days' THEN 1 END) as last_30_days
      FROM citizens
      WHERE status = 'active'
    `;

    const params = [];
    let paramCount = 1;

    if (date_range) {
      const [start, end] = date_range.split(' to ');
      query += ` AND created_at BETWEEN $${paramCount} AND $${paramCount + 1}`;
      params.push(start, end);
      paramCount += 2;
    }

    const result = await pool.query(query, params);
    return result.rows[0];
  }

  async calculateGrowthRate(filters) {
    const { date_range } = filters;

    // Calculate month-over-month growth
    const result = await pool.query(`
      WITH monthly_data AS (
        SELECT
          DATE_TRUNC('month', created_at) as month,
          COUNT(*) as registrations
        FROM citizens
        WHERE status = 'active'
        AND created_at >= NOW() - INTERVAL '12 months'
        GROUP BY DATE_TRUNC('month', created_at)
      ),
      lagged_data AS (
        SELECT
          month,
          registrations,
          LAG(registrations) OVER (ORDER BY month) as prev_month
        FROM monthly_data
      )
      SELECT
        month,
        registrations,
        prev_month,
        ROUND(
          ((registrations - prev_month)::float / NULLIF(prev_month, 0)) * 100,
          2
        ) as growth_rate
      FROM lagged_data
      ORDER BY month DESC
      LIMIT 12
    `);

    return result.rows;
  }

  async getFraudAttempts(filters) {
    const { date_range } = filters;

    let query = `
      SELECT
        COUNT(*) as total_attempts,
        COUNT(CASE WHEN (detection_result->>'fraudDetected')::boolean = true THEN 1 END) as fraud_detected,
        COUNT(CASE WHEN (detection_result->>'action'->>'type') = 'BLOCK' THEN 1 END) as blocked
      FROM fraud_logs
    `;

    const params = [];
    let paramCount = 1;

    if (date_range) {
      const [start, end] = date_range.split(' to ');
      query += ` WHERE timestamp BETWEEN $${paramCount} AND $${paramCount + 1}`;
      params.push(start, end);
      paramCount += 2;
    }

    const result = await pool.query(query, params);
    return result.rows[0];
  }

  async getApiResponseTimes(filters) {
    const { date_range, service } = filters;

    // In production, this would query monitoring data
    // For now, return simulated data
    return {
      avg_response_time: 150, // ms
      p95_response_time: 300, // ms
      p99_response_time: 500, // ms
      service: service || 'all'
    };
  }

  async getErrorRate(filters) {
    const { date_range, service } = filters;

    // In production, this would query monitoring data
    // For now, return simulated data
    return {
      error_rate: 0.5, // percentage
      total_requests: 10000,
      error_count: 50,
      service: service || 'all'
    };
  }

  async getUptime(filters) {
    const { date_range, service } = filters;

    // In production, this would query monitoring data
    // For now, return simulated data
    return {
      uptime_percentage: 99.9,
      total_time: 86400, // seconds in a day
      downtime: 86, // seconds
      service: service || 'all'
    };
  }

  async getRiskScoreDistribution(filters) {
    const { date_range } = filters;

    const result = await pool.query(`
      SELECT
        CASE
          WHEN (detection_result->>'riskScore')::numeric >= 0.9 THEN 'Very High'
          WHEN (detection_result->>'riskScore')::numeric >= 0.7 THEN 'High'
          WHEN (detection_result->>'riskScore')::numeric >= 0.5 THEN 'Medium'
          WHEN (detection_result->>'riskScore')::numeric >= 0.3 THEN 'Low'
          ELSE 'Very Low'
        END as risk_level,
        COUNT(*) as count,
        ROUND(
          (COUNT(*)::float / SUM(COUNT(*)) OVER () * 100),
          2
        ) as percentage
      FROM fraud_logs
      WHERE timestamp >= NOW() - INTERVAL '30 days'
      GROUP BY risk_level
      ORDER BY count DESC
    `);

    return result.rows;
  }

  async getJobCreation(filters) {
    const { date_range } = filters;

    // Estimate job creation based on business registrations
    const result = await pool.query(`
      SELECT
        COUNT(*) as businesses,
        COUNT(*) * 2 as estimated_jobs,
        COUNT(CASE WHEN business_type = 'small' THEN 1 END) * 1 as small_jobs,
        COUNT(CASE WHEN business_type = 'medium' THEN 1 END) * 5 as medium_jobs,
        COUNT(CASE WHEN business_type = 'large' THEN 1 END) * 20 as large_jobs
      FROM businesses
      WHERE status = 'active'
    `);

    return result.rows[0];
  }

  async getGDPContribution(filters) {
    // Estimate GDP contribution
    const economicMetrics = await this.getEconomicMetrics();

    return {
      tax_revenue_potential: economicMetrics.tax_revenue_potential,
      formalization_rate: economicMetrics.formalization_rate,
      estimated_gdp_contribution: economicMetrics.tax_revenue_potential * 4, // Multiplier
      confidence: 0.8
    };
  }
}

const reportingEngine = new ReportingAnalyticsEngine();

// API Endpoints

// Generate report
app.post('/api/v1/reports/generate', async (req, res) => {
  try {
    const { reportType, filters, format } = req.body;

    if (!reportType) {
      return res.status(400).json({ error: 'Missing reportType' });
    }

    const report = await reportingEngine.generateReport(reportType, filters || {}, format || 'json');

    res.json({
      success: true,
      report,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Report generation error', { error: error.message });
    res.status(500).json({ error: 'Report generation failed' });
  }
});

// Get available report templates
app.get('/api/v1/reports/templates', async (req, res) => {
  try {
    const templates = Array.from(reportingEngine.reportTemplates.values()).map(t => ({
      type: t.name,
      description: t.type,
      metrics: t.metrics,
      frequency: t.frequency,
      formats: t.format
    }));

    res.json({
      success: true,
      templates,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Templates error', { error: error.message });
    res.status(500).json({ error: 'Failed to get templates' });
  }
});

// Get report history
app.get('/api/v1/reports/history', async (req, res) => {
  try {
    const { limit = 50 } = req.query;

    const result = await pool.query(
      `SELECT id, report_type, generated_at,
              jsonb_array_length(filters) as filter_count
       FROM report_audits
       ORDER BY generated_at DESC
       LIMIT $1`,
      [limit]
    );

    res.json({
      success: true,
      history: result.rows,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('History error', { error: error.message });
    res.status(500).json({ error: 'Failed to get history' });
  }
});

// Schedule automated report
app.post('/api/v1/reports/schedule', async (req, res) => {
  try {
    const { reportType, filters, schedule, recipients } = req.body;

    if (!reportType || !schedule) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    // Store schedule in database
    const scheduleId = uuidv4();
    await pool.query(
      `INSERT INTO report_schedules
       (id, report_type, filters, schedule, recipients, status, created_at)
       VALUES ($1, $2, $3, $4, $5, 'active', $6)`,
      [
        scheduleId,
        reportType,
        JSON.stringify(filters || {}),
        JSON.stringify(schedule),
        JSON.stringify(recipients || []),
        new Date().toISOString()
      ]
    );

    res.json({
      success: true,
      scheduleId,
      message: 'Report scheduled successfully',
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Schedule error', { error: error.message });
    res.status(500).json({ error: 'Failed to schedule report' });
  }
});

// Health check
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    service: 'Reporting Analytics Engine',
    timestamp: new Date().toISOString(),
    version: '1.0.0',
    reportTemplates: reportingEngine.reportTemplates.size,
    analyticalModels: reportingEngine.analyticalModels.size
  });
});

const PORT = process.env.PORT || 3013;
app.listen(PORT, () => {
  logger.info(`Reporting Analytics Engine running on port ${PORT}`);
  console.log(`Reporting Analytics Engine running on port ${PORT}`);
});

module.exports = app;
 
4. AUTOMATED COMPLIANCE & AUDIT ENGINE
 
Module Overview
Automated compliance checking, audit trail generation, and regulatory reporting for Sudanese laws and international standards.
 
File: backend/compliance-audit-engine/src/app.js
javascript
javascript
const express = require('express');
const { Pool } = require('pg');
const Redis = require('ioredis');
const { Kafka } = require('kafkajs');
const winston = require('winston');
const { v4: uuidv4 } = require('uuid');
const crypto = require('crypto');
const fs = require('fs').promises;
const path = require('path');

const app = express();
app.use(express.json());

// Database connection
const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: process.env.DB_PORT
});

// Redis for caching
const redis = new Redis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD
});

// Kafka for event streaming
const kafka = new Kafka({
  clientId: 'compliance-audit-engine',
  brokers: process.env.KAFKA_BROKERS?.split(',') || ['localhost:9092']
});

// Logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'compliance-errors.log', level: 'error' }),
    new winston.transports.File({ filename: 'compliance-comOwner exists inbined.log' })
  ]
});

// Compliance & Audit Engine
class ComplianceAuditEngine {
  constructor() {
    this.complianceRules = new Map();
    this.auditTrail = [];
    this.initializeComplianceRules();
  }

  initializeComplianceRules() {
    // Sudanese Legal Compliance Rules
    this.complianceRules.set('sudanese_electronic_transactions', {
      name: 'Electronic Transactions Act 2007',
      requirements: [
        {
          id: 'ET-001',
          description: 'Digital signatures must be legally recognized',
          check: async (data) => {
            return {
              passed: data.digital_signature !== undefined,
              evidence: data.digital_signature ? 'Digital signature present' : 'Digital signature missing'
            };
          }
        },
        {
          id: 'ET-002',
          description: 'Data retention for 7 years',
          check: async (data) => {
            const retentionDate = new Date();
            retentionDate.setFullYear(retentionDate.getFullYear() - 7);
            const createdDate = new Date(data.created_at);
            return {
              passed: createdDate <= retentionDate,
              evidence: `Data created: ${createdDate.toISOString()}`
            };
          }
        },
        {
          id: 'ET-003',
          description: 'Secure storage of personal data',
          check: async (data) => {
            const hasEncryption = data.encryption_algorithm !== undefined;
            const hasAccessControl = data.access_control !== undefined;
            return {
              passed: hasEncryption && hasAccessControl,
              evidence: `Encryption: ${hasEncryption}, Access Control: ${hasAccessControl}`
            };
          }
        }
      ]
    });

    this.complianceRules.set('sudanese_civil_registry', {
      name: 'Civil Registry Act 1994',
      requirements: [
        {
          id: 'CR-001',
          description: 'Birth registration within 30 days',
          check: async (data) => {
            if (data.entity_type !== 'citizen') return { passed: true, evidence: 'Not applicable' };

            const birthDate = new Date(data.date_of_birth);
            const registrationDate = new Date(data.created_at);
            const daysDiff = Math.floor((registrationDate - birthDate) / (1000 * 60 * 60 * 24));

            return {
              passed: daysDiff <= 30,
              evidence: `Registration within ${daysDiff} days of birth`
            };
          }
        },
        {
          id: 'CR-002',
          description: 'Unique National ID assignment',
          check: async (data) => {
            if (data.entity_type !== 'citizen') return { passed: true, evidence: 'Not applicable' };

            const nationalId = data.national_id;
            const isUnique = await this.checkNationalIdUniqueness(nationalId);

            return {
              passed: isUnique,
              evidence: isUnique ? 'National ID is unique' : 'National ID already exists'
            };
          }
        }
      ]
    });

    this.complianceRules.set('sudanese_business_l passed: monthsSinceaw', {
      name: 'Business Registration Act 2015',
      requirements: [
        {
          id: 'BR-001',
          description: 'Business registration number format',
          check: async (data) => {
            if (data.entity_type !== 'business') return { passed: true, evidence: 'Not applicable' };

            const regNumber = data.registration_number;
            const isValidFormat = /^SD-[A-Z0-9]{5}$/.test(regNumber);

            return {
              passed: isValidFormat,
              evidence: isValidFormat ? 'Valid format: SD-XXXXX' : 'Invalid format'
            };
          }
        },
        {
          id: 'BR-002',
          description: 'Owner must be registered citizen',
          check: async (data) => {
            if (data.entity_type !== 'business') return { passed: true, evidence: 'Not applicable' };

            const ownerOid = data.owner_oid;
            const ownerExists = await this.checkCitizenExists(ownerOid);

            return {
              passed: ownerExists,
              evidence: ownerExists ? ' systemPolicy = data.privacy_policy_version !== undefined;

            return {
              passed: hasConsent && hasClearPolicy,
              evidence: `Consent: ${hasConsent}, Policy: ${hasClearPolicy}`
            };
          }
        },
        {
          id: 'DP-002',
          description: 'Purpose limitation',
          check: async (data) => {
            const hasPurpose = data.purpose !== undefined;
            const purposeIsSpecific = data.purpose && data.purpose.length > 0;

            return {
              passed: hasPurpose && purposeIsSpecific,
              evidence: `Purpose defined: ${hasPurpose}`
            };
          }
        },
        {
          id: 'DP-003',
          description: 'Data minimization',
          check: async (data) => {
            // Check if only necessary fields are collected
            const necessaryFields = ['national_id', 'first_name', 'last_name', 'date_of_birth', 'phone_number'];
            const collectedFields = Object.keys(data);
            const unnecessaryFields = collectedFields.filter(f => !necessaryFields.includes(f));

            return {
              passed: unnecessaryFields.length === 0,
              evidence: `Unnecessary fields: ${unnecessaryFields.join(', ') || 'None'}`
            };
          }
        },
        {
          id: 'DP-004',
          description: 'Accuracy and data quality',
          check: async (data) => {
            // Check data quality score
            const qualityScore = data.quality_score || 0;

            return {
              passed: qualityScore >= 0.7,
              evidence: `Quality score: ${qualityScore}`
            };
          }
        }
      ]
    });

    this.complianceRules.set('cybersecurity', {
      name: 'Sudanese Cybersecurity Standards',
      requirements: [
        {
          id: 'CS-001',
          description: 'Secure authentication',
          check: async (data) => {
            const has2FA = data.two_factor_enabled === true;
            const hasStrongPassword = data.password_strength >= 3; // 1-5 scale

            return {
              passed: has2FA &&    const exists hasStrongPassword,
              evidence: `2FA: ${has2FA}, Password strength: ${data.password_strength}`
            };
          }
        },
        {
          id: 'CS-002',
          description: 'Encrypted data transmission',
          check: async (data) => {
            const isEncrypted = data.encryption_protocol !== undefined;

            return {
              passed: isEncrypted,
              evidence: isEncrypted ? `Protocol: ${data.encryption_protocol}` : 'Not encrypted'
            };
          }
        },
        {
          id: 'CS-003',
          description: 'Regular security audits',
          check: async (data) => {
            const lastAudit = data.last_security_audit;
            if (!lastAudit) return { passed: false, evidence: 'No security audit performed' };

            const auditDate = new Date(lastAudit);
            const monthsSinceAudit = (new Date() - auditDate) / (1000 * 60 * 60 * 24 * 30);

            return {
             Audit <= 6 evidence: result.evidence
          });

          if (!result.passed) {
            overallCompliance = false;
            complianceScore -= 0.1;
          }
        } catch (error) {
          logger.error(`Compliance check failed for ${requirement.id}`, { error: error.message });
          ruleResults.push({
            requirementId: requirement.id,
            description: requirement.description,
            passed: false,
            evidence: `Check failed: ${error.message}`
          });
          overallCompliance = false;
          complianceScore -= 0.15;
        }
      }

      complianceResults.push({
        rule: rule.name,
        ruleName: ruleName,
        requirements: ruleResults,
        complianceRate: this.calculateComplianceRate(ruleResults)
      });
    }

    // Calculate overall compliance score
    complianceScore = Math.max(0, complianceScore);

    return {
      overallCompliance,
      complianceScore,
      complianceLevel: this.getComplianceLevel(complianceScore),
      complianceResults,
      timestamp: new Date().toISOString(),
      context: {
        entityType,
        ...context
      }
    };
  }

  getApplicableRules(entityType, context) {
    const rules = [];

    // Always apply data protection rules
    rules.push('data_protection');

    if (entityType === 'citizen') {
      rules.push('sudanese_electronic_transactions', 'sudanese_civil_registry');
    } else if (entityType === 'business') {
      rules.push('sudanese_electronic_transactions', 'sudanese_business_law');
    }

    // Apply cybersecurity rules if it's a system operation
    if (context.operation === 'system') {
      rules.push('cybersecurity');
    }

    return rules;
  }

  calculateComplianceRate(requirements) {
    const passed = requirements.filter(r => r.passed).length;
    const total = requirements.length;
    return total > 0 ? (passed / total) * 100 : 100;
  }

  getComplianceLevel(score) {
    if (score >= 0.9) return 'A+';
    if (score >= 0.8) return complianceCheck,
      'A';
    if (score >= 0.7) return 'B+';
    if (score >= 0.6) return 'B';
    if (score >= 0.5) return 'C';
    return 'D';
  }

  async checkNationalIdUniqueness(nationalId) {
    const cacheKey = `national_id:${nationalId}`;
    const cached = await redis.get(cacheKey);
    if (cached) return false;

    const result = await pool.query(
      'SELECT COUNT(*) FROM citizens WHERE national_id = $1',
      [nationalId]
    );

    const isUnique = parseInt(result.rows[0].count) === 0;
    if (isUnique) {
      await redis.setex(cacheKey, 3600, 'exists');
    }

    return isUnique;
  }

  async checkCitizenExists(oid) {
    const cacheKey = `citizen:${oid}`;
    const cached = await redis.get(cacheKey);
    if (cached) return true;

    const result = await pool.query(
      'SELECT COUNT(*) FROM citizens WHERE oid = $1',
      [oid]
    );

 = parseInt(result.rowsail
       (id, timestamp, event, data, user, context, ip_address, user_agent, hash)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,
      [
        auditEntry.id,
        auditEntry.timestamp,
        auditEntry.event,
        JSON.stringify(auditEntry.data),
        JSON.stringify(auditEntry.user),
        JSON.stringify(auditEntry.context),
        auditEntry.ipAddress,
        auditEntry.userAgent,
        auditEntry.hash
      ]
    );

    // Publish to Kafka for real-time monitoring
    const producer = kafka.producer();
    await producer.connect();
    await producer.send({
      topic: 'audit-events',
      messages: [{ value: JSON.stringify(auditEntry) }]
    });
    await producer.disconnect();

    // Store in blockchain (simulated)
    await this.storeInBlockchain(auditEntry);

    this.auditTrail.push(auditEntry);

    // Keep only last 1000 entries in memory
    if (this.auditTrail.length > 1000) {
      this.auditTrail = this.auditTrail.slice(-1000);
    }

    return auditEntry;
  }

  calculateHash(event, data, user, context) {
    const dataToHash = JSON.stringify({
      event,
      data: this.anonymizeData(data),
      user: user ? this.anonymizeUser(user) : null,
      context,
      timestamp: new Date().toISOString()
    });

    return crypto.createHash('sha256').update(dataToHash).digest('hex');
  }

  async storeInBlockchain(auditEntry) {
    // Simulate blockchain storage
    // In production, this would connect to a blockchain network
    const blockchainEntry = {
      ...auditEntry,
      blockchain: 'simulated',
      blockNumber: this.auditTrail.length,
      previousHash: this.auditTrail.length > 0 ? this.auditTrail[this.auditTrail.length - 1].hash : '0',
      merkleRoot: crypto.createHash('sha256').update(JSON.stringify(auditEntry)).digest('6')
      .hex')
    };

    // Store in file for persistence
    try {
      const blockchainDir = path.join(__dirname, 'blockchain');
      await fs.mkdir(blockchainDir, { recursive: true });

      const blockFile = path.join(blockchainDir, `block_${blockchainEntry.blockNumber}.json`);
      await fs.writeFile(blockFile, JSON.stringify(blockchainEntry, null, 2));

      logger.info(`Blockchain entry stored: block ${blockchainEntry.blockNumber}`);
    } catch (error) {
      logger.error('Failed to store blockchain entry', { error: error.message });
    }

    return blockchainEntry;
  }

  async generateComplianceReport(entityData, entityType, context) {
    const complianceCheck = await this.checkCompliance(entityData, entityType, context);

    // Generate detailed report
    const report = {
      reportId: uuidv4(),
      generatedAt: new Date().toISOString(),
      entityType,
      context,
      compliance: recommendations 10 audit entries
      signature: this.signReport(complianceCheck)
    };

    // Store report
    await pool.query(
      `INSERT INTO compliance_reports
       (id, entity_type, context, compliance_data, recommendations, signature, generated_at)
       VALUES ($1, $2, $3, $4, $5, $6, $7)`,
      [
        report.reportId,
        entityType,
        JSON.stringify(context),
        JSON.stringify(report.compliance),
        JSON.stringify(report.recommendations),
        report.signature,
        report.generatedAt
      ]
    );

    return report;
  }

  generateRecommendations(complianceCheck) {
    const recommendations = [];

    if (!complianceCheck.overallCompliance) {
      complianceCheck.complianceResults.forEach(ruleResult => {
        ruleResult.requirements.forEach(req => {
          if (!req.passed) {
            recommendations.push({
              requirementId: req.requirementId,
              description: req.description,
              recommendation: this.getRecommendation(req.requirementId),
              priority: 'HIGH'
            });
          }
        });
      });
    }

    // Add proactive recommendations
    if (complianceCheck.complianceScore < 0.8) {
      recommendations.push({
        requirementId: 'GENERAL-001',
        description: 'Overall compliance score below 80%',
        recommendation: 'Review all compliance requirements and implement missing controls',
        priority: 'MEDIUM'
      });
    }

    return recommendations;
  }

  getRecommendation(requirementId) {
    const recommendations = {
      'ET-001': 'Implement digital signature verification using Sudanese approved algorithms',
      'ET-002': 'Configure data retention policies to meet 7-year requirement',
      'ET-003': 'Implement encryption at rest and in transit using AES-256',
      'CR-001': 'Implement automated birth registration workflow',
      'CR-002': 'Enhance National ID validation and uniqueness checks',
      'BR-001': 'Update business registration number validation',
      'BR-0018
       2': 'Add citizen verification before business registration',
      'DP-001': 'Implement clear consent mechanism and privacy policy',
      'DP-002': 'Define and document data processing purposes',
      'DP-003': 'Review data collection forms and remove unnecessary fields',
      'DP-004': 'Implement data quality checks and validation',
      'CS-001': 'Enable two-factor authentication for all users',
      'CS-002': 'Implement TLS 1.3 for all data transmission',
      'CS-003': 'Schedule quarterly security audits'
    };

    return recommendations[requirementId] || 'Review compliance requirements';
  }

  signReport(complianceCheck) {
    const dataToSign = JSON.stringify({
      complianceScore: complianceCheck.complianceScore,
      timestamp: new Date().toISOString(),
      entityId: complianceCheck.context?.entityId
    });

    return crypto.createSign('RSA-SHA25update(dataToSignDACTED***';
      }
    });

    return anonymized;
  }

  anonymizeUser(user) {
    if (!user) return null;

    return {
      oid: user.oid,
      role: user.role,
      // Other sensitive fields would be redacted
    };
  }

  async generateRegulatoryReport(regulator, period) {
    // Generate report for specific regulator
    const report = {
      regulator,
      period,
      generatedAt: new Date().toISOString(),
      data: {}
    };

    // Get relevant data
    if (regulator === 'MOJ') { // Ministry of Justice
      report.data = await this.getJusticeReport(period);
    } else if (regulator === 'MOT') { // Ministry of Trade
      report.data = await this.getTradeReport(period);
    } else if (regulator === 'MOF') { // Ministry of Finance
      report.data = await this.getFinanceReport(period);
    } else if (regulator === 'NITC') { // National IT Commission
      report.data = await this.getITCReport(period);
    }

    // Add digital signature
    report.signature = this.signReport(report);

    return report;
  }

  async getJusticeReport(period) {
    const result = await pool.query(`
      SELECT
        COUNT(*) as total_citizens,
        COUNT(CASE WHEN compliance_score >= 0.8 THEN 1 END) as compliant_citizens,
        COUNT(CASE WHEN compliance_score < 0.8 THEN 1 END) as non_compliant_citizens,
        AVG(compliance_score) as avg_compliance_score
      FROM compliance_reports
      WHERE entity_type = 'citizen'
      AND generated_at >= NOW() - INTERVAL '${period}'
    `);

    return result.rows[0];
  }

  async getTradeReport(period) {
    const result = await pool.query(`
      SELECT
        COUNT(DISTINCT b.oid) as total_businesses,
        COUNT(DISTINCT b.oid) FILTER];

    return {
 (WHERE c.compliance_score >= 0.8) as compliant_businesses,
        COUNT(DISTINCT b.oid) FILTER (WHERE c.compliance_score < 0.8) as non_compliant_businesses,
        AVG(c.compliance_score) as avg_compliance_score
      FROM businesses b
      JOIN compliance_reports c ON b.oid = c.context->>'entityId'
      WHERE c.entity_type = 'business'
      AND c.generated_at >= NOW() - INTERVAL '${period}'
    `);

    return result.rows[0];
  }

  async getFinanceReport(period) {
    const result = await pool.query(`
      SELECT
        COUNT(DISTINCT b.oid) as total_businesses,
        SUM(CASE
          WHEN b.business_type = 'small' THEN 50000 * 0.15
          WHEN b.business_type = 'medium' THEN 200000 * 0.20
          WHEN b.business_type = 'large' THEN 1000000 * 0.25
          ELSE 100000 * 0. END) as estimated];
  }

  async getITCReport(period) {
    const result = await pool.query(`
      SELECT
        COUNT(DISTINCT user_oid) as total_users,
        COUNT(DISTINCT user_oid) FILTER (WHERE two_factor_enabled = true) as users_with_2fa,
        COUNT(DISTINCT user_oid) FILTER (WHERE password_strength >= 3) as users_with_strong_passwords,
        ROUND(
          (COUNT(DISTINCT user_oid) FILTER (WHERE two_factor_enabled = true)::float /
           NULLIF(COUNT(DISTINCT user_oid), 0)) * 100,
          2
        ) as two_factor_adoption_rate
      FROM user_security_settings
      WHERE created_at >= NOW() - INTERVAL '${period}'
    `);

    return result.rows[0];
  }

  async monitorComplianceContinuous() {
    // Continuous compliance monitoring
    const checks = [
      this.checkSystemSecurity(),
      this.checkDataRetention(),
      this.checkAccessControls(),
      this.checkAuditTrailIntegrity()
    ];

    const results = await Promise.all(checks);

    const summary = {
      timestamp: new Date().toISOString(),
      checks: results,
      overallStatus: results.every(r => r.passed) ? 'PASS' : 'FAIL'
    };

    // Log any failures
    const failures = results.filter(r => !r.passed);
    if (failures.length > 0) {
      logger.warn('Compliance monitoring failures', { failures });

      // Send alerts for critical failures
      if (failures.some(f => f.severity === 'HIGH')) {
        await this.sendComplianceAlert(failures);
      }
    }

    return summary;
  }

  async checkSystemSecurity() {
    // Check system security controls
    const result = await pool.query(`
      SELECT
        COUNT(CASE WHEN two_factor_enabled = true THEN 1 END) as users_with_2fa,
        COUNT(*) as total_users,
        COUNT.message });
    res(CASE WHEN last_password_change < NOW() - INTERVAL '90 days' THEN 1 END) as expired_passwords
      FROM user_security_settings
    `);

    const data = result.rows[0];
    const twoFactorRate = data.total_users > 0 ?
      (data.users_with_2fa / data.total_users) * 100 : 0;

    return {
      check: 'SYSTEM_SECURITY',
      passed: twoFactorRate >= 80 && data.expired_passwords === 0,
      severity: twoFactorRate < 80 ? 'MEDIUM' : 'LOW',
      details: {
        twoFactorRate: `${twoFactorRate.toFixed(1)}%`,
        expiredPasswords: data.expired_passwords
      }
    };
  }

  async checkDataRetention() {
    // Check data retention compliance
    const result = await pool.query(`
      SELECT
        COUNT(*) as total_records,
        COUNT(CASE WHEN created_at < NOW() - INTERVAL '7 years' THEN 1 END) as expired_records
      FROM citizens
    `);

    const data = result.rows[0      check: ' // Check access control compliance
    const result = await pool.query(`
      SELECT
        COUNT(DISTINCT user_oid) as users_with_access,
        COUNT(DISTINCT user_oid) FILTER (WHERE role = 'admin') as admin_users,
        COUNT(DISTINCT user_oid) FILTER (WHERE role = 'government_staff') as gov_users
      FROM user_roles
    `);

    const data = result.rows[0];

    return {
      check: 'ACCESS_CONTROLS',
      passed: data.admin_users <= 10, // Limit admin users
      severity: data.admin_users > 10 ? 'HIGH' : 'LOW',
      details: {
        adminUsers: data.admin_users,
        govUsers: data.gov_users
      }
    };
  }

  async checkAuditTrailIntegrity() {
    // Check audit trail integrity
    const result = await pool.query(`
      SELECT
        COUNT(*) as total_audits,
        COUNT(CASE WHEN hash IS NULL THEN 1 END) as missing_hashes,
        COUNT(CASE WHEN blockchain_hash IS NULL THEN 1 END) as missing_blockchain
      FROM audit_trail
      WHERE timestamp > NOW() - INTERVAL '24 hours'
    `);

    const data = result.rows[0];

    return {
      check: 'AUDIT_TRAIL_INTEGRITY',
      passed: data.missing_hashes === 0 && data.missing_blockchain === 0,
      severity: (data.missing_hashes > 0 || data.missing_blockchain > 0) ? 'HIGH' : 'LOW',
      details: {
        totalAudits: data.total_audits,
        missingHashes: data.missing_hashes,
        missingBlockchain: data.missing_blockchain
      }
    };
  }

  async sendComplianceAlert(failures) {
    // Send compliance alert
    const alert = {
      id: uuidv4(),
      timestamp: new Date().toISOString(),
      type: 'COMPLIANCE_ALERT',
      severity: 'HIGH',
      failures: failures,
      message: 'Critical compliance failures detected'
    };

    // Send to notification service
    const producer = kafka.producer();
    await producer.connect();
    await producer.send({
 PORT = process.env      topic: 'compliance-alerts',
      messages: [{ value: JSON.stringify(alert) }]
    });
    await producer.disconnect();

    return alert;
  }
}

const complianceEngine = new ComplianceAuditEngine();

// API Endpoints

// Check compliance
app.post('/api/v1/compliance/check', async (req, res) => {
  try {
    const { entityData, entityType, context } = req.body;

    if (!entityData || !entityType) {
      return res.status(400).json({ error: 'Missing entityData or entityType' });
    }

    const complianceCheck = await complianceEngine.checkCompliance(entityData, entityType, context);

    // Generate audit trail
    await complianceEngine.generateAuditTrail(
      'COMPLIANCE_CHECK',
      entityData,
      req.user,
      { ...context, ip_address: req.ip, user_agent: req.get('User-Agent') }
    );

    res.json({
      success: true,
      ...complianceCheck,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Compliance check error', { error: error.status(50
app.post('/api/v1/compliance/report', async (req, res) => {
  try {
    const { entityData, entityType, context } = req.body;

    if (!entityData || !entityType) {
      return res.status(400).json({ error: 'Missing entityData or entityType' });
    }

    const report = await complianceEngine.generateComplianceReport(entityData, entityType, context);

    res.json({
      success: true,
      report,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Compliance report error', { error: error.message });
    res.status(500).json({ error: 'Report generation failed' });
  }
});

// Generate regulatory report
app.post('/api/v1/compliance/regulatory-report', async (req, res) => {
  try {
    const { regulator, period } = req.body;

    if (!regulator) {
      return res.status(400).json({ error: 'Missing regulator' });
    }

    const report = await complianceEngine.generateRegulatoryReport(regulator, period || '1 year');

    res.json({
      success: true,
      report,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Regulatory report error', { error: error.message });
    res.status(500).json({ error: 'Regulatory report failed' });
  }
});

// Continuous compliance monitoring
app.get('/api/v1/compliance/monitor', async (req, res) => {
  try {
    const summary = await complianceEngine.monitorComplianceContinuous();

    res.json({
      success: true,
      summary,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Compliance monitoring error', { error: error.message });
    res.status(500).json({ error: 'Monitoring failed' });
  }
});

// Get compliance history
app.get('/api/v1/compliance/history', async (req, res) => {
  try {
    const { limit = 50, entityType } = req.query;

    let query = `
      SELECT id, entity_type, compliance_score, compliance_level, generated_at
      FROM compliance_reports
      ORDER BY generated_at DESC
      LIMIT $1
    `;

    const params = [limit];

    if (entityType) {
      query = `
        SELECT id, entity_type, compliance_score, compliance_level, generated_at
        FROM compliance_reports
        WHERE entity_type = $2
        ORDER BY generated_at DESC
        LIMIT $1
      `;
      params.push(entityType);
    }

    const result = await pool.query(query, params);

    res.json({
      success: true,
      history: result.rows,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Compliance history error', { error: error.message });
    res.status(500).json({ error: 'Failed to get history' });
  }
});

// Health check
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    service: 'Compliance Audit Engine',
    timestamp: new Date().toISOString(),
    version: '1.0.0',
    complianceRules: complianceEngine.complianceRules.size,
    auditTrailLength: complianceEngine.auditTrail.length
  });
});

const.PORT || 3pliance Audit Engine running on port ${PORT}`);
  console.log(`Compliance Audit Engine running on port ${PORT}`);
});

module.exports = app;
 
5. AUTOMATED BACKUP & DISASTER RECOVERY SYSTEM
 
Module Overview
Automated backup, recovery testing, and disaster recovery orchestration with multi-region redundancy.
 
File: backend/backup-recovery-system/src/app.js
javascript
javascript
const express = require('express');
const { Pool } = require('pg');
const Redis = require('ioredis');
const { Kafka } = require('kafkajs');
const winston = require('winston');
const { v4: uuidv4 } = require('uuid');
const fs = require('fs').promises;
const path = require('path');
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);
const tar = require('tar');
const AWS = require('aws-sdk');
const axios = require('axios');

const app = express();
app.use(express.json());

// Database connection
const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: process.env.DB_PORT
});

// Redis for caching
const redis = new Redis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD
});

// Kafka for event streaming
const kafka = new Kafka({
  clientId: 'backup-recovery-system',
  brokers: process.env.KAFKA_BROKERS?.split(',') || ['localhost:9092']
});

// AWS S3 configuration (for off-site backups)
const s3 = new AWS.S3({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_REGION || 'us-east-1'
});

// Logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'backup-errors.log', level: 'error' }),
    new winston Store.transports.File({ filename: 'backup-combined.log' })
  ]
});

// Backup & Recovery System
class BackupRecoverySystem {
  constructor() {
    this.backupConfig = {
      fullBackupSchedule: '0 2 * * 0', // Weekly on Sunday at 2 AM
      incrementalSchedule: '0 2 * * *', // Daily at 2 AM
      retentionDays: 90,
      compression: 'gzip',
      encryption: 'aes-256-gcm'
    };

    this.recoveryPointObjective = 15; // minutes
    this.recoveryTimeObjective = 4; // hours

    this.initializeBackupJobs();
  }

  initializeBackupJobs() {
    // Initialize backup jobs
    this.jobs = {
      fullBackup: {
        name: 'Full Database Backup',
        schedule: this.backupConfig.fullBackupSchedule,
        lastRun: null,
        status: 'pending'
      },
      incrementalBackup: {
        name: 'Incremental Backup',
        schedule: this.backupConfig.incrementalSchedule,
        lastRun: null,
        status: 'pending'
      },
      fileBackup: {
        name: 'File System Backup',
        schedule: '0 3 * * *', // Daily at 3 AM
        lastRun: null,
        status: 'pending'
      },
      logBackup: {
        name: 'Log Backup',
        schedule: '0 * * * *', // Hourly
        lastRun: null,
        status: 'pending'
      }
    };
  }

  async createBackup(type = 'incremental', options = {}) {
    const backupId = uuidv4();
    const timestamp = new Date().toISOString();

    const backupInfo = {
      id: backupId,
      type,
      timestamp,
      status: 'in_progress',
      progress: 0,
      details: {},
      size: 0,
      checksum: null,
      encrypted: true,
      location: 'local'
    };

    logger.info(`Starting ${type} backup`, { backupId });

    try {
      // Update progress
      backupInfo.progress = 10;
      await this.updateBackupStatus(backupId, backupInfo);

      // Create backup directory
      const backupDir = path.join(__dirname, 'backups', backupId);
      await fs.mkdir(backupDir, { recursive: true });

      // Backup based on type
      if (type === 'full' || type === 'incremental') {
        await this.backupDatabase(backupDir, type, backupInfo);
      }

      if (type === 'full' || options.includeFiles) {
        await this.backupFiles(backupDir, backupInfo);
      }

      if (type === 'full' || options.includeLogs) {
        await this.backupLogs(backupDir, backupInfo);
      }

      // Compress backup
      backupInfo.progress = 70;
      await this.updateBackupStatus(backupId, backupInfo);

      const compressedFile = await this.compressBackup(backupDir, backupInfo);

      // Encrypt backup
      backupInfo.progress = : fileBackupDir80;
      await this.updateBackupStatus(backupId, backupInfo);

      const encryptedFile = await this.encryptBackup(compressedFile, backupInfo);

      // Calculate checksum
      backupInfo.progress = 90;
      await this.updateBackupStatus(backupId, backupInfo);

      backupInfo.checksum = await this.calculateChecksum(encryptedFile);

      // Upload to off-site storage (S3)
      if (type === 'full') {
        backupInfo.progress = 95;
        await this.updateBackupStatus(backupId, backupInfo);

        const s3Url = await this.uploadToS3(encryptedFile, backupId);
        backupInfo.location = s3Url;
        backupInfo.offsite = true;
      }

      // Cleanup temporary files
      await this.cleanupTempFiles(backupDir);

      // Update final status
      backupInfo.status = 'completed';
      backupInfo.progress = 100;
      backupInfo.size = (await fs.stat(encryptedFile)).size;
      await this.updateBackupStatus(backupId, backupInfo);

      // backup metadata error;
    }
  }

  async backupDatabase(backupDir, type, backupInfo) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupFile = path.join(backupDir, `database_${type}_${timestamp}.sql`);

    const dbConfig = {
      host: process.env.DB_HOST,
      port: process.env.DB_PORT,
      user: process.env.DB_USER,
      database: process.env.DB_NAME
    };

    if (type === 'full') {
      // Full backup using pg_dump
      const command = `pg_dump -h ${dbConfig.host} -p ${dbConfig.port} -U ${dbConfig.user} -d ${dbConfig.database} -f ${backupFile}`;

      try {
        await execAsync(command, { env: { PGPASSWORD: process.env.DB_PASSWORD } });
        backupInfo.details.database = { full: true, file: backupFile };
        logger.info(`Full database backup created`, { file: backupFile });
      } catch (error) {
        throw new Error(`Database backup failed: ${error.message}`);
      }
    } else {
      // Incremental backup using WAL (Write-Ahead Log)
      // For PostgreSQL, we would use continuous archiving
      const walDir = path.join(backupDir, 'wal');
      await fs.mkdir(walDir, { recursive: true });

      // Copy WAL files since last backup
      const lastBackup = await this.getLastBackup();
      if (lastBackup) {
        const walCommand = `cp ${process.env.PG_WAL_DIR}/*.ready ${walDir}/`;
        await execAsync(walCommand);
        backupInfo.details.database = { incremental: true, walDir };
        logger.info(`Incremental backup created`, { walDir });
      } else {
        // If no previous backup, create full backup
        await this.backupDatabase(backupDir, 'full',).promise();
      backupInfo);
      }
    }

    backupInfo.progress = 30;
    await this.updateBackupStatus(backupInfo.id, backupInfo);
  }

  async backupFiles(backupDir, backupInfo) {
    const filesToBackup = [
      path.join(__dirname, 'config'),
      path.join(__dirname, 'logs'),
      path.join(__dirname, 'uploads')
    ];

    const fileBackupDir = path.join(backupDir, 'files');
    await fs.mkdir(fileBackupDir, { recursive: true });

    for (const dir of filesToBackup) {
      try {
        await fs.access(dir);
        const command = `cp -r ${dir} ${fileBackupDir}/`;
        await execAsync(command);
      } catch (error) {
        // Directory might not exist, which is okay
        logger.warn(`Directory not found for backup: ${dir}`);
      }
    }

    backupInfo.details.files = { directory: fileBackupDir };
    backupInfo.progress = 50;
    await this.updateBackupStatus(backupInfo.id, backupInfo);

    logger.info(`File backup completed`, { directory });
  }

 Dir, { recursive: true });

    try {
      await fs.access(logDir);
      const command = `cp -r ${logDir} ${backupDir}/`;
      await execAsync(command);

      backupInfo.details.logs = { directory: logBackupDir };
      backupInfo.progress = 60;
      await this.updateBackupStatus(backupInfo.id, backupInfo);

      logger.info(`Log backup completed`, { directory: logBackupDir });
    } catch (error) {
      logger.warn(`Log backup failed: ${error.message}`);
    }
  }

  async compressBackup(backupDir, backupInfo) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const tarFile = path.join(backupDir, `backup_${timestamp}.tar.gz`);

    await tar.c(
      {
        gzip: true,
        file: tarFile,
        cwd: backupDir
      },
      ['.']
    );

    backupInfo.details.compressed = { file: tarFile };
    logger.info(`Backup compressed`, { file: tarFile });

    return tarFile;
  }

  async encryptBackup(file, backupInfo) {
    const crypto = require('crypto');
    const key = crypto.randomBytes(32);
    const iv = crypto.randomBytes(16);

    const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);

    const fileBuffer = await fs.readFile(file);
    const encrypted = Buffer.concat([
      cipher.update(fileBuffer),
      cipher.final(),
      cipher.getAuthTag()
    ]);

    const encryptedFile = file + '.enc';
    await fs.writeFile(encryptedFile, encrypted);

    // Store encryption key securely (in production, use KMS)
    const keyStore = {
      key: key.toString('hex'),
      iv: iv.toString('hex'),
      authTag: cipher.getAuthTag().toString('hex')
    };

    const keyFile = encryptedFile + '.key';
    await fs.writeFile(keyFile, JSON.stringify(keyStore, null, 2));

    backupInfo.details.encrypted = { file: encryptedFile, keyFile };
    backup;
      if (Info.encryptionKey = keyStore.key.substring(0, 16) + '...'; // Store only partial

    logger.info(`Backup encrypted`, { file: encryptedFile });

    return encryptedFile;
  }

  async calculateChecksum(file) {
    const crypto = require('crypto');
    const fileBuffer = await fs.readFile(file);
    return crypto.createHash('sha256').update(fileBuffer).digest('hex');
  }

  async uploadToS3(file, backupId) {
    if (!process.env.AWS_ACCESS_KEY_ID) {
      logger.warn('AWS credentials not configured, skipping S3 upload');
      return null;
    }

    const fileBuffer = await fs.readFile(file);
    const fileName = `backups/${backupId}/${path.basename(file)}`;

    const params = {
      Bucket: process.env.AWS_S3_BUCKET,
      Key: fileName,
      Body: fileBuffer,
      ServerSideEncryption: 'AES256',
      Metadata: {
        backupId,
        timestamp: new Date().toISOString()
      }
    };

    try {
      const result = await s3.upload(params logger.info(`Backup logger.warn(`Failed to cleanup temp files: ${error.message}`);
    }
  }

  async updateBackupStatus(backupId, backupInfo) {
    const cacheKey = `backup:${backupId}`;
    await redis.setex(cacheKey, 3600, JSON.stringify(backupInfo));

    // Also store in database
    await pool.query(
      `INSERT INTO backup_metadata
       (id, type, status, progress, details, size, checksum, encrypted, location, created_at)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
       ON CONFLICT (id) DO UPDATE SET
         status = EXCLUDED.status,
         progress = EXCLUDED.progress,
         details = EXCLUDED.details,
         size = EXCLUDED.size,
         updated_at = NOW()`,
      [
        backupId,
        backupInfo.type,
        backupInfo.status,
        backupInfo.progress,
        JSON.stringify(backupInfo.details),
        backupInfo.size,
        backupInfo.checksum,
        backupInfo.encrypted,
        backupInfo.location,
        new Date().toISOString()
      ]
    );
  }

  async storeBackupMetadata(backupInfo) {
    await pool.query(
      `INSERT INTO backup_history
       (id, type, timestamp, size, checksum, location, encrypted, offsite, metadata)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,
      [
        backupInfo.id,
        backupInfo.type,
        backupInfo.timestamp,
        backupInfo.size,
        backupInfo.checksum,
        backupInfo.location,
        backupInfo.encrypted,
        backupInfo.offsite || false,
        JSON.stringify(backupInfo.details)
      ]
    );
  }

  async publishBackupEvent(eventType, backupInfo) {
    const producer = kafka.producer();
    await producer.connect();
    await producer.send({
      topic: 'backup-events',
      messages: [{
        value: JSON.stringify({
          event: eventType,
          backupId: backupInfo.id,
          timestamp: new Date().toISOString(),
          backupInfo
        })
      }]
    });
    await producer.disconnect();
  }

Path = path.join  async getLastBackup() {
    const result = await pool.query(
      `SELECT * FROM backup_history
       WHERE status = 'completed'
       ORDER BY timestamp DESC
       LIMIT 1`
    );
    return result.rows[0];
  }

  async restoreBackup(backupId, restoreOptions = {}) {
    const backupInfo = await this.getBackupInfo(backupId);

    if (!backupInfo) {
      throw new Error(`Backup ${backupId} not found`);
    }

    if (backupInfo.status !== 'completed') {
      throw new Error(`Backup ${backupId} is not completed`);
    }

    logger.info(`Starting restore`, { backupId });

    const restoreInfo = {
      id: uuidv4(),
      backupId,
      startedAt: new Date().toISOString(),
      status: 'in_progress',
      progress: 0,
      steps: []
    };

    try {
      // Step 1: Download backup if from S3
      restoreInfo.progress = 10;
      restoreInfo.steps.push({ step: 'download', status: 'in_progress' });

      let backupFilebackupInfo.location &&.com')) {
        backupFile = await this.downloadFromS3(backupInfo);
      } else {
        // Local backup
        backupFile = await this.findLocalBackup(backupId);
      }

      if (!backupFile) {
        throw new Error('Backup file not found');
      }

      restoreInfo.progress = 20;
      restoreInfo.steps.push({ step: 'download', status: 'completed' });

      // Step 2: Decrypt backup
      restoreInfo.progress = 30;
      restoreInfo.steps.push({ step: 'decrypt', status: 'in_progress' });

      const decryptedFile = await this.decryptBackup(backupFile, backupInfo);

      restoreInfo.progress = 40;
      restoreInfo.steps.push({ step: 'decrypt', status: 'completed' });

      // Step 3: Decompress backup
      restoreInfo.progress = 50;
      restoreInfo.steps.push({ step: 'decompress', status: 'in_progress' });

      const extractedDir = await this.decompressBackup(decryptedFile);

      restoreInfo.progress = 60;
      restoreInfo.steps.push({ step: 'decompress', status: 'completed' });

      // Step 4: Restore database
      restoreInfo.progress = 70;
      restoreInfo.steps.push({ step: 'restore_database', status: 'in_progress' });

      await this.restoreDatabase(extractedDir, restoreOptions);

      restoreInfo.progress = 80;
      restoreInfo.steps.push({ step: 'restore_database', status: 'completed' });

      // Step 5: Restore files (if included)
      if (restoreOptions.includeFiles) {
        restoreInfo.progress = 85;
        restoreInfo.steps.push({ step: 'restore_files', status: 'in_progress' });

        await this.restoreFiles(extractedDir);

        restoreInfo.steps.push({ step: 'restore_files', status: 'completed' });
      }

      // Step 6: Verify restore
      restoreInfo.progress = 90;
      restoreInfo.steps.push({ step: 'verify', status: 'in_progress' });

      const verification = await this.verifyRestore();

      restoreInfo.progress = 95;
      restoreInfo.steps.push({ step: 'verify', status: 'completed' });

 process.env.DB_PASSWORD      // Cleanup
      await this.cleanupRestoreFiles(backupFile, decryptedFile, extractedDir);

      // Complete restore
      restoreInfo.status = 'completed';
      restoreInfo.progress = 100;
      restoreInfo.finishedAt = new Date().toISOString();
      restoreInfo.verification = verification;

      logger.info(`Restore completed successfully`, { backupId, restoreId: restoreInfo.id });

      // Store restore history
      await this.storeRestoreHistory(restoreInfo);

      // Publish event
      await this.publishRestoreEvent('RESTORE_COMPLETED', restoreInfo);

      return restoreInfo;
    } catch (error) {
      restoreInfo.status = 'failed';
      restoreInfo.error = error.message;
      restoreInfo.finishedAt = new Date().toISOString();

      logger.error(`Restore failed`, { backupId, error: error.message });
      await this.publishRestoreEvent('RESTORE_FAILED', restoreInfo);

      throw error;
    }
  }

  async downloadFromS3(backupInfo) {
    const fileUrl = backupInfo.location;
    const fileName = path.basename(fileUrl);
    const local(__dirname, ' localPath;
  }

  async findLocalBackup(backupId) {
    const backupDir = path.join(__dirname, 'backups', backupId);
    const files = await fs.readdir(backupDir);

    const encryptedFile = files.find(f => f.endsWith('.enc'));
    if (encryptedFile) {
      return path.join(backupDir, encryptedFile);
    }

    return null;
  }

  async decryptBackup(encryptedFile, backupInfo) {
    const crypto = require('crypto');

    // Read the encrypted file
    const encryptedData = await fs.readFile(encryptedFile);

    // Extract IV and auth tag (last 16 bytes are auth tag)
    const authTag = encryptedData.slice(-16);
    const cipherText = encryptedData.slice(0, -16);

    // Get encryption key from backup info or key file
    const keyFile = encryptedFile + '.key';
    let keyStore;

    try {
      const keyData = await fs.readFile(keyFile, 'utf8');
      keyStore = JSON.parse(keyData);
    } catch (error) {
      throw new Error('Encryption key file not found');
    }

    const key = Buffer.from(keyStore.key, 'hex');
    const iv = Buffer.from(keyStore.iv, 'hex');

    // Decrypt
    const decipher = crypto.createDecipheriv('aes-256-gcm', key, iv);
    decipher.setAuthTag(authTag);

    const decrypted = Buffer.concat([
      decipher.update(cipherText),
      decipher.final()
    ]);

    const decryptedFile = encryptedFile.replace('.enc', '.dec');
    await fs.writeFile(decryptedFile, decrypted);

    return decryptedFile;
  }

  async decompressBackup(compressedFile) {
    const extractDir = path.join(__dirname, 'restore', 'extracted', path.basename(compressedFile, '.tar.gz'));

    await fs.mkdir(extractDir, { recursive: true });

    await tar.x({
      file: compressedFile,
      cwd: extractDir
    });

    return extractDir;
  }

  async restoreDatabase(backupDir, options) {
    constId: restoreInfo timestamp = new Date().toISOString().replace(/[:.]/g, '-');

    // Find database backup file
    const dbBackupDir = path.join(backupDir, 'database');
    const files = await fs.readdir(dbBackupDir);
    const sqlFile = files.find(f => f.endsWith('.sql'));

    if (!sqlFile) {
      throw new Error('Database backup file not found');
    }

    const sqlFilePath = path.join(dbBackupDir, sqlFile);

    // Create restore database (don't touch production)
    const restoreDbName = `restore_${timestamp}`;

    // Create restore database
    await pool.query(`CREATE DATABASE ${restoreDbName}`);

    // Restore backup
    const command = `psql -h ${process.env.DB_HOST} -p ${process.env.DB_PORT} -U ${process.env.DB_USER} -d ${restoreDbName} -f ${sqlFilePath}`;

    try {
      await execAsync(command, { env: { PGPASSWORD: } });
     ].count) === 0) {
        throw new Error('Restore verification failed: no tables found');
      }

      return { database: restoreDbName, tables: result.rows[0].count };
    } catch (error) {
      // Cleanup failed restore
      await pool.query(`DROP DATABASE IF EXISTS ${restoreDbName}`);
      throw error;
    }
  }

  async restoreFiles(backupDir) {
    const filesDir = path.join(backupDir, 'files');

    try {
      await fs.access(filesDir);

      // Restore files to appropriate locations
      const configDir = path.join(__dirname, 'config');
      const logsDir = path.join(__dirname, 'logs');
      const uploadsDir = path.join(__dirname, 'uploads');

      // Create directories if they don't exist
      await fs.mkdir(configDir, { recursive: true });
      await fs.mkdir(logsDir, { recursive: true });
      await fs.mkdir(uploadsDir, { recursive: true });

      // Copy files
      const command = `cp -r ${filesDir}/* ${__dirname}/`;
      await execAsync(command);

      logger.info(`Files restored successfully`);
    } catch (error) {
      logger.warn(`File restore failed: ${error.message}`);
    }
  }

  async verifyRestore() {
    // Verify database connectivity
    const dbCheck = await pool.query('SELECT 1 as test');

    // Verify critical tables exist
    const tablesCheck = await pool.query(`
      SELECT table_name
      FROM information_schema.tables
      WHERE table_schema = 'public'
      AND table_name IN ('citizens', 'businesses', 'audit_logs')
    `);

    // Verify user access
    const userCheck = await pool.query('SELECT CURRENT_USER as user');

    return {
      database: dbCheck.rows[0].test === 1,
      tables: tablesCheck.rows.length >= 3,
      user: userCheck.rows[0].user,
      timestamp: new Date().toISOString()
    };
  }

  async cleanupRestoreFiles(...files) {
    for (const file of files) {
      try {
        await fs.rm(file, { recursive: true, force: true });
      } catch (error) {
        logger.warn(`Failed to cleanup file: ${file}`, { error: error.message });
      }
    }
  }

  async storeRestoreHistory(restoreInfo) {
    await pool.query(
      `INSERT INTO restore_history
       (id, backup_id, started_at, finished_at, status, steps, verification, error)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
      [
        restoreInfo.id,
        restoreInfo.backupId,
        restoreInfo.startedAt,
        restoreInfo.finishedAt,
        restoreInfo.status,
        JSON.stringify(restoreInfo.steps),
        JSON.stringify(restoreInfo.verification || {}),
        restoreInfo.error || null
      ]
    );
  }

  async publishRestoreEvent(eventType, restoreInfo) {
    const producer = kafka.producer();
    await producer.connect();
    await producer.send({
      topic: 'restore-events',
      messages: [{
        value: JSON.stringify({
          event: eventType,
          restore.id,
          backup {
    const testId = uuidv4();
    const testInfo = {
      id: testId,
      startedAt: new Date().toISOString(),
      status: 'in_progress',
      steps: []
    };

    try {
      // Step 1: Create test backup
      testInfo.steps.push({ step: 'create_test_backup', status: 'in_progress' });
      const testBackup = await this.createBackup('full', { test: true });
      testInfo.testBackupId = testBackup.id;
      testInfo.steps.push({ step: 'create_test_backup', status: 'completed' });

      // Step 2: Simulate disaster (delete test data)
      testInfo.steps.push({ step: 'simulate_disaster', status: 'in_progress' });
      await this.simulateDisaster();
      testInfo.steps.push({ step: 'simulate_disaster', status: 'completed' });

      // Step 3: Restore from backup
      testInfo.steps.push({ step: 'restore', status: 'in_progress' });
      const restoreInfo = await this.restoreBackup(testBackup.id);
      testInfo.restoreId = restoreInfo.id;
      testInfo.steps.push({ step: 'restore', status: 'completed' });

      // Step 4: Verify recovery
      testInfo.steps.push({ step: 'verify_recovery', status: 'in_progress' });
      const verification = await this.verifyRecovery();
      testInfo.verification = verification;
      testInfo.steps.push({ step: 'verify_recovery', status: 'completed' });

      // Calculate metrics
      testInfo.finishedAt = new Date().toISOString();
      testInfo.status = 'completed';
      testInfo.metrics = {
        recoveryTime: (new Date(testInfo.finishedAt) - new Date(testInfo.startedAt)) / 1000,
        dataLoss: verification.dataLoss || 0,
        rtoAchieved: verification.rtoAchieved,
        rpoAchieved: verification.rpoAchieved
      };

      logger.info(`Disaster recovery test completed`, { testId, metrics: testInfo.metrics });

      // Store test results
      await this.storeTestResults(testInfo);

      return testInfo;
    } catch (error) {
      testInfo.status = 'failed';
      testInfo.error = error.message;
      testInfo.finishedAt = new Date().toISOString();

      logger.error(`Disaster recovery test failed`, { testId, error: error.message });

      throw error;
    }
  }

  async simulateDisaster() {
    // Simulate data loss (for testing only)
    const testTables = ['test_citizens', 'test_businesses'];

    for (const table of testTables) {
      try {
        await pool.query(`DROP TABLE IF EXISTS ${table}`);
        await pool.query(`CREATE TABLE ${table} (id SERIAL, data TEXT)`);
        await pool.query(`INSERT INTO ${table} (data) VALUES ('test_data')`);
        await pool.query(`DROP TABLE ${table}`);
      } catch (error) {
        logger.warn(`Failed to simulate disaster for ${table}: ${error.message}`);
      }
    }

    // Simulate file loss
    const testDir = path.join(__dirname, 'test_files');
    await fs.mkdir(testDir, { recursive: true });
    await fs.writeFile(path.join(testDir, 'test.txt'), 'test content');
    await fs.rm(testDir, { recursive: true, force: true });

    logger.info(`Disaster simulation completed`);
  }

  async verifyRecovery() {
    // Verify database recovery
    const dbCheck = await pool.query('SELECT 1 as test');

    // Verify critical data exists
    const dataCheck = await pool.query(`
      SELECT COUNT(*) as count
      FROM information_schema.tables
      WHERE table_schema = 'public'
      AND table_name IN ('citizens', 'businesses')
    `);

    // Check RTO (Recovery Time Objective)
    const rtoAchieved = true; // In production, calculate actual time

    // Check RPO (Recovery Point Objective)
    const rpoAchieved = true; // In production, calculate data loss

    return {
      database: dbCheck.rows[0].test === 1,
      tables: dataCheck.rows[0].count >= 2,
      rtoAchieved,
      rpoAchieved,
      dataLoss: 0,
      timestamp: new Date().toISOString()
    };
  }

  async storeTestResults(testInfo) {
    await pool.query(
      `INSERT INTO disaster_recovery_tests
       (id, started_at, finished_at, status, metrics, steps, verification, error)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
      [
        testInfo.id,
        testInfo.startedAt,
        testInfo.finishedAt,
        testInfo.status,
        JSON.stringify(testInfo.metrics || {}),
        JSON.stringify(testInfo.steps),
        JSON.stringify(testInfo.verification || {}),
        testInfo.error || null
      ]
    );
  }

  async getBackupInfo(backupId) {
    const cacheKey = `backup:${backupId}`;
    const cached = await redis.get(cacheKey);

    if (cached) {
      return JSON.parse(cached);
    }

    const result = await pool.query(
      `SELECT * FROM backup_metadata WHERE id = $1`,
      [backupId]
    );

    return result.rows[0 }
});

// Test];
  }

  async cleanupOldBackups() {
    const retentionDate = new Date();
    retentionDate.setDate(retentionDate.getDate() - this.backupConfig.retentionDays);

    // Get old backups
    const result = await pool.query(
      `SELECT id, location FROM backup_history
       WHERE created_at < $1 AND status = 'completed'`,
      [retentionDate.toISOString()]
    );

    for (const backup of result.rows) {
      try {
        // Delete from local storage
        const backupDir = path.join(__dirname, 'backups', backup.id);
        await fs.rm(backupDir, { recursive: true, force: true });

        // Delete from S3 if applicable
        if (backup.location && backup.location.includes('s3.amazonaws.com')) {
          const fileName = path.basename(backup.location);
          await s3.deleteObject({
            Bucket: process.env.AWS_S3_BUCKET,
            Key: `backups/${backup.id}/${fileName}`
          }).promise();
        }

        // Delete from database
        await pool.query(
          `DELETE FROM backup_history WHERE id = $1`,
          [backup.id]
        );

        logger.info(`Cleaned up old backup`, { backupId: backup.id });
      } catch (error) {
        logger.warn(`Failed to cleanup backup ${backup.id}: ${error.message}`);
      }
    }

    // Clean up old restore files
    const restoreDir = path.join(__dirname, 'restore');
    try {
      await fs.rm(restoreDir, { recursive: true, force: true });
      await fs.mkdir(restoreDir, { recursive: true });
    } catch (error) {
      logger.warn(`Failed to cleanup restore directory: ${error.message}`);
    }
  }

  async getBackupStatus() {
    const result = await pool.query(`
      SELECT
        COUNT(*) as total_backups,
        COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_backups,
        COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_backups,
        SUM(size) as total_size,
        MAX(created_at) as last_backup
      FROM backup_metadata
    `);

    const restoreStats = await pool.query(`
      SELECT
        COUNT(*) as total_restores,
        COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_restores,
        COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_restores,
        MAX(finished_at) as last_restore
      FROM restore_history
    `);

    const testStats = await pool.query(`
      SELECT
        COUNT(*) as total_tests,
        COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_tests,
        COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_tests,
        MAX(finished_at) as last_test
      FROM disaster_recovery_tests
    `);

    return {
      backups: result.rows[0],
      restores: restoreStats.rows[0],
      tests: testStats.rows[0],
      retentionDays: this.backupConfig.retentionDays,
      rpo: this.recoveryPointObjective,
      rto: this.recoveryTimeObjective
    };
  }
}

const backupSystem = new BackupRecoverySystem();

// API Endpoints

// Create backup
app.post('/api/v1/backup/create', async (req, res) } = require(' => {
  try {
    const { type = 'incremental', options = {} } = req.body;

    const backupInfo = await backupSystem.createBackup(type, options);

    res.json({
      success: true,
      backupInfo,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Backup creation error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Restore backup
app.post('/api/v1/backup/restore', async (req, res) => {
  try {
    const { backupId, options = {} } = req.body;

    if (!backupId) {
      return res.status(400).json({ error: 'Missing backupId' });
    }

    const restoreInfo = await backupSystem.restoreBackup(backupId, options);

    res.json({
      success: true,
      restoreInfo,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Restore error', { error: error.message });
    res.status(500).json({ error: error.message });
  disaster recovery
app// Get backup status
app.get('/api/v1/backup/status', async (req, res) => {
  try {
    const status = await backupSystem.getBackupStatus();

    res.json({
      success: true,
      status,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Backup status error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Get backup history
app.get('/api/v1/backup/history', async (req, res) => {
  try {
    const { limit = 50 } = req.query;

    const result = await pool.query(
      `SELECT * FROM backup_history
       ORDER BY timestamp DESC
       LIMIT $1`,
      [limit]
    );

    res.json({
      success: true,
      history: result.rows,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Backup history error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Get restore history
app.get('/api/v1/backup/restore-history', async (req, res) => {
  try {
    const { limit = 50 } = req.query;

    const result = await pool.query(
      `SELECT * FROM restore_history
       ORDER BY started_at DESC
       LIMIT $1`,
      [limit]
    );

    res.json({
      success: true,
      history: result.rows,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Restore history error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Cleanup old backups
app.post('/api/v1/backup/cleanup', async (req, res) => {
  try {
    await backupSystem.cleanupOldBackups();

    res.json({
      success: true,
      message: 'Old backups cleaned up successfully',
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Cleanup error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Health check
app.get('/health', (req failed to ${recipient, res) => {
  res.json({
    status: 'healthy',
    service: 'Backup & Recovery System',
    timestamp: new Date().toISOString(),
    version: '1.0.0',
    rpo: backupSystem.recoveryPointObjective,
    rto: backupSystem.recoveryTimeObjective
  });
});

const PORT = process.env.PORT || 3015;
app.listen(PORT, () => {
  logger.info(`Backup & Recovery System running on port ${PORT}`);
  console.log(`Backup & Recovery System running on port ${PORT}`);
});

module.exports = app;
 
6. INTELLIGENT NOTIFICATION & ALERTING SYSTEM
 
Module Overview
Multi-channel intelligent notifications with adaptive messaging and escalation policies.
 
File: backend/notification-system/src/app.js
javascript
javascript
const express = require('express');
const { Pool } = require('pg');
const Redis = require('ioredis');
const { Kafka } = require('kafkajs');
const winston = require('winston');
const { v4: uuidv4uuid');
const axiosconst redis = new Redis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD
});

// Kafka for event streaming
const kafka = new Kafka({
  clientId: 'notification-system',
  brokers: process.env.KAFKA_BROKERS?.split(',') || ['localhost:9092']
});

// Email transporter
const emailTransporter = nodemailer.createTransport({
  host: process.env.SMTP_HOST,
  port: process.env.SMTP_PORT,
  secure: true,
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASSWORD
  }
});

// SMS client (Twilio)
const twilioClient = process.env.TWILIO_ACCOUNT_SID ?
  twilio(process.env.TWILIO_ACCOUNT_SID, process.env.TWILIO_AUTH_TOKEN) : null;

// Logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'notification-errors.log', level: 'error' }),
    new winston.transports.File({ filename: 'notification-combined.log' })
  ]
});

// Notification System
class NotificationSystem {
  constructor() {
    this.channels = new Map();
    this.rules = new Map();
    this.escalationPolicies = new Map();
    this.initializeChannels();
    this.initializeRules();
    this.initializeEscalationPolicies();
  }

  initializeChannels() {
    // Email channel
    this.channels.set('email', {
      name: 'Email',
      send: async (recipient, subject, content, options = {}) => {
        try {
          const mailOptions = {
            from: process.env.SMTP_FROM || 'noreply@sgdus.gov.sd',
            to: recipient,
            subject: subject,
            html: content,
            ...options
          };

          const result = await emailTransporter.sendMail(mailOptions);
          logger.info(`Email sent to ${recipient}`, { messageId: result.messageId });
          return { success: true, messageId: result.messageId };
        } <p>Your registration catch (error) {
          logger.error(`Email failed to ${recipient}`, { error: error.message });
          throw error;
        }
      }
    });

    // SMS channel
    this.channels.set('sms', {
      name: 'SMS',
      send: async (recipient, subject, content, options = {}) => {
        if (!twilioClient) {
          logger.warn('Twilio not configured, skipping SMS');
          return { success: false, reason: 'Twilio not configured' };
        }

        try {
          // For SMS, we use the content as the message
          const message = content.substring(0, 160); // SMS character limit

          const result = await twilioClient.messages.create({
            body: message,
            from: process.env.TWILIO_PHONE_NUMBER,
            to: recipient
          });

          logger.info(`SMS sent to ${recipient}`, { sid: result.sid });
          return { success: true, sid: result.sid };
        } catch (error) {
          logger.error(`SMS}`, { error: throw error;
        }
      }
    });

    // Push notification channel
    this.channels.set('push', {
      name: 'Push',
      send: async (recipient, subject, content, options = {}) => {
        // In production, integrate with Firebase Cloud Messaging (FCM) or similar
        // For now, simulate push notification
        logger.info(`Push notification to ${recipient}`, {
          title: subject,
          body: content.substring(0, 100)
        });

        // Store in database for mobile app to fetch
        await pool.query(
          `INSERT INTO push_notifications
           (id, device_token, title, body, data, created_at)
           VALUES ($1, $2, $3, $4, $5, $6)`,
          [
            uuidv4(),
            recipient,
            subject,
            content,
            JSON.stringify(options.data || {}),
            new Date().toISOString()
          ]
        );

        return { success: true };
      }
    });

    // USSD notification channel
    this.channels.set('ussd', {
      name: 'USSD',
      send: async (recipient, subject, content, options = {}) => {
        // USSD is session-based, so we can't send directly
        // Instead, we store for next USSD session
        const cacheKey = `ussd:notification:${recipient}`;
        await redis.setex(cacheKey, 3600, JSON.stringify({
          title: subject,
          message: content,
          timestamp: new Date().toISOString()
        }));

        logger.info(`USSD notification queued for ${recipient}`);
        return { success: true, queued: true };
      }
    });

    // In-app notification channel
    this.channels.set('inapp', {
      name: 'In-App',
      send: async (recipient, subject, content, options = {}) => {
        // Store in database for in-app notification center
        await pool.query(
          `INSERT INTO inapp_notifications
           (id, user_oid, title, body, typeF, data, created_at)
           VALUES ($1, $2, $3, $4, $5, $6, $7)`,
          [
            uuidv4(),
            recipient,
            subject,
            content,
            options.type || 'info',
            JSON.stringify(options.data || {}),
            new Date().toISOString()
          ]
        );

        logger.info(`In-app notification created for ${recipient}`);
        return { success: true };
      }
    });
  }

  initializeRules() {
    // Registration success notifications
    this.rules.set('CITIZEN_REGISTERED', {
      name: 'Citizen Registration Success',
      channels: ['email', 'sms', 'inapp'],
      priority: 'low',
      cooldown: 300, // 5 minutes
      messageTemplates: {
        email: {
          subject: 'Registration Successful - SGDUS',
          body: (data) => `
            <h2>Registration Successful</h2>
            <p>Dear ${data.first_name} ${data.last_name},</p>
            with SGDUS has            <p>Keep this OID safe as you will need it for future services.</p>
            <hr>
            <p>This is an automated message from Sudan Government Digital Unified System.</p>
          `
        },
        sms: {
          body: (data) => `SGDUS: Registration successful. Your OID is ${data.oid}. Keep it safe.`
        },
        inapp: {
          title: 'Registration Complete',
          body: (data) => `Your registration is complete. Your OID: ${data.oid}`
        }
      }
    });

    // Business registration notifications
    this.rules.set('BUSINESS_REGISTERED', {
      name: 'Business Registration Success',
      channels: ['email', 'sms', 'inapp'],
      priority: 'low',
      cooldown: 300,
      messageTemplates: {
        email: {
          subject: 'Business Registration Successful - SGDUS',
          body: (data) => `
            <h2>Business Registration Successful</h2>
            <p>Dear Business Owner,</p>
            <p>Your business <strong>${data.business_name}</strong> has been registered successfully.</p>
            <p><strong>Business OID:</strong> ${data.oid}</p>
            <p><strong>Registration Number:</strong> ${data.registration_number}</p>
            <p>You can now access government services for your business.</p>
            <hr>
            <p>This is an automated message from Sudan Government Digital Unified System.</p>
          `
        },
        sms: {
          body: (data) => `SGDUS: Business ${data.business_name} registered. OID: ${data.oid}`
        },
        inapp: {
          title: 'Business Registration Complete',
          body: (data) => `Business ${data.business_name} registered successfully.`
        }
      }
    });

    // Fraud alert notifications
    this.rules.set('FRAUD_DETECTED', {
      name: 'Fraud Detection Alert',
      channels: ['email', 'sms', 'inapp'],
      priority: 'high',
      cooldown: 60, // 1 minute
      escalation: 'fraud_team',
      messageTemplates: {
        email: {
          subject: 'FRAUD ALERT - Immediate Action Required',
          body: (data) => `
            <h2 style="color: red;">FRAUD ALERT</h2>
            <p><strong>Alert ID:</strong> ${data.alertId}</p>
            <p><strong>Time:</strong> ${new Date().toLocaleString()}</p>
            <p><strong>Detected Activity:</strong> ${data.description}</p>
            <p><strong>Risk Score:</strong> ${data.riskScore}</p>
            <p><strong>Recommended Action:</strong> ${data.action}</p>
            <hr>
            <p>This is an automated alert from SGDUS Fraud Detection System.</p>
          `
        },
        sms: {
          body: (data) => `FRAUD ALERT: ${data.description}. Risk: ${data.riskScore}. Action: ${data.action}`
        },
        inapp: {
          title: 'RAUD ALERT',
      name: 'Compliance Violation Alert',
      channels: ['email', 'inapp'],
      priority: 'high',
      cooldown: 300,
      escalation: 'compliance_team',
      messageTemplates: {
        email: {
          subject: 'Compliance Violation - SGDUS',
          body: (data) => `
            <h2>Compliance Violation Detected</h2>
            <p><strong>Entity:</strong> ${data.entityType}</p>
            <p><strong>Violation:</strong> ${data.violation}</p>
            <p><strong>Compliance Score:</strong> ${data.complianceScore}</p>
            <p><strong>Recommendations:</strong></p>
            <ul>
              ${data.recommendations.map(r => `<li>${r}</li>`).join('')}
            </ul>
            <hr>
            <p>This is an automated alert from SGDUS Compliance System.</p>
          `
        },
        inapp: {
          title: 'Compliance Violation',
          body: (data) => `Compliance violation: ${data.violation}`,
          type: 'error'
        }
      }
    });

    // System alerts
    this.rules.set('SYSTEM_ALERT', {
      name: 'System Alert',
      channels: ['email', 'inapp'],
      priority: 'medium',
      cooldown: 300,
      escalation: 'system_admin',
      messageTemplates: {
        email: {
          subject: 'System Alert - SGDUS',
          body: (data) => `
            <h2>System Alert</h2>
            <p><strong>Alert:</strong> ${data.alert}</p>
            <p><strong>Service:</strong> ${data.service}</p>
            <p><strong>Severity:</strong> ${data.severity}</p>
            <p><strong>Details:</strong> ${data.details}</p>
            <hr>
            <p>This is an automated alert from SGDUS Monitoring System.</p>
          `
        },
        inapp: {
          title: 'System Alert',
          body: (data) => `${data.service}: ${data.alert}`,
          type: data.severity === 'critical' ? 'error' : 'warning'
        }
      }
    });

    // Backup completion notifications
    this.rules.set('BACKUP_COMPLETED', {
      name: 'Backup Completion',
      channels: ['email', 'inapp'],
      priority: 'low',
      cooldown: 3600, // 1 hour
      messageTemplates: {
        email: {
          subject: 'Backup Completed - SGDUS',
          body: (data) => `
            <h2>Backup Completed Successfully</h2>
            <p><strong>Backup ID:</strong> ${data.backupId}</p>
            <p><strong>Type:</strong> ${data.type}</p>
            <p><strong>Size:</strong> ${this.formatBytes(data.size)}</p>
            <p><strong>Location:</strong> ${data.location || 'Local'}</p>
            <p><strong>Time:</strong> ${new Date().toLocaleString()}</p>
            <hr>
            <p>This is an automated message from SGDUS Backup System.</p>
          `
        },
        inapp: {
          title: 'Backup Complete',
          body: (data) => `Backup ${data.backupId} completed successfully.`
        }
      }
    });

    // Restore completion notifications
    this.rules.set('RESTORE_COMPLETED', {
      name: 'Restore Completion',
      channels: ['email', 'sms', 'inapp'],
      priority: 'medium',
      cooldown: 600,
      messageTemplates: {
        email: {
          subject: 'Restore Completed - SGDUS',
          body: (data) => `
            <h2>Restore Completed Successfully</h2>
            <p><strong>Restore ID:</strong> ${data.restoreId}</p>
            <p><strong>Backup ID:</strong> ${data.backupId}</p>
            <p><strong>Status:</strong> ${data.status}</p>
            <p><strong>Time:</strong> ${new Date().toLocaleString()}</p>
            <hr>
            <p>This is an automated message from SGDUS Backup System.</p>
          `
        },
        sms: {
          body: (data) => `SGDUS: Restore completed. ID: ${data.restoreId}. Status: ${data.status}`
        },
        inapp: {
          title: 'Restore Complete',
          body: (data) => `Restore ${data.restoreId} completed.`
        }
      }
    });
  }

  initializeEscalationPolicies() {
    this.escalationPolicies.set('fraud_team', {
      name: 'Fraud Team Escalation',
      levels: [
        { delay: 0, channels: ['inapp'], recipients: ['fraud_analyst_1'] },
        { delay: 300, channels: ['email', 'sms'], recipients: ['fraud_analyst_1', 'fraud_analyst_2'] },
        { delay: 900, channels: ['email', 'sms'], recipients: ['fraud_manager'] }
      ]
    });

    this.escalationPolicies.set('compliance_team', {
      name: 'Compliance Team Escalation',
      levels: [
        { delay: 0, channels: ['inapp'], recipients: ['compliance_officer'] },
        { delay: 600, channels: ['email'], recipients: ['compliance_manager'] }
      ]
    });

    this.escalationPolicies.set('system_admin', {
      name: 'System Admin Escalation',
      levels: [
        { delay: 0, channels: ['inapp'], recipients: ['sysadmin_1'] },
        { delay: 300, channels: ['email', 'sms'], recipients: ['sysadmin_1', 'sysadmin_2'] },
        { delay: 600, channels: ['email', 'sms'], recipients: ['it_manager'] }
      ]
    });
  }

  async sendNotification(eventType, data, recipients = [], options = {}) {
    const rule = this.rules.get(eventType);

    if (!rule) {
      logger.warn(`No rule found for event type: ${eventType}`);
      return { success: false, reason: 'No rule found' };
    }

    // Check cooldown
    const cooldownKey = `notification_cooldown:${eventType}:${JSON.stringify(recipients)}`;
    const lastSent = await redis.get(cooldownKey);

    if (lastSent && (Date.now() - parseInt(lastSent)) < rule.cooldown * 1000) {
      logger.info(`Notification throttled for ${eventType}`);
      return { success: false, reason: 'Cooldown active' };
    }

    const results = [];

    // Determine which channels to use
    const channels = options.channels || rule.channels;

    // Prepare messages for each channel
    for (const channel of channels) {
      const channelConfig = this.channels.get(channel);
      if (!channelConfig) continue;

      const template = rule.messageTemplates[channel];
      if (!template) continue;

      // Prepare content based on template
      let subject, body, content;

      if (template.subject) {
        subject = typeof template.subject === 'function' ?
          template.subject(data) : template.subject;
      }

      if (template.body) {
        body = typeof template.body === 'function' ?
          template.body(data) : template.body;
        content = body;
      }

      if (template.title) {
        subject = typeof template.title === 'function' ?
          template.title(data) : template.title;
        body = typeof template.body === 'function' ?
          template.body(data) : template.body;
        content = body;
      }

      // Send to each recipient
      for (const recipient of recipients) {
        try {
          const result = await channelConfig.send(recipient, subject, content, {
            ...options,
            data: {
              eventType,
              timestamp: new Date().toISOString(),
              ...data
            }
          });

          results.push({
            channel,
            recipient,
            success: result.success,
            details: result
          });

          // Log notification
          await this.logNotification(eventType, channel, recipient, subject, body, result);
        } catch (error) {
          logger.error(`Failed to send ${channel} to ${recipient}`, { error: error.message });
          results.push({
            channel,
            recipient,
            success: false,
            error: error.message
          });
        }
      }
    }

    // Set cooldown
    await redis.setex(cooldownKey, rule.cooldown, Date.now().toString());

    // Check if escalation is needed
    if (rule.escalation && options.escalate) {
      await this.escalateNotification(eventType, data, rule.escalation);
    }

    return {
      success: results.some(r => r.success),
      results,
      timestamp: new Date().toISOString()
    };
  }

  async escalateNotification(eventType, data, escalationPolicyName) {
    const policy = this.escalationPolicies.get(escalationPolicyName);

    if (!policy) {
      logger.warn(`No escalation policy found: ${escalationPolicyName}`);
      return;
    }

    // Schedule each escalation level
    for (const level of policy.levels) {
      setTimeout(async () => {
        try {
          await this.sendNotification(
            eventType,
            data,
            level.recipients,
            { channels: level.channels, escalate: false }
          );

          logger.info(`Escalation level triggered for ${eventType}`, {
            policy: escalationPolicyName,
            level: level.delay
          });
        } catch (error) {
          logger.error(`Escalation failed for ${eventType}`, {
            policy: escalationPolicyName,
            level: level.delay,
            error: error.message
          });
        }
      }, level.delay * 1000);
    }
  }

  async logNotification(eventType, channel, recipient, subject, body, result) {
    await pool.query(
      `INSERT INTO notification_logs
       (id, event_type, channel, recipient, subject, body, success, details, created_at)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,
      [
        uuidv4(),
        eventType,
        channel,
        recipient,
        subject,
        body,
        result.success,
        JSON.stringify(result),
        new Date().toISOString()
      ]
    );
  }

  async getUserPreferences(userOid) {
    const cacheKey = `user_prefs:${userOid}`;
    const cached = await redis.get(cacheKey);

    if (cached) {
      return JSON.parse(cached);
    }

    const result = await pool.query(
      `SELECT * FROM user_notification_preferences WHERE user_oid = $1`,
      [userOid]
    );

    const preferences = result.rows[0] || {
      user_oid: userOid,
      email_enabled: true,
      sms_enabled: true,
      push_enabled: true,
      inapp_enabled: true,
      ussd_enabled: true,
      quiet_hours_start: '22:00',
      quiet_hours_end: '07:00',
      priority_levels: ['high', 'medium', 'low'],
      created_at: new Date().toISOString()
    };

    await redis.setex(cacheKey, 3600, JSON.stringify(preferences));
    return preferences;
  }

  async updateUserPreferences(userOid, preferences) {
    const existing = await this.getUserPreferences(userOid);
    const updated = { ...existing, ...preferences, updated_at: new Date().toISOString() };

    await pool.query(
      `INSERT INTO user_notification_preferences
       (user_oid, email_enabled, sms_enabled, push_enabled, inapp_enabled, ussd_enabled,
        quiet_hours_start, quiet_hours_end, priority_levels, created_at, updated_at)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
       ON CONFLICT (user_oid) DO UPDATE SET
         email_enabled = EXCLUDED.email_enabled,
         sms_enabled = EXCLUDED.sms_enabled,
         push_enabled = EXCLUDED.push_enabled,
         inapp_enabled = EXCLUDED.inapp_enabled,
         ussd_enabled = EXCLUDED.ussd_enabled,
         quiet_hours_start = EXCLUDED.quiet_hours_start,
         quiet_hours_end = EXCLUDED.quiet_hours_end,
         priority_levels = EXCLUDED.priority_levels,
         updated_at = EXCLUDED.updated_at`,
      [
        userOid,
        updated.email_enabled,
        updated.sms_enabled,
        updated.push_enabled,
        updated.inapp_enabled,
        updated.ussd_enabled,
        updated.quiet_hours_start,
        updated.quiet_hours_end,
        JSON.stringify(updated.priority_levels),
        updated.created_at,
        updated.updated_at
      ]
    );

    // Invalidate cache
    await redis.del(`user_prefs:${userOid}`);

    return updated;
  }

  async checkQuietHours(userOid, priority) {
    const prefs = await this.getUserPreferences(userOid);

    // Check if priority is allowed during quiet hours
    if (!prefs.priority_levels.includes(priority)) {
      return false;
    }

    // Check if current time is in quiet hours
    const now = new Date();
    const currentTime = now.getHours() * 60 + now.getMinutes();

    const [startHour, startMin] = prefs.quiet_hours_start.split(':').map(Number);
    const [endHour, endMin] = prefs.quiet_hours_end.split(':').map(Number);

    const startTime = startHour * 60 + startMin;
    const endTime = endHour * 60 + endMin;

    if (startTime < endTime) {
      // Same day
      if (currentTime >= startTime && currentTime <= endTime) {
        return priority === 'high'; // Only allow high priority during quiet hours
      }
    } else {
      // Across midnight
      if (currentTime >= startTime || currentTime <= endTime) {
        return priority === 'high';
      }
    }

    return true; // Not in quiet hours
  }

  formatBytes(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  async getNotificationStats() {
    const result = await pool.query(`
      SELECT
        DATE(created_at) as date,
        event_type,
        channel,
        COUNT(*) as total,
        SUM(CASE WHEN success = true THEN 1 ELSE 0 END) as successful,
        SUM(CASE WHEN success = false THEN 1 ELSE 0 END) as failed
      FROM notification_logs
      WHERE created_at >= NOW() - INTERVAL '30 days'
      GROUP BY DATE(created_at), event_type, channel
      ORDER BY date DESC, event_type
    `);

    const userStats = await pool.query(`
      check
app.get SELECT
        COUNT(DISTINCT recipient) as unique_recipients,
        COUNT(*) as total_notifications,
        COUNT(CASE WHEN success = true THEN 1 END) as successful_notifications
      FROM notification_logs
      WHERE created_at >= NOW() - INTERVAL '30 days'
    `);

    return {
      daily: result.rows,
      summary: userStats.rows[0],
      timestamp: new Date().toISOString()
    };
  }
}

const notificationSystem = new NotificationSystem();

// API Endpoints

// Send notification
app.post('/api/v1/notifications/send', async (req, res) => {
  try {
    const { eventType, data, recipients, options = {} } = req.body;

    if (!eventType || !recipients || !Array.isArray(recipients)) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    // Check user preferences for each recipient
    const filteredRecipients = [];
    for (const recipient of recipients) {
      const prefs = await notificationSystem.getUserPreferences(recipient);
      const allowed = await notificationSystem.checkQuietHours(recipient, options.priority || 'medium');

      if (allowed) {
        filteredRecipients.push(recipient);
      }
    }

    if (filteredRecipients.length === 0) {
      return res.json({
        success: false,
        message: 'All recipients filtered by preferences/quiet hours',
        timestamp: new Date().toISOString()
      });
    }

    const result = await notificationSystem.sendNotification(
      eventType,
      data,
      filteredRecipients,
      options
    );

    res.json({
      success: true,
      ...result,
      filteredCount: filteredRecipients.length,
      originalCount: recipients.length
    });
  } catch (error) {
    logger.error('Notification send error', { error: error.message });
    res.status(500).json({ error: 'Failed to send notification' });
  }
});

// Update user preferences
app.post('/api/v1/notifications/preferences', async (req, res) => {
  try {
    const { userOid, preferences } = req.body;

    if (!userOid || !preferences) {
      return res.status(400).json({ error: 'Missing userOid or preferences' });
    }

    const updated = await notificationSystem.updateUserPreferences(userOid, preferences);

    res.json({
      success: true,
      preferences: updated,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Preferences update error', { error: error.message });
    res.status(500).json({ error: 'Failed to update preferences' });
  }
});

// Get user preferences
app.get('/api/v1/notifications/preferences/:userOid', async (req, res) => {
  try {
    const { userOid } = req.params;

    const preferences = await notificationSystem.getUserPreferences(userOid);

    res.json({
      success: true,
      preferences,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Preferences get error', { error: error.message });
    res.status(500).json({ error: 'Failed to get preferences' });
  }
});

// Get notification stats
app.get('/api/v1/notifications/stats', async (req, res 'own) => {
  try {
    const stats = await notificationSystem.getNotificationStats();

    res.json({
      success: true,
      stats,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Stats error', { error: error.message });
    res.status(500).json({ error: 'Failed to get stats' });
  }
});

// Get notification history for user
app.get('/api/v1/notifications/history/:userOid', async (req, res) => {
  try {
    const { userOid } = req.params;
    const { limit = 50 } = req.query;

    const result = await pool.query(
      `SELECT * FROM notification_logs
       WHERE recipient = $1
       ORDER BY created_at DESC
       LIMIT $2`,
      [userOid, limit]
    );

    res.json({
      success: true,
      history: result.rows,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('History error', { error: error.message });
    res.status(500).json({ error: 'Failed to get history' });
  }
});

// Health('/health', (    service: 'Notification System',
    timestamp: new Date().toISOString(),
    version: '1.0.0',
    channels: Array.from(notificationSystem.channels.keys()),
    rules: notificationSystem.rules.size,
    escalationPolicies: notificationSystem.escalationPolicies.size
  });
});

const PORT = process.env.PORT || 3016;
app.listen(PORT, () => {
  logger.info(`Notification System running on port ${PORT}`);
  console.log(`Notification System running on port ${PORT}`);
});

module.exports = app;
 
7. INTELLIGENT ACCESS CONTROL & RBAC ENGINE
 
Module Overview
Automated role-based access control, dynamic permissions, and adaptive security policies.
 
File: backend/access-control-engine/src/app.js
javascript
javascript
const express = require('express');
const { Pool } = require('pg');
const Redis = require('ioredis');
const { Kafka } = require('kafkajs');
const winston = require('winston');
const { v4: uuidv4 } = require('uuid');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const crypto = require('crypto');

const app = express();
app.use(express.json());

// Database connection
const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: process.env.DB_PORT
});

// Redis for caching
const redis = new Redis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD
});

// Kafka for event streaming
const kafka = new Kafka({
  clientId: 'access-control-engine',
  brokers: process.env.KAFKA_BROKERS?.split(',') || ['localhost:9092']
});

// Logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'access-control-errors.log', level: 'error' }),
    new winston.transports.File({ filename: 'access-control-combined.log' })
  ]
});

// Access Control Engine
class AccessControlEngine {
  constructor()ensitiveData === {
    this.roles = new Map();
    this.permissions = new Map();
    this.policies = new Map();
    this.initializeRoles();
    this.initializePermissions();
    this.initializePolicies();
  }

  initializeRoles() {
    // Sudanese government role structure
    this.roles.set('citizen', {
      name: 'Citizen',
      description: 'Registered citizen with basic access',
      permissions: ['read:self', 'update:self', 'register:business', 'read:services'],
      constraints: {
        maxBusinesses: 5,
        dataAccess: 'own'
      }
    });

    this.roles.set('business_owner', {
      name: 'Business Owner',
      description: 'Business owner with business-related access',
      permissions: ['read:self', 'update:self', 'read:business', 'update:business', 'register:export'],
      constraints: {
        maxBusinesses: 1,
        dataAccess:_business 'Government employee with departmental access',
      permissions: ['read:all', 'write:all', 'approve:all', 'export:data'],
      constraints: {
        department: 'required',
        dataAccess: 'department'
      }
    });

    this.roles.set('ministry_officer', {
      name: 'Ministry Officer',
      description: 'Ministry-level officer with broader access',
      permissions: ['read:all', 'write:all', 'approve:all', 'export:data', 'manage:users'],
      constraints: {
        ministry: 'required',
        dataAccess: 'ministry'
      }
    });

    this.roles.set('admin', {
      name: 'System Administrator',
      description: 'Full system access',
      permissions: ['*'],
      constraints: {
        requiresMFA: true,
        dataAccess: 'all'
      }
    });

    this.roles.set('auditor', {
      name: 'Auditor',
      description: 'Read-only access for audit purposes',
      permissions: ['read:all', 'export:audit'],
      constraints: {
        dataAccess: 'all',
        readonly: true
      }
    });
  }

  initializePermissions() {
    // Fine-grained permissions
    this.permissions.set('read:self', {
      resource: 'citizen',
      action: 'read',
      scope: 'own',
      description: 'Read own citizen data'
    });

    this.permissions.set('read:all', {
      resource: 'citizen',
      action: 'read',
      scope: 'all',
      description: 'Read all citizen data'
    });

    this.permissions.set('update:self', {
      resource: 'citizen',
      action: 'update',
      scope: 'own',
      description: 'Update own citizen data'
    });

    this.permissions.set('write:all', {
      resource: '*',
      action: 'write',
      scope: 'all',
      description: 'Write to any resource'
    });

    this.permissions.set('register:business', {
      resource: 'business',
      action: 'create',
      scope: 'own',
      description: 'Register const cached = await own business'
    });

    this.permissions.set('approve:all', {
      resource: '*',
      action: 'approve',
      scope: 'all',
      description: 'Approve any operation'
    });

    this.permissions.set('export:data', {
      resource: '*',
      action: 'export',
      scope: 'all',
      description: 'Export data'
    });

    this.permissions.set('manage:users', {
      resource: 'user',
      action: 'manage',
      scope: 'all',
      description: 'Manage user accounts'
    });

    this.permissions.set('export:audit', {
      resource: 'audit',
      action: 'export',
      scope: 'all',
      description: 'Export audit logs'
    });
  }

  initializePolicies() {
    // Access policies for different scenarios
    this.policies.set('sudanese_data_localization', {
      name: 'Sudanese Data Localization Policy',
      description: 'Ensures sensitive data stays within Sudan',
      rules: [
        {
          condition: (context) => context.s true,
          action',
      rules: [
        {
          condition: (context) => context.gender === 'F' && context.service === 'biometric',
          action: 'require_female_staff',
          message: 'Female citizens require female staff for biometric services'
        }
      ]
    });

    this.policies.set('tribal_consideration', {
      name: 'Tribal Consideration Policy',
      description: 'Respects tribal affiliations in data access',
      rules: [
        {
          condition: (context) => context.tribalConflict === true,
          action: 'restrict_cross_tribal_access',
          message: 'Restricted cross-tribal data access'
        }
      ]
    });

    this.policies.set('post_conflict_security', {
      name: 'Post-Conflict Security Policy',
      description: 'Enhanced security for post-conflict regions',
      rules: [
        {
          condition: (context) => context.region === 'conflict_zone',
          action: 'require_enhanced_verification',
          message: 'Enhanced verification required for conflict zones'
        },
        {
          condition: (context) => context.region === 'conflict_zone',
          action: 'restrict_high_value_transactions',
          message: 'High-value transactions restricted in conflict zones'
        }
      ]
    });
  }

  async checkAccess(userOid, resource, action, context = {}) {
    const cacheKey = `access:${userOid}:${resource}:${action}:${JSON.stringify(context)}`;
    const cached = await redis.get(cacheKey);

    if (cached) {
      return JSON.parse(cached);
    }

    // Get user roles
    const userRoles = await this.getUserRoles(userOid);

    // Check each role for permission
    let hasPermission = false;
    let matchedRole = null;
    let constraints = {};

    for (const role of userRoles) {
      const roleConfig = this.roles.get(role);
      if (!roleConfig) continue;

      // Check if role has the required permission
      const roleHas    //Permission = await this.checkRolePermission(roleConfig, resource, action, context);

      if (roleHasPermission) {
        hasPermission = true;
        matchedRole = role;
        constraints = roleConfig.constraints;
        break;
      }
    }

    // Apply access policies
    const policyResults = await this.applyPolicies(userOid, resource, action, context);

    // Combine results
    const accessResult = {
      granted: hasPermission && policyResults.allowed,
      userOid,
      resource,
      action,
      role: matchedRole,
      constraints,
      policies: policyResults,
      timestamp: new Date().toISOString(),
      requestId: uuidv4()
    };

    // Cache the result (5 minutes)
    await redis.setex(cacheKey, 300, JSON.stringify(accessResult));

    // Log access attempt
    await this.logAccessAttempt(accessResult, context);

    return accessResult;
  }

  async getUserRoles(userOid) {
    const cacheKey = `user_roles:${userOid}`;
    redis.get(cacheKey = true`,
      [userOid]
    );

    const roles = result.rows.map(row => row.role);
    await redis.setex(cacheKey, 3600, JSON.stringify(roles));

    return roles;
  }

  async checkRolePermission(roleConfig, resource, action, context) {
    // Check wildcard permissions
    if (roleConfig.permissions.includes('*')) {
      return true;
    }

    // Check specific permissions
    const requiredPermission = `${action}:${resource}`;
    if (roleConfig.permissions.includes(requiredPermission)) {
      return true;
    }

    // Check scoped permissions
    for (const perm of roleConfig.permissions) {
      const [permAction, permResource, permScope] = perm.split(':');

      if (permAction === action || permAction === '*') {
        if (permResource === resource || permResource === '*') {
          // Check scope constraints
          if (permScope === 'all') {
            return true;
          } else if (permScope === 'own') {
            // Check if user owns the resource
            return await this.checkOwnership(context.userOid, resource, context.resourceId);
          } else if (permScope === 'department') {
            // Check department match
            return await this.checkDepartmentMatch(context.userOid, context.department);
          }
        }
      }
    }

    return false;
  }

  async checkOwnership(userOid, resource, resourceId) {
    if (!resourceId) return false;

    const cacheKey = `ownership:${userOid}:${resource}:${resourceId}`;
    const cached = await redis.get(cacheKey);

    if (cached) {
      return cached === 'true';
    }

    let isOwner = false;

    switch (resource) {
      case 'citizen':
        const citizenResult = await pool.query(
          'SELECT oid FROM citizens WHERE oid = $1 AND oid = $2',
          [resourceId, userOid]
        );
        isOwner = citizenResult.rows.length > 0;
        break;

      case 'business':
        const businessResult = await pool.query(
          'SELECT oid FROM businesses WHERE oid = $1 ANDv4(),
        owner_oid = $2',
          [resourceId, userOid]
        );
        isOwner = businessResult.rows.length > 0;
        break;

      default:
        isOwner = false;
    }

    await redis.setex(cacheKey, 300, isOwner.toString());
    return isOwner;
  }

  async checkDepartmentMatch(userOid, department) {
    if (!department) return false;

    const cacheKey = `department:${userOid}:${department}`;
    const cached = await redis.get(cacheKey);

    if (cached) {
      return cached === 'true';
    }

    const result = await pool.query(
      `SELECT department FROM user_profiles WHERE user_oid = $1`,
      [userOid]
    );

    const userDepartment = result.rows[0]?.department;
    const match = userDepartment === department;

    await redis.setex(cacheKey, 300, match.toString());
    return match;
  }

  async applyPolicies(userOid, resource, action, context) {
    const results = {
      allowed: true,
      policies: [],
      restrictions: []
    };

 Get user context
    const userContext = await this.getUserContext(userOid);
    const fullContext = { ...context, ...userContext };

    // Apply each policy
    for (const [policyName, policy] of this.policies) {
      for (const rule of policy.rules) {
        try {
          const conditionMet = rule.condition(fullContext);

          if (conditionMet) {
            results.policies.push({
              policy: policyName,
              rule: rule.message,
              action: rule.action
            });

            // Apply action
            if (rule.action === 'block_if_outside_sudan') {
              if (fullContext.country !== 'SDN') {
                results.allowed = false;
                results.restrictions.push(rule.message);
              }
            } else if (rule.action === 'require_approval') {
              results.allowed = false;
              results.restrictions.push(rule.message);
            } else if (rule.action === 'require_female_staff') {
              // Check if staff is female
              if (fullContext.staffGender !== 'F') {
                results.allowed = false;
                results.restrictions.push(rule.message);
              }
            } else if (rule.action === 'restrict_cross_tribal_access') {
              // Check tribal match
              if (fullContext.userTribalAffiliation !== fullContext.resourceTribalAffiliation) {
                results.allowed = false;
                results.restrictions.push(rule.message);
              }
            } else if (rule.action === 'require_enhanced_verification') {
              // Check if enhanced verification is provided
              if (!fullContext.enhancedVerification) {
                results.allowed = false;
                results.restrictions.push(rule.message);
              }
            } else if (rule.action === 'restrict_high_value_transactions') {
              // Check transaction value
              if (fullContext.transactionValue > 1000000) { // 1 million SDG
                results.allowed = false;
                results.restrictions.push(rule.message);
              }
            }
          }
        } catch (error) {
          logger.error(`Policy ${policyName} evaluation failed`, { error: error.message });
        }
      }
    }

    return results;
  }

  async getUserContext(userOid) {
    const cacheKey = `)`,
      [
user_context:${userOid}`;
    const cached = await redis.get(cacheKey);

    if (cached) {
      return JSON.parse(cached);
    }

    const result = await pool.query(
      `SELECT
        u.country,
        u.gender,
        u.tribal_affiliation,
        p.department,
        p.ministry,
        p.region
       FROM users u
       LEFT JOIN user_profiles p ON u.oid = p.user_oid
       WHERE u.oid = $1`,
      [userOid]
    );

    const context = result.rows[0] || {};
    await redis.setex(cacheKey, 3600, JSON.stringify(context));

    return context;
  }

  async logAccessAttempt(accessResult, context) {
    await pool.query(
      `INSERT INTO access_logs
       (id, user_oid, resource, action, granted, role, constraints, policies, context, timestamp)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`,
      [
        uuid accessResult.userO()
      ]
    );

    // Publish to Kafka for real-time monitoring
    const producer = kafka.producer();
    await producer.connect();
    await producer.send({
      topic: 'access-events',
      messages: [{ value: JSON.stringify(accessResult) }]
    });
    await producer.disconnect();
  }

  async assignRole(userOid, role, assignedBy) {
    // Check if role exists
    if (!this.roles.has(role)) {
      throw new Error(`Role ${role} does not exist`);
    }

    // Check if user already has this role
    const existing = await pool.query(
      `SELECT id FROM user_roles WHERE user_oid = $1 AND role = $2 AND active = true`,
      [userOid, role]
    );

    if (existing.rows.length > 0) {
      throw new Error(`User already has role ${role}`);
    }

    // Assign role
    await pool.query(
      `INSERT INTO user_roles (id, user_oid, role, assigned_by, assigned_at, active)
       VALUES ($1, $2, $3, $4, $5, true)`,
      [uuidv4(), userOid, role, assignedBy, new Date().toISOString()]
    );

    // Invalidate cache
    await redis.del(`user_roles:${userOid}`);

    // Log role assignment
    await this.logRoleAssignment(userOid, role, assignedBy);

    return { success: true, userOid, role };
  }

  async revokeRole(userOid, role, revokedBy) {
    // Update role to inactive
    await pool.query(
      `UPDATE user_roles
       SET active = false, revoked_by = $3, revoked_at = $4
       WHERE user_oid = $1 AND role = $2 AND active = true`,
      [userOid, role, revokedBy, new Date().toISOString()]
    );

    // Invalidate cache
    await redis.del(`user_roles:${userOid}`);

    // Log role revocation
    await this.logRoleRevocation(userOid, role, revokedBy);

    return { success: true, userOid, role };
  }

  async logRoleAssignment(userOid, role, assignedBy) {
    await pool.query(
      `INSERT INTO role_audit_logs
       (id, user_oid, role, action, performed_by, timestamp)
       VALUES ($1, $2, $3, 'ASSIGN', $4, $5)`,
      [uuidv4(), userOid, role, assignedBy, new Date().toISOString()]
    );
  }

  async logRoleRevocation(userOid, role, revokedBy) {
    await pool.query(
      `INSERT INTO role_audit_logs
       (id, user_oid, role, action, performed_by, timestamp)
       VALUES ($1, $2, $3, 'REVOKE', $4, $5)`,
      [uuidv4(), userOid, role, revokedBy, new Date().toISOString()]
    );
  }

  async createCustomRole(roleConfig) {
    const roleId = uuidv4();

    await pool.query(
      `INSERT INTO custom_roles
       (id, name, description, permissions, constraints, created_at)
       VALUES ($1, $2, $3, $4, $5, $6        roleId,
           );

    // Add to in-memory map
    this.roles.set(roleId, {
      name: roleConfig.name,
      description: roleConfig.description,
      permissions: roleConfig.permissions,
      constraints: roleConfig.constraints || {}
    });

    return { success: true, roleId, roleConfig };
  }

  async getAccessStats() {
    const result = await pool.query(`
      SELECT
        DATE(timestamp) as date,
        COUNT(*) as total_attempts,
        COUNT(CASE WHEN granted = true THEN 1 END) as granted,
        COUNT(CASE WHEN granted = false THEN 1 END) as denied,
        COUNT(DISTINCT user_oid) as unique_users
      FROM access_logs
      WHERE timestamp >= NOW() - INTERVAL '30 days'
      GROUP BY DATE(timestamp)
      ORDER BY date DESC
    `);

    const topDenied = await pool.query(`
      SELECT
        resource,
        action,
        COUNT(*) as denied_count
      FROM access_logs
      WHERE granted = false
      AND timestamp >= NOW() - INTERVAL '7 days'
      GROUP BY resource, action
      ORDER BY denied_count DESC
      LIMIT 10
    `);

    const userActivity = await pool.query(`
      SELECT
        user_oid,
        COUNT(*) as total_attempts,
        COUNT(CASE WHEN granted = true THEN 1 END) as successful,
        MAX(timestamp) as last_activity
      FROM access_logs
      WHERE timestamp >= NOW() - INTERVAL '7 days'
      GROUP BY user_oid
      ORDER BY total_attempts DESC
      LIMIT 20
    `);

    return {
      daily: result.rows,
      topDenied: topDenied.rows,
      userActivity: userActivity.rows,
      timestamp: new Date().toISOString()
    };
  }

  async adaptiveSecurityCheck(userOid, resource, action, context) {
    // Enhanced security check with adaptive policies
    const baseCheck = await this.checkAccess(userOid, resource, action, context);

    if (!baseCheck.granted) {
      return baseCheck;
    }

    // Additional security checks based on risk
    const riskScore = await this.calculateRiskScore(userOid, resource, action, context);

    if (riskScore > 0.8) {
      // High risk - require additional verification
      return {
        ...baseCheck,
        granted: false,
        riskScore,
        reason: 'High risk detected - additional verification required',
        nextSteps: ['MFA', 'manager_approval']
      };
    } else if (riskScore > 0.5) {
      // Medium risk - log for review
      return {
        ...baseCheck,
        riskScore,
        warning: 'Medium risk - activity logged for review',
        requiresReview: true
      };
    }

    return { ...baseCheck, riskScore };
  }

  async calculateRiskScore(userOid, resource, action, context) {
    let riskScore = 0;

    // Check unusual access patterns
    const accessPattern = await this.checkAccessPattern(userOid);
    if (accessPattern.unusual) {
      riskScore += 0.3;
    }

    // Check time of access
    const hour = new Date().getHours();
    if (hour < 6 || hour > 22) {
      riskScore += 0.2;
    }

    // Check resource sensitivity
    const sensitivity = await this.getResourceSensitivity(resource);
    riskScore += sensitivity;

    // Check user's recent activity
    const recentActivity = await this.checkRecentActivity(userOid);
    if (recentActivity.excessive) {
      riskScore += 0.2;
    }

    return Math.min(riskScore, 1.0);
  }

  async checkAccessPattern(userOid) {
    const cacheKey = `access_pattern:${userOid}`;
    const cached = await redis.get(cacheKey);

    if (cached) {
      return JSON.parse(cached);
    }

    // Get recent access attempts
    const result = await pool.query(
      `SELECT
        COUNT(*) as total,
        COUNT(DISTINCT resource) as unique_resources,
        COUNT(DISTINCT action) as unique_actions
       FROM access_logs
       WHERE user_oid = $1
       AND timestamp >= NOW() - INTERVAL '1 hour'`,
      [userOid]
    );

    const data = result.rows[0];
    const unusual = data.total > 10 || data.unique_resources > 5 || data.unique_actions > 3;

    const pattern = { unusual, ...data };
    await redis.setex(cacheKey, 300, JSON.stringify(pattern));

    return pattern;
  }

  async getResourceSensitivity(resource) {
    const sensitivityMap = {
      'citizen': 0.2,
      'business': 0.3,
      'financial': 0.8,
      'audit': 0.1,
      'system': 0.9
    };

    return sensitivityMap[resource] || 0.1;
  }

  async checkRecentActivity(userOid) {
    const cacheKey = `recent_activity:${userOid}`;
    const cached = await redis.get(cacheKey);

    if (cached) {
      return JSON.parse(cached);
    }

    const result = await pool.query(
      `SELECT
        COUNT(*) as total,
        COUNT(CASE WHEN granted = false THEN 1 END) as denied
       FROM access_logs
       WHERE user_oid = $1
       AND timestamp >= NOW() - INTERVAL '24 hours'`,
      [userOid]
    );

    const data = result.rows[0];
    const excessive = data.total > 100 || (data.total > 50 && data.denied > 10);

    const activity = { excessive, ...data };
    await redis.setex(cacheKey, 600, JSON.stringify(activity));

    return activity;
  }
}

const accessControlEngine = new AccessControlEngine();

// API Endpoints

// Check access
app.post('/api/v1/access/check', async (req, res) => {
  try {
    const { userOid, resource, action, context } = req.body;

    if (!userOid || !resource || !action) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const result = await accessControlEngine.checkAccess(userOid, resource, action, context || {});

    res.json({
      success: true,
      ...result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Access check error', { error: error.message });
    res.status(500).json({ error: 'Access check failed' });
  }
});

// Adaptive security check
app.post('/api/v1/access/adaptive-check', async (req, res) => {
  try {
    const { userOid, resource, action, context } = req.body;

    if (!userOid || !resource || !action) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const result = await accessControlEngine.adaptiveSecurityCheck(userOid, resource, action, context || {});

    res.json({
      success: true,
      ...result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Adaptive check error', { error: error.message });
    res.status(500).json({ error: 'Adaptive check failed' });
  }
});

// Assign role
app.post('/api/v1/access/assign-role', async (req, res) => {
  try {
    const { userOid, role, assignedBy } = req.body;

    if (!userOid || !role || !assignedBy) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const result = await accessControlEngine.assignRole(userOid, role, assignedBy);

    res.json({
      success: true,
      ...result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Role assignment error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Revoke role
app.post('/api/v1/access/revoke-role', async (req, res) => {
  try {
    const { userOid, role, revokedBy } = req.body;

    if (!userOid || !role || !revokedBy) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const result = await accessControlEngine.revokeRole(userOid, role, revokedBy);

    res.json({
      success: true,
      ...result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Role revocation error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Create custom role
app.post('/api/v1/access/create-role', async (req, res) => {
  try {
    const { roleConfig } = req.body;

    if (!roleConfig) {
      return res.status(400).json({ error: 'Missing roleConfig' });
    }

    const result = await accessControlEngine.createCustomRole(roleConfig);

    res.json({
      success: true,
      ...result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Role creation error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Get access stats
app.get('/api/v1/access/stats', async (req, res) => {
  try {
    const stats = await accessControlEngine.getAccessStats();

    res.json({
      success: true,
      stats,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Stats error', { error: error.message });
    res.status(500).json({ error: 'Failed to get stats' });
  }
});

// Get user roles
app.get('/api/v1/access/roles/:userOid', async (req, res) => {
  try {
    const { userOid } = req.params;

    const roles = await accessControlEngine.getUserRoles(userOid);

    res.json({
      success: true,
      userOid,
      roles,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Get roles error', { error: error.message });
    res.status(500).json({ error: 'Failed to get roles' });
  }
});

// Health check
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    service: 'Access Control Engine',
    timestamp: new Date().toISOString(),
    version: '1.0.0',
    roles: accessControlEngine.roles.size,
    permissions: accessControlEngine.permissions.size,
    policies: accessControlEngine.policies.size
  });
});

const PORT = process.env.PORT || 3017;
app.listen(PORT, () => {
  logger.info(`Access Control Engine running on port ${PORT}`);
  console.log(`Access Control Engine running on port ${PORT}`);
});

module.exports = app;
 
8. INTELLIGENT INTEGRATION ORCHESTRATOR
 
Module Overview
Automated integration management, API gateway orchestration, and external system synchronization.
 
File: backend/integration-orchestrator/src/app.js
javascript
javascript
const express = require('express');
const { Pool } = require('pg');
const Redis = require('ioredis');
const { Kafka } = require('kafkajs');
const winston = require('winston');
const { v4: uuidv4 } = require('uuid');
const axios = require('axios');
const cron = require('node-cron');

const app = express();
app.use(express.json());

// Database connection
const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: process.env.DB_PORT
});

// Redis for caching
const redis = new Redis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD
});

// Kafka for event streaming
const kafka = new Kafka({
  clientId: 'integration-orchestrator',
  brokers: process.env.KAFKA_BROKERS?.split(',') || ['localhost:9092']
});

// Logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'integration-errors.log', level: 'error' }),
    new winston.transports.File({ filename: 'integration-combined.log' })
  ]
});

// Integration Orchestrator
class IntegrationOrchestrator {
  constructor() {
    this.integrations = new Map();
    this.adapters = new Map();
    this.orchestrationRules = new Map();
    this.initializeIntegrations();
    this.initializeAdapters();
    this.initializeOrchestrationRules();
  }

  initializeIntegrations() {
    // Define external system integrations
    this.integrations.set('civil_registry', {
      name: 'Civil Registry System',
      type: 'government',
      endpoint: process.env.CIVIL_REGISTRY_ENDPOINT,
      authType: 'basic',
      credentials: {
        username: process.env.CIVIL_REGISTRY_USERNAME,
        password: process.env.CIVIL_REGISTRY_PASSWORD
      },
      timeout: 30000,
      retryPolicy: {
        maxRetries: 3,
        backoff: 'exponential',
        initialDelay: 1000
      },
      healthCheck: {
        endpoint: '/health',
        interval: 60000
      },
      syncSchedule: '0 */6 * * *' // Every 6 hours
    });

    this.integrations.set('tax_authority', {
      name: 'National Tax Authority',
      type: 'government',
      endpoint: process.env.TAX_AUTHORITY_ENDPOINT,
      authType: 'oauth2',
      clientId: process.env.TAX_CLIENT_ID,
      clientSecret: process.env.TAX_CLIENT_SECRET,
      timeout: 45000,
      retryPolicy: {
        maxRetries: 5,
        backoff: 'exponential',
        initialDelay: 2000
      },
      healthCheck: {
        endpoint: '/api/health',
        interval: 120000
      },
      syncSchedule: '0 2 * * *' // Daily at 2 AM
    });

    this.integrations.set('customs', {
      name: 'Customs Authority',
      type: 'government',
      endpoint: process.env.CUSTOMS_ENDPOINT,
      authType: 'certificate',
      certPath: process.env.CUSTOMS_CERT_PATH,
      timeout: 60000,
      retryPolicy: {
        maxRetries: 2,
        backoff: 'fixed',
        initialDelay: 5000
      },
      healthCheck: {
        endpoint: '/api/health',
        interval: 300000
      },
      syncSchedule: '0 */12 * * *' // Every 12 hours
    });

    this.integrations.set('business_registry', {
      name: 'Business Registry',
      type: 'government',
      endpoint: process.env.BUSINESS_REGISTRY_ENDPOINT,
      authType: 'token',
      token: process.env.BUSINESS_REGISTRY_TOKEN,
      timeout: 30000,
      retryPolicy: {
        maxRetries: 3,
        backoff: 'exponential',
        initialDelay: 1000
      },
      healthCheck: {
        endpoint: '/health',
        interval: 60000
      },
      syncSchedule: '0 */4 * * *' // Every 4 hours
    });

    this.integrations.set('land_registry', {
      name: 'Land Registry',
      type: 'government',
      endpoint: process.env.LAND_REGISTRY_ENDPOINT,
      authType: 'basic',
      credentials: {
        username: process.env.LAND_REGISTRY_USERNAME,
        password: process.env.LAND_REGISTRY_PASSWORD
      },
      timeout: 45000,
      retryPolicy: {
        maxRetries: 4,
        backoff: 'exponential',
        initialDelay: 1500
      },
      healthCheck: {
        endpoint: '/api/health',
        interval: 180000
      },
      syncSchedule: '0 3 * * 0' // Weekly on Sunday at 3 AM
    });

    this.integrations.set('banking', {
      name: 'Banking System',
      type: 'financial',
      endpoint: process.env.BANKING_ENDPOINT,
      authType: 'oauth2',
      clientId: process.env.BANKING_CLIENT_ID,
      clientSecret: process.env.BANKING_CLIENT_SECRET,
      timeout: 30000,
      retryPolicy: {
        maxRetries: 3,
        backoff: 'exponential',
        initialDelay: 1000
      },
      healthCheck: {
        endpoint: '/health',
        interval: 60000
      },
      syncSchedule: '0 */2 * * *' // Every 2 hours
    });

    this.integrations.set('telecom', {
      name: 'Telecom Providers',
      type: 'utility',
      endpoints: {
        'MTN': process.env.MTN_ENDPOINT,
        'Zain': process.env.ZAIN_ENDPOINT,
        'Sudani': process.env.SUDANI_ENDPOINT
      },
      authType: 'multi',
      credentials: {
        mtn: { username: process.env.MTN_USER, password: process.env.MTN_PASS },
        zain: { username: process.env.ZAIN_USER, password: process.env.ZAIN_PASS },
        sudani: { username: process.env.SUDANI_USER, password: process.env.SUDANI_PASS }
      },
      timeout: 15000,
      retryPolicy: {
        maxRetries: 2,
        backoff: 'fixed',
        initialDelay: 1000
      },
      healthCheck: {
        endpoints: {
          mtn: '/health',
          zain: '/health',
          sudani: '/health'
        },
        interval: 120000
      },
      syncSchedule: '*/15 * * * *' // Every 15 minutes
    });
  }

  initializeAdapters() {
    // Adapter for Civil Registry
    this.adapters.set('civil_registry', {
      name: 'Civil Registry Adapter',
      transform: async (data) => {
        return {
          national_id: data.national_id,
          first_name: data.first_name,
          last_name: data.last_name,
          date_of_birth: data.date_of_birth,
          gender: data.gender,
          father_national_id: data.father_national_id,
          mother_national_id: data.mother_national_id,
          place_of_birth: data.place_of_birth,
          registration_date: new Date().toISOString()
        };
      },
      validate: async (data) => {
        const errors = [];
        if (!data.national_id) errors.push('National ID is required');
        if (!data.first_name) errors.push('First name is required');
        if (!data.last_name) errors.push('Last name is required');
        if (!data.date_of_birth) errors.push('Date of birth is required');
        return { valid: errors.length === 0, errors };
      }
    });

    // Adapter for Tax Authority
    this.adapters.set('tax_authority', {
      name: 'Tax Authority Adapter',
      transform: async (data) => {
        return {
          business_name: data.business_name,
          registration_number: data.registration_number,
          owner_national_id: data.owner_national_id,
          address: data.address,
          business_type: data.business_type,
          tax_category: this.determineTaxCategory(data.business_type),
          registration_date: new Date().toISOString()
        };
      },
      validate: async (data) => {
        const errors = [];
        if (!data.business_name) errors.push('Business name is required');
        if (!data.registration_number) errors.push('Registration number is required');
        if (!data.owner_national_id) errors.push('Owner national ID is required');
        return { valid: errors.length === 0, errors };
      }
    });

    // Adapter for Customs
    this.adapters.set('customs', {
      name: 'Customs Adapter',
      transform: async (data) => {
        return {
          business_oid: data.business_oid,
          business_registration_number: data.registration_number,
          product_description: data.product_description,
          quantity: data.quantity,
          destination_country: data.destination_country,
          value_usd: data.value_usd,
          supporting_documents: data.documents,
          declaration_date: new Date().toISOString()
        };
      },
      validate: async (data) => {
        const errors = [];
        if (!data.business_oid) errors.push('Business OID is required');
        if (!data.product_description) errors.push('Product description is required');
        if (!data.destination_country) errors.push('Destination country is required');
        return { valid: errors.length === 0, errors };
      }
    });

    // Adapter for Business Registry
    this.adapters.set('business_registry', {
      name: 'Business Registry Adapter',
      transform: async (data) => {
        return {
          registration_number: data.registration_number,
          business_name: data.business_name,
          business_type: data.business_type,
          owner_national_id: data.owner_national_id,
          address: data.address,
          phone: data.phone_number,
          email: data.email,
          tax_id: data.tax_id,
          registration_date: new Date().toISOString()
        };
      },
      validate: async (data) => {
        const errors = [];
        if (!data.registration_number) errors.push('Registration number is required');
        if (!data.business_name) errors.push('Business name is required');
        if (!data.owner_national_id) errors.push('Owner national ID is required');
        return { valid: errors.length === 0, errors };
      }
    });

    // Adapter for Land Registry
    this.adapters.set('land_registry', {
      name: 'Land Registry Adapter',
      transform: async (data) => {
        return {
          property_id: data.property_id,
          owner_oid: data.owner_oid,
          address: data.address,
          plot_number: data.plot_number,
          area_sqm: data.area_sqm,
          title_deed_number: data.title_deed_number,
          registration_date: new Date().toISOString()
        };
      },
      validate: async (data) => {
        const errors = [];
        if (!data.property_id) errors.push('Property ID is required');
        if (!data.owner_oid) errors.push('Owner OID is required');
        if (!data.address) errors.push('Address is required');
        return { valid: errors.length === 0, errors };
      }
    });

    // Adapter for Banking
    this.adapters.set('banking', {
      name: 'Banking Adapter',
      transform: async (data) => {
        return {
          account_name: data.business_name || `${data.first_name} ${data.last_name}`,
          account_type: data.account_type || 'business',
          currency: 'SDG',
          initial_balance: 0,
          national_id: data.national_id || data.owner_national_id,
          phone_number: data.phone_number,
          email: data.email,
          address: data.address,
          registration_date: new Date().toISOString()
        };
      },
      validate: async (data) => {
        const errors = [];
        if (!data.account_name) errors.push('Account name is required');
        if (!data.national_id) errors.push('National ID is required');
        if (!data.phone_number) errors.push('Phone number is required');
        return { valid: errors.length === 0, errors };
      }
    });

    // Adapter for Telecom
    this.adapters.set('telecom', {
      name: 'Telecom Adapter',
      transform: async (data, provider) => {
        return {
          phone_number: data.phone_number,
          customer_name: data.first_name ? `${data.first_name} ${data.last_name}` : data.business_name,
          national_id: data.national_id || data.owner_national_id,
          address: data.address,
          plan_type: data.plan_type || 'standard',
          provider: provider,
          registration_date: new Date().toISOString()
        };
      },
      validate: async (data) => {
        const errors = [];
        if (!data.phone_number) errors.push('Phone number is required');
        if (!data.phone_number.startsWith('+249')) errors.push('Phone must start with +249');
        return { valid: errors.length === 0, errors };
      }
    });
  }

  initializeOrchestrationRules() {
    // Orchestration rules for multi-system integration
    this.orchestrationRules.set('citizen_registration_orchestration', {
      name: 'Citizen Registration Orchestration',
      description: 'Orchestrate citizen registration across multiple systems',
      steps: [
        {
          integration: 'civil_registry',
          action: 'register error;
    }
_citizen',
          condition: (data) => data.national_id && data.first_name && data.last_name,
          successNext: 'tax_authority',
          failureAction: 'rollback_civil_registry'
        },
        {
          integration: 'tax_authority',
          action: 'generate_tax_id',
          condition: (data) => data.national_id,
          successNext: 'telecom',
          failureAction: 'rollback_civil_registry'
        },
        {
          integration: 'telecom',
          action: 'register_sim',
          condition: (data) => data.phone_number,
          successNext: 'banking',
          failureAction: 'rollback_tax'
        },
        {
          integration: 'banking',
          action: 'create_account',
          condition: (data) => data.national_id,
          successNext: null,
          failureAction: 'rollback_telecom'
        }
      ]
    });

    this.orchestrationRules.set('business_registration_orchestration', {
      name: 'Business Registration Orchestration',
      description: 'Orchestrate business registration across multiple systems',
      steps: [
        {
          integration: 'business_registry',
          action: 'register_business',
          condition: (data) => data.registration_number && data.business_name,
          successNext: 'tax_authority',
          failureAction: 'rollback_business_registry'
        },
        {
          integration: 'tax_authority',
          action: 'generate_tax_id',
          condition: (data) => data.registration_number,
          successNext: 'customs',
          failureAction: 'rollback_business_registry'
        },
        {
          integration: 'customs',
          action: 'register_exporter',
          condition: (data) => data.business_oid,
          successNext: 'land_registry',
          failureAction: 'rollback_tax'
        },
        {
          integration: 'land_registry',
          action: 'register_property',
          condition: (data) => data.property_id,
          successNext: null,
          failureAction: 'rollback_customs'
        }
      ]
    });

    this.orchestrationRules.set('export_license_orchestration', {
      name: 'Export License Orchestration',
      description: 'Orchestrate export license application',
      steps: [
        {
          integration: 'customs',
          action: 'submit_export_application',
          condition: (data) => data.business_oid && data.product_description,
          successNext: 'banking',
          failureAction: null
        },
        {
          integration: 'banking',
          action: 'verify_funds',
          condition: (data) => data.business_oid,
          successNext: 'telecom',
          failureAction: null
        },
        {
          integration: 'telecom',
          action: 'send_notification',
          condition: (data) => data.phone_number,
          successNext: null,
          failureAction: null
        }
      ]
    });
  }

  async executeIntegration(integrationName, action, data, context = {}) {
    const integration = this.integrations.get(integrationName);
    const adapter = this.adapters.get(integrationName);

    if (!integration || !adapter) {
      throw new Error(`Integration ${integrationName} not found`);
    }

    const executionId = uuidv4();
    const startTime = Date.now();

    // Log execution start
    await this, data, context.logExecutionStart(executionId, integrationName, action, data, context);

    try {
      // Validate data
      const validation = await adapter.validate(data);
      if (!validation.valid) {
        throw new Error(`Validation failed: ${validation.errors.join(', ')}`);
      }

      // Transform data
      const transformedData = await adapter.transform(data);

      // Get authentication
      const authHeaders = await this.getAuthHeaders(integration);

      // Execute with retry policy
      const result = await this.executeWithRetry(
        integration,
        action,
        transformedData,
        authHeaders,
        executionId
      );

      // Log success
      const duration = Date.now() - startTime;
      await this.logExecutionSuccess(executionId, integrationName, action, result, duration);

      return {
        success: true,
        executionId,
        integration: integrationName,
        action,
        result,
        duration
      };
    } catch (error) {
      // Log failure
      const duration = Date.now() - startTime;
      await this.logExecutionFailure(executionId, integrationName, action, error.message, duration);

      throw  }

  async/json',
            'X-Execution-ID': executionId,
            'X-Attempt': attempt.toString()
          },
          timeout: integration.timeout
        });

        return response.data;
      } catch (error) {
        lastError = error;

        // Check if error is retryable
        const isRetryable = this.isRetryableError(error);

        if (!isRetryable || attempt === retryPolicy.maxRetries) {
          break;
        }

        // Calculate delay
        let delay;
        if (retryPolicy.backoff === 'exponential') {
          delay = retryPolicy.initialDelay * Math.pow(2, attempt - 1);
        } else {
          delay = retryPolicy.initialDelay;
        }

        // Add jitter
        delay = delay + Math.random() * 1000;

        // Log retry
        logger.warn(`Retry attempt ${attempt} for ${integration.name}`, {
          executionId,
          delay,
          error: error.message
        });

        // Wait before retry
        await this.sleep(delay);
      }
    }

    throw lastError;
  }

  async getAuthHeaders(integration) {
    switch (integration.authType) {
      case 'basic':
        return {
          'Authorization': `Basic ${Buffer.from(`${integration.credentials.username}:${integration.credentials.password}`).toString('base64')}`
        };

      case 'token':
        return {
          'Authorization': `Bearer ${integration.token}`
        };

      case 'oauth2':
        // Get OAuth2 token
        const tokenResponse = await axios.post(`${integration.endpoint}/oauth/token`, {
          grant_type: 'client_credentials',
          client_id: integration.clientId,
          client_secret: integration.clientSecret
        });
        return {
          'Authorization': `Bearer ${tokenResponse.data.access_token}`
        };

      case 'certificate':
        // For certificate-based auth, we would use the certificate
        // This is simplified for demonstration
        return {
          'X-Certificate': 'present'
        };

      case 'multi':
        // For telecom, we need to handle multiple providers
        return {};

} failed`, {      default:
        return {};
    }
  }

  isRetryableError(error) {
    if (!error.response) {
      // Network error - retryable
      return true;
    }

    const status = error.response.status;

    // Retryable status codes
    const retryableStatuses = [408, 429, 500, 502, 503, 504];

    return retryableStatuses.includes(status);
  }

  async sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  async executeOrchestration(orchestrationName, data, context = {}) {
    const orchestration = this.orchestrationRules.get(orchestrationName);

    if (!orchestration) {
      throw new Error(`Orchestration ${orchestrationName} not found`);
    }

    const orchestrationId = uuidv4();
    const startTime = Date.now();

    // Log orchestration start
    await this.logOrchestrationStart(orchestrationId, orchestrationName);

    const results: step.integration
          });
          continue;
        }

        // Execute step
        const stepResult = await this.executeIntegration(
          step.integration,
          step.action,
          currentData,
          { ...context, orchestrationId, step: step.integration }
        );

        results.push({
          step: step.integration,
          action: step.action,
          success: stepResult.success,
          result: stepResult.result
        });

        // Update current data with result
        currentData = { ...currentData, ...stepResult.result };

        // If step failed and has failure action
        if (!stepResult.success && step.failureAction) {
          logger.warn(`Step ${step.integration} failed, executing failure action: ${step.failureAction}`, {
            orchestrationId,
            step: step.integration
          });

          // Execute failure action
          await this.executeFailureAction(step.failureAction, currentData, context);

          // Break orchestration
          break;
        }
      }

      const duration = Date.now() - startTime;

      // Log orchestration completion
      await this.logOrchestrationCompletion(
        orchestrationId,
        orchestrationName,
        results,
        duration,
        results.every(r => r.success)
      );

      return {
        success: results.every(r => r.success),
        orchestrationId,
        orchestration: orchestrationName,
        results,
        duration
      };
    } catch (error) {
      const duration = Date.now() - startTime;

      // Log orchestration failure
      await this.logOrchestrationFailure(
        orchestrationId,
        orchestrationName,
        error.message,
        duration
      );

      throw error;
    }
  }

  async executeFailureAction(action, data, context) {
    // Map failure actions to actual operations
    const failureActions = {
      'rollback_civil_registry': async () => {
        // Delete from civil registry if possible
        if (data.national_id) {
          await this.executeIntegration('civil_registry', 'delete_citizen', { national_id: data.national_id }, context);
        }
      },
      'rollback_tax': async () => {
        // Delete tax ID if possibler.success).length
        if (data.tax_id) {
          await this.executeIntegration('tax_authority', 'delete_tax_id', { tax_id: data.tax_id }, context);
        }
      },
      'rollback_telecom': async () => {
        // Deactivate SIM if possible
        if (data.phone_number) {
          await this.executeIntegration('telecom', 'deactivate_sim', { phone_number: data.phone_number }, context);
        }
      },
      'rollback_business_registry': async () => {
        // Delete business registration if possible
        if (data.registration_number) {
          await this.executeIntegration('business_registry', 'delete_business', { registration_number: data.registration_number }, context);
        }
      },
      'rollback_customs': async () => {
        // Delete customs registration if possible
        if (data.business_oid) {
          await this.executeIntegration('customs', 'delete_exporter', { business_oid: data.business_oid }, context);
        }
      }
    };

    if (failureActions[action]) {
      try {
        await failureActions[action]();
        logger.info(`Failure action ${action} executed successfully`, { context });
      } catch (error) {
        logger.error(`Failure action ${action error:        if (integration.healthCheck.endpoints) {
          // For multi-provider integrations (like telecom)
          const results = {};
          for (const [provider, endpoint] of Object.entries(integration.healthCheck.endpoints)) {
            try {
              const response = await axios.get(`${integration.endpoints[provider]}${endpoint}`, {
                timeout: 5000
              });
              results[provider] = response.status === 200 ? 'healthy' : 'unhealthy';
            } catch (error) {
              results[provider] = 'unhealthy';
            }
          }
          healthStatus[name] = results;
        } else {
          // Single endpoint
          healthEndpoint = integration.healthCheck.endpoint;
          const response = await axios.get(`${integration.endpoint}${healthEndpoint}`, {
            timeout: 5000
          });
          healthStatus[name] = response.status === 200 ? 'healthy' : 'unhealthy';
        }
      } catch (error) {
        healthStatus[name] = 'unhealthy';
      }
    }

    // Store health status
    await redis.set('integration_health', JSON.stringify(healthStatus));

    // Publish health events
    const unhealthy = Object.entries(healthStatus).filter(([_, status]) => {
      if (typeof status === 'object') {
        return Object.values(status).some(s => s === 'unhealthy');
      }
      return status === 'unhealthy';
    });

    if (unhealthy.length > 0) {
      await this.publishHealthAlert(unhealthy);
    }

    return healthStatus;
  }

  async scheduleSyncs() {
    // Schedule synchronization jobs
    for (const [name, integration] of this.integrations) {
      if (integration.syncSchedule) {
        cron.schedule(integration.syncSchedule, async () => {
          logger.info(`Scheduled sync starting for ${name}`);

          try {
            const syncResult = await this.executeSync(name);
            logger.info(`Scheduled sync completed for ${name}`, { syncResult });
          } catch (error) {
            logger.error(`Scheduled sync failed for ${name}`, duration) {
    { error: error.message });
          }
        });
      }
    }
  }

  async executeSync(integrationName) {
    const integration = this.integrations.get(integrationName);

    if (!integration) {
      throw new Error(`Integration ${integrationName} not found`);
    }

    // Get data to sync
    const syncData = await this.getSyncData(integrationName);

    if (syncData.length === 0) {
      return { message: 'No data to sync', count: 0 };
    }

    // Execute sync
    const results = [];
    for (const data of syncData) {
      try {
        const result = await this.executeIntegration(integrationName, 'sync', data);
        results.push({
          id: data.id,
          success: true,
          result: result.result
        });
      } catch (error) {
        results.push({
          id: data.id,
          success: false,
          error: error.message
        });
      }
    }

    const successCount = results.filter(r => r.success).length;
    const failureCount = results.filter(r => !;

    return {
: successCount,
      failure: failureCount,
      results
    };
  }

  async getSyncData(integrationName) {
    // Get data from database that needs syncing
    const queries = {
      'civil_registry': `SELECT * FROM citizens WHERE synced = false AND created_at >= NOW() - INTERVAL '24 hours'`,
      'tax_authority': `SELECT * FROM businesses WHERE tax_id_synced = false AND created_at >= NOW() - INTERVAL '24 hours'`,
      'customs': `SELECT * FROM export_applications WHERE synced = false`,
      'business_registry': `SELECT * FROM businesses WHERE registration_synced = false`,
      'telecom': `SELECT * FROM citizens WHERE phone_number IS NOT NULL AND telecom_synced = false`
    };

    const query = queries[integrationName];
    if (!query) return [];

    const result = await pool.query(query);
    return result.rows;
  }

  async logExecutionStart(executionId, integration, action, data, context) {
    await pool.query(
      `INSERT INTO integration_executions
       (id, integration, action, data, context, status, started_at)
       VALUES ($1, $2, $3, $4, $5, 'started', $6)`,
      [
        executionId,
        integration,
        action,
        JSON.stringify(data),
        JSON.stringify(context),
        new Date().toISOString()
      ]
    );
  }

  async logExecutionSuccess(executionId, integration, action, result, duration) {
    await pool.query(
      `UPDATE integration_executions
       SET status = 'success', result = $2, duration = $3, completed_at = $4
       WHERE id = $1`,
      [
        executionId,
        JSON.stringify(result),
        duration,
        new Date().toISOString()
      ]
    );
  }

  async logExecutionFailure(executionId, integration, action, error, duration) {
    await pool.query(
      `UPDATE integration_executions
       SET status = 'failed', error = $2, duration = $3, completed_at = $4
       WHERE id = $1`,
      [
        executionId,
        error,
        duration started_at DESC
,
        new Date().toISOString()
      ]
    );
  }

  async logOrchestrationStart(orchestrationId, orchestrationName, data, context) {
    await pool.query(
      `INSERT INTO orchestration_logs
       (id, orchestration, data, context, status, started_at)
       VALUES ($1, $2, $3, $4, 'started', $5)`,
      [
        orchestrationId,
        orchestrationName,
        JSON.stringify(data),
        JSON.stringify(context),
        new Date().toISOString()
      ]
    );
  }

  async logOrchestrationCompletion(orchestrationId, orchestrationName, results, duration, success) {
    await pool.query(
      `UPDATE orchestration_logs
       SET status = $2, results = $3, duration = $4, completed_at = $5, success = $6
       WHERE id = $1`,
      [
        orchestrationId,
        success ? 'completed' : 'partial',
        JSON.stringify(results),
        duration,
        new Date().toISOString(),
        success
      ]
    );
  }

  async logOrchestrationFailure(orchestrationId, orchestrationName, error, await pool.query(
        })
      }]
    });
    await producer.disconnect();
  }

  determineTaxCategory(businessType) {
    const categories = {
      'small': 'A',
      'medium': 'B',
      'large': 'C',
      'micro': 'A',
      'enterprise': 'D'
    };
    return categories[businessType] || 'B';
  }
}

const integrationOrchestrator = new IntegrationOrchestrator();

// Schedule syncs on startup
integrationOrchestrator.scheduleSyncs();

// API Endpoints

// Execute integration
app.post('/api/v1/integration/execute', async (req, res) => {
  try {
    const { integration, action, data, context } = req.body;

    if (!integration || !action || !data) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const result = await integrationOrchestrator.executeIntegration(integration, action, data, context || {});

    res.json({
      success: true,
      ...result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Integration execution error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Execute orchestration
app.post('/api/v1/integration/orchestrate', async (req, res) => {
  try {
    const { orchestration, data, context } = req.body;

    if (!orchestration || !data) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const result = await integrationOrchestrator.executeOrchestration(orchestration, data, context || {});

    res.json({
      success: true,
      ...result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Orchestration error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Check integration health
app.get('/api/v1/integration/health', async (req, res) => {
  try {
    const health = await integrationOrchestrator.checkIntegrationHealth();

    res.json({
      Usage',
      unit success: true,
      health,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Health check error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Execute sync
app.post('/api/v1/integration/sync', async (req, res) => {
  try {
    const { integration } = req.body;

    if (!integration) {
      return res.status(400).json({ error: 'Missing integration' });
    }

    const result = await integrationOrchestrator.executeSync(integration);

    res.json({
      success: true,
      ...result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Sync error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Get execution history
app.get('/api/v1/integration/history', async (req, res) => {
  try {
    const { integration, limit = 50 } = req.query;

    let query = `
      SELECT * FROM integration_executions
      ORDER BY      LIMIT $1) {
      query = `
        SELECT * FROM integration_executions
        WHERE integration = $2
        ORDER BY started_at DESC
        LIMIT $1
      `;
      params.push(integration);
    }

    const result = await pool.query(query, params);

    res.json({
      success: true,
      history: result.rows,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('History error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Health check
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    service: 'Integration Orchestrator',
    timestamp: new Date().toISOString(),
    version: '1.0.0',
    integrations: integrationOrchestrator.integrations.size,
    adapters: integrationOrchestrator.adapters.size,
    orchestrations: integrationOrchestrator.orchestrationRules.size
  });
});

const PORT = process.env.PORT || 3018;
app.listen(PORT, () => {
  logger.info(`Integration Orchestrator running on port ${PORT}`);
  console.log(`Integration Orchestrator running on port ${PORT}`);
});

module.exports = app;
 
9. INTELLIGENT PERFORMANCE MONITORING & OPTIMIZATION
 
Module Overview
Automated performance monitoring, predictive scaling, and self-optimization of system resources.
 
File: backend/performance-monitor/src/app.js
javascript
javascript
const express = require('express');
const { Pool } = require('pg');
const Redis = require('ioredis');
const { Kafka } = require('kafkajs');
const winston = require('winston');
const { v4: uuidv4 } = require('uuid');
const axios = require('axios');
const os = require('os');
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);

const app = express();
app.use(express.json());

// Database connection
const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: process.env.DB_PORT
});

// Redis(*)) as rate for caching
const redis = new Redis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD
});

// Kafka for event streaming
const kafka = new Kafka({
  clientId: 'performance-monitor',
  brokers: process.env.KAFKA_BROKERS?.split(',') || ['localhost:9092']
});

// Logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'performance-errors.log', level: 'error' }),
    new winston.transports.File({ filename: 'performance-combined.log' })
  ]
});

// Performance Monitor
class PerformanceMonitor {
  constructor() {
    this.metrics = new Map();
    this.thresholds = new Map();
    this.optimizationRules = new Map();
    this.initializeMetrics();
    this.initializeThresholds();
    this.initializeOptimizationRules();
    this.startMonitoring();
  }

  initializeMetrics() {
    // System metrics
    this.metrics.set('cpu_usage', {
      name: 'CPU: '%5000,
      collector: async () => {
        const cpus = os.cpus();
        const totalIdle = cpus.reduce((sum, cpu) => sum + cpu.times.idle, 0);
        const totalTick = cpus.reduce((sum, cpu) =>
          sum + cpu.times.user + cpu.times.nice + cpu.times.sys + cpu.times.idle + cpu.times.irq, 0);
        return 100 - (100 * totalIdle / totalTick);
      }
    });

    this.metrics.set('memory_usage', {
      name: 'Memory Usage',
      unit: '%',
      collectionInterval: 5000,
      collector: async () => {
        const totalMem = os.totalmem();
        const freeMem = os.freemem();
        return ((totalMem - freeMem) / totalMem) * 100;
      }
    });

    this.metrics.set('disk_usage', {
      name: 'Disk Usage',
      unit: '%',
      collectionInterval: 30000,
      collector: async () => {
        try {
          const { stdout } = await execAsync('df / | tail -1 | awk \'{print $5}\' | sed \'s/%//\'');
          return parseFloat(stdout.trim());
        } catch (error) {
          logger.error('Disk usage collection failed', { error: error.message });
          return 0;
        }
      }
    });

    this.metrics.set('network_io', {
      name: 'Network I/O',
      unit: 'MB/s',
      collectionInterval: 10000,
      collector: async () => {
        try {
          const { stdout } = await execAsync('cat /proc/net/dev | grep eth0 | awk \'{print $2, $10}\'');
          const [rx, tx] = stdout.trim().split(' ').map(Number);
          return { rx: rx / 1024 / 1024, tx: tx / 1024 / 1024 };
        } catch (error) {
          return { rx: 0, tx: 0 };
        }
      });

    this.threshold }
    });

    // Application metrics
    this.metrics.set('api_response_time', {
      name: 'API Response Time',
      unit: 'ms',
      collectionInterval: 10000,
      collector: async () => {
        const result = await pool.query(`
          SELECT
            AVG(response_time) as avg,
            PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY response_time) as p95,
            PERCENTILE_CONT(0.99) WITHIN GROUP (ORDER BY response_time) as p99
          FROM api_metrics
          WHERE timestamp >= NOW() - INTERVAL '5 minutes'
        `);
        return result.rows[0] || { avg: 0, p95: 0, p99: 0 };
      }
    });

    this.metrics.set('error_rate', {
      name: 'Error Rate',
      unit: '%',
      collectionInterval: 10000,
      collector: async () => {
        const result = await pool.query(`
          SELECT
            (COUNT(CASE WHEN status >= 400 THEN 1 END) * 100.0 / COUNT
          FROM api {
        const result = await pool.query('SELECT COUNT(*) as count FROM pg_stat_activity');
        return result.rows[0].count;
      }
    });

    this.metrics.set('queue_length', {
      name: 'Queue Length',
      unit: 'messages',
      collectionInterval: 10000,
      collector: async () => {
        // Check Kafka queue length
        try {
          const admin = kafka.admin();
          await admin.connect();
          const topics = await admin.listTopics();
          let totalMessages = 0;

          for (const topic of topics) {
            if (topic.startsWith('sgdus-')) {
              const metadata = await admin.fetchTopicMetadata({ topics: [topic] });
              for (const partition of metadata.topics[0].partitions) {
                const watermarks = await admin.fetchTopicOffsets(topic);
                const offset = watermarks.find(o => o.partition === partition.partition);
                if (offset) {
                  totalMessages += offset.high - offset.low;
                }
              }
            }
          }

          await admin.disconnect();
          return totalMessages;
        } catch (error) {
          return 0;
        }
      }
    });

    // Business metrics
    this.metrics.set('registration_rate', {
      name: 'Registration Rate',
      unit: 'per hour',
      collectionInterval: 60000,
      collector: async () => {
        const result = await pool.query(`
          SELECT COUNT(*) / 1.0 as rate
          FROM citizens
          WHERE created_at >= NOW() - INTERVAL '1 hour'
        `);
        return result.rows[0]?.rate || 0;
      }
    });

    this.metrics.set('fraud_detection_rate', {
      name: 'Fraud Detection Rate',
      unit: '%',
      collectionInterval: 60000,
      collector: async () => {
        const result = await pool.query(`
          SELECT
            (COUNT(CASE WHEN (detection_result->>'fraudDetected')::boolean = true THEN 1 END) * 100.0 / COUNT(*)) as rate
          FROM fraud_logs
          WHERE timestamp >= NOW() - INTERVAL '1 hour'
        `);
        return result.rows[0]?.rate || 0;
      }
    });

    this.metrics.set('system_uptime', {
      name: 'System Uptime',
      unit: '%',
      collectionInterval: 300000,
      collector: async () => {
        const result = await pool.query(`
          SELECT
            (COUNT(CASE WHEN status = 'healthy' THEN 1 END) * 100.0 / COUNT(*)) as uptime
          FROM health_checks
          WHERE timestamp >= NOW() - INTERVAL '24 hours'
        `);
        return result.rows[0]?.uptime || 100;
      }
    });
  }

  initializeThresholds() {
    // Performance thresholds for alerts and optimizations
    this.thresholds.set('cpu_usage', {
      warning: 70,
      critical: 90,
      action: 'scale_up'
    });

    this.thresholds.set('memory_usage', {
      warning: 75,
      critical: 90,
      action: 'scale_up'
   s.set('disk'
    });

    this.thresholds.set('error_rate', {
      warning: 5, // 5%
      critical: 20, // 20%
      action: 'investigate'
    });

    this.thresholds.set('database_connections', {
      warning: 50,
      critical: 100,
      action: 'optimize_connections'
    });

    this.thresholds.set('queue_length', {
      warning: 1000,
      critical: 5000,
      action: 'scale_consumers'
    });
  }

  initializeOptimizationRules() {
    // Automated optimization rules
    this.optimizationRules.set('scale_up', {
      name: 'Scale Up',
      description: 'Increase resources when metrics exceed thresholds',
      execute: async (metric, value, threshold) => {
        logger.info(`Executing scale up for ${metric}: ${value}`);

        // In production, this would trigger Kubernetes HPA or cloud auto-scaling
        // For now, we'll simulate scaling
        const scalingEvent = {
          type: 'scale_up',
          metric,
          value,
          threshold,
          timestamp: new Date().toISOString(),
          action: 'Increased instance count by 1'
        };

        await this.logOptimization(scalingEvent);
        await this.publishOptimizationEvent(scalingEvent);

        return scalingEvent;
      }
    });

    this.optimizationRules.set('optimize_queries', {
      name: 'Optimize Queries',
      description: 'Optimize database queries when response time is high',
      execute: async (metric, value, threshold) => {
        logger.info(`Executing query optimization for ${metric}: ${value}`);

        // Analyze slow queries
        const slowQueries = await this.getSlowQueries();

        const optimizationEvent = {
          type: 'optimize_queries',
          metric,
          value,
          threshold,
          timestamp: new Date().toISOString(),
          action: `Analyzed ${slowQueries.length} slow queries`,
          details: slowQueries
        };

        await this.logOptimization(optimizationEvent);
        await this.publishOptimizationEvent(optimizationEvent);

        return optimizationEvent;
      }
    });

    this.optimizationRules.set('cleanup', {
      name: 'Cleanup',
      description: 'Cleanup disk space when usage is high',
      execute: async (metric, value, threshold) => {
        logger.info(`Executing cleanup for ${metric}: ${value}`);

        // Cleanup old logs and temporary files
        const cleanupResult = await this.cleanupDiskSpace();

        const optimizationEvent = {
          type: 'cleanup',
          metric,
          value,
          threshold,
          timestamp: new Date().toISOString(),
          action: 'Cleanup executed',
          details: cleanupResult
        };

        await this.logOptimization(optimizationEvent);
        await this.publishOptimizationEvent(optimizationEvent);

        return optimizationEvent;
      }
    });

    this.optimizationRules.set('optimize_connections', {
      name: 'Optimize Connections',
      description: 'Optimize database connection pool',
      execute: async (metric, value, threshold) => {
        logger.info(`Executing connection optimization for ${metric}: ${value}`);

        // Adjust connection pool settings
        const optimizationResult = await this.optimizeConnectionPool();

        const optimizationEvent = {
          type: 'optimize_connections',
          metric,
          value,
          threshold,
          timestamp: new Date().toISOString(),
          action: 'Connection pool optimized',
          details: optimizationResult
        };

        await this.logOptimization(optimizationEvent);
        await this.publishOptimizationEvent(optimizationEvent);

        return optimizationEvent;
      }
    });

    this.optimizationRules.set('scale_consumers', {
      name: 'Scale Consumers',
      description: 'Increase message consumers when queue length is high',
      execute: async (metric, value, threshold) => {
        logger.info(`Executing consumer scaling for ${metric}: ${value}`);

        // Scale up consumer instances
        const scalingResult = await this.scaleConsumers();

        const optimizationEvent = {
          type: 'scale_consumers',
          metric,
          value,
          threshold,
          timestamp: new Date().toISOString(),
          action: 'Consumers scaled up',
          details: scalingResult
        };

        await this.logOptimization(optimizationEvent);
        await this.publishOptimizationEvent(optimizationEvent);

        return optimizationEvent;
      }
    });

    this.optimizationRules.set('investigate', {
      name: 'Investigate',
      description: 'Trigger investigation when error rate is high',
      execute: async (metric, value, threshold) => {
        logger.info(`Triggering investigation for ${metric}: ${value}`);

        // Collect diagnostic information
        const diagnostics = await this.collectDiagnostics();

        const optimizationEvent = {
          type: 'investigate',
          metric,
          value,
          threshold,
          timestamp: new Date().toISOString(),
          action: 'Investigation triggered',
          details: diagnostics
        };

        await this.logOptimization(optimizationEvent);
        await this.publishOptimizationEvent(optimizationEvent);

        // Notify operations team
        await this.notifyOperationsTeam(optimizationEvent);

        return optimizationEvent;
      }
    });
  }

  startMonitoring() {
    // Start collecting metrics
    for (const [metricName, metricConfig] of this.metrics) {
      this.collectMetric(metricName, metricConfig);

      // Schedule periodic collection
      setInterval(() => {
        this.collectMetric(metricName, metricConfig);
      }, metricConfig.collectionInterval);
    }

    // Start optimization checks
    setInterval(() => {
      this.checkOptimizations();
    }, 30000); // Every 30 seconds

    // Start predictive analysis
    setInterval(() => {
      this.predictiveAnalysis();
    }, 300000); // Every 5 minutes

    logger.info('Performance monitoring started');
  }

  async collectMetric(metricName, metricConfig) {
    try {
      const value = await metricConfig.collector();

      // Store metric value
      const timestamp = new Date().toISOString();
      const metricData = {
        metric: metricName,
        value,
        timestamp,
        unit: metricConfig.unit
      };

      // Store in Redis for real-time access
      await redis.setex(`metric:${metricName}`, 300, JSON.stringify(metricData));

      // Store in database for historical analysis
      await pool.query(
        `INSERT INTO performance_metrics (metric, value, unit, timestamp)
         VALUES ($1, $2, $3, $4)`,
        [metricName, JSON.stringify(value), metricConfig.unit, timestamp]
      );

      // Check thresholds
      await this.checkThreshold(metricName, value, timestamp);

      // Publish metric event
      await this.publishMetricEvent(metricData);

      return metricData;
    } catch (error) {
      logger.error(`Failed to collect metric ${metricName}`, { error: error.message });
    }
  }

  async checkThreshold(metricName, value, timestamp) {
    const threshold = this.thresholds.get(metricName);
    if (!threshold) return;

    let numericValue = value;
    if (typeof value === 'object') {
      // For complex metrics, use average or specific field
      numericValue = value.avg || value.p95 || value.rate || 0;
    }

    if (numericValue >= threshold.critical) {
      logger.error(`Critical threshold exceeded for ${metricName}: ${numericValue}`, {
        threshold: threshold.critical,
        timestamp
      });

      await this.triggerOptimization(metricName, numericValue, threshold.critical, 'critical');
    } else if (numericValue >= threshold.warning) {
      logger.warn(`Warning threshold exceeded for ${metricName}: ${numericValue}`, {
        threshold: threshold.warning,
        timestamp
      });

      await this.triggerOptimization(metricName, numericValue, threshold.warning, 'warning');
    }
  }

  async triggerOptimization(metric, value, threshold, severity) {
    const thresholdConfig = this.thresholds.get(metric);
    if (!thresholdConfig || !thresholdConfig.action) return;

    const optimizationRule = this.optimizationRules.get(thresholdConfig.action);
    if (!optimizationRule) return;

    // Check if we already triggered this optimization recently
    const cacheKey = `optimization:${metric}:${thresholdConfig.action}`;
    const lastTriggered = await redis.get(cacheKey);

    if (lastTriggered) {
      const lastTime = parseInt(lastTriggered);
      const now = Date.now();
      const cooldown = 300000; // 5 minutes

      if (now - lastTime < cooldown) {
        logger.info(`Optimization ${thresholdConfig.action} for ${metric} is in cooldown`);
        return;
      }
    }

    // Execute optimization
    try {
      await optimizationRule.execute(metric, value, threshold);

      // Set cooldown
      await redis.setex(cacheKey, 300, Date.now().toString());
    } catch (error) {
      logger.error(`Failed to execute optimization ${thresholdConfig.action}`, {
        metric,
        error: error.message
      });
    }
  }

  async getSlowQueries() {
    const result = await pool.query(`
      SELECT query, mean_time, calls
      FROM pg_stat_stat
Also help me to add innovative modules about Nile, water management, farming, gold, under earth treasures like oil, gold, uranium, management, Red Sea and ports management, education and healthcare management .

INTEGRATED SUDANESE RESOURCE MANAGEMENT MODULES
 
I'll create 6 innovative, integrated modules for managing Sudan's unique resources and services. Each module will be deeply integrated with the existing SGDUS system.
 
1. NILE WATER MANAGEMENT & IRRIGATION SYSTEM
 
Module Overview
Automated water resource management, irrigation scheduling, and Nile water allocation with IoT integration.
 
File: backend/nile-water-management/src/app.js
javascript
javascript
const express = require('express');
const { Pool } = require('pg');
const Redis = require('ioredis');
const { Kafka } = require('kafkajs');
const winston = require('winston');
const { v4: uuidv4 } = require('uuid');
const axios = require('axios');
const cron = require('node-cron');

const app = express();
app.use(express.json());

// Database connection
const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: process.env.DB_PORT
});

// Redis for caching
const redis = new Redis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD
});

// Kafka for event streaming
const kafka = new Kafka({
  clientId: 'nile-water-management',
  brokers: process.env.KAFKA_BROKERS?.split(',') || ['localhost:9092']
});

// Logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'nile-water-errors.log', level: 'error' }),
    new winston.transports.File({ filename: 'nile-water-combined.log' })
  ]
});

// Nile Water Management System
class NileWaterManagement {
  constructor() {
    this.waterAllocationRules = new Map();
    this.irrigationSchedules = new Map();
    this.nileStations = new Map();
    this.initializeWaterAllocationRules();
    this.initializeNileStations();
    this.initializeIrrigationSchedules();
    this.startDailyCalculations();
  }

  initializeNileStations() {
    // Nile monitoring stations
    this.nileStations.set('khartoum', {
      name: 'Khartoum Station',
      location: { lat: 15.5007, lng: 32.5599 },
      river: 'Blue Nile',
      currentLevel: 0,
      normalRange: { min: 10, max: 25 }, // meters
      floodThreshold: 30,
      droughtThreshold: 5,
      lastUpdate: null
    });

    this.nileStations.set('shandi', {
      name: 'Shandi Station',
      location: { lat: 13.1556, lng: 33.9682 },
      river: 'Main Nile',
      currentLevel: 0,
      normalRange: { min: 8, max: 20 },
      floodThreshold: 25,
      droughtThreshold: 4,
      lastUpdate: null
    });

    this.nileStations.set('ed_damer', {
      name: 'Ed Damer Station',
      location: { lat: 14.0333, lng: 33.5167 },
      river: 'Atbara River',
      currentLevel: 0,
      normalRange: { min: 5, max: 15 },
      floodThreshold: 20,
      droughtThreshold: 2,
      lastUpdate: null
    });

    this.nileStations.set('kosti', {
      name: 'Kosti Station',
      location: { lat: 13.1667, lng: 32.6667 },
      river: 'White Nile',
      currentLevel: 0,
      normalRange: { min: 12, max: 28 },
      floodThreshold: 35,
      droughtThreshold: 6,
      lastUpdate: null
    });
  }

  initializeWaterAllocationRules() {
    // Water allocation rules based on Sudanese regulations
    this.waterAllocationRules.set('agricultural', {
      name: 'Agricultural Water Allocation',
      priority: 1,
      baseAllocation: 1000, // cubic meters per hectare per season
      seasonalAdjustment: {
        'dry': 0.7,
        'normal': 1.0,
        'wet': 1.3
      },
      stateAdjustments: {
        '01': 1.2, // Khartoum - higher value crops
        '02': 0.8, // Port Sudan - limited water
        '03': 1.0, // North Kordofan - typical
        '04': 1.1, // South Kordofan - more water
        '05': 0.9, // West Kordofan - less water
        '06': 0.7, // North Darfur - arid
        '07': 0.8, // South Darfur - semi-arid
        '08': 0.6, // East Darfur - arid
        '09': 0.7, // West Darfur - arid
        '10': 0.8, // Central Darfur - semi-arid
        '11': 1.1, // White Nile - water rich
        '12': 0.9, // Blue Nile - moderate
        '13': 1.0, // River Nile - typical
        '14': 0.8, // Kassala - semi-arid
        '15': 0.7, // Red Sea - arid
        '16': 1.2, // Gezira - irrigation hub
        '17': 1.0, // Sennar - moderate
        '18': 1.1 // Al Qadarif - irrigation
      },
      cropMultipliers: {
        'wheat': 1.0,
        'sorghum': 0.8,
        'millet': 0.6,
        'cotton': 1.5,
        'sugarcane': 2.0,
        'vegetables': 1.2,
        'fruits': 1.4,
        'dates': 0.5,
        'sesame': 0.7,
        'groundnuts': 0.9
      }
    });

    this.waterAllocationRules.set('domestic', {
      name: 'Domestic Water Allocation',
      priority: 2,
      baseAllocation: 150, // liters per person per day
      urbanMultiplier: 1.5,
      ruralMultiplier: 0.8,
      emergencyReserve: 0.2 // 20% reserve for emergencies
    });

    this.waterAllocationRules.set('industrial', {
      name: 'Industrial Water Allocation',
      priority: 3,
      baseAllocation: 5000, // cubic meters per factory per month
      industryMultipliers: {
        'food_processing': 1.2,
        'textile': 1.5,
        'cement': 2.0,
        'mining': 3.0,
        'petroleum': 2.5,
        'agricultural_processing': 1.3
      },
      recyclingRequirement: 0.3 // 30% must be recycled
    });

    this.waterAllocationRules.set('environmental', {
      name: 'Environmental Water Allocation',
      priority: 4,
      baseAllocation: 1000000, // cubic meters per wetland per month
      wetlandMultipliers: {
        'sudd': 3.0,
        'dinder': 2.0,
        'rahad': 1.5,
        'other': 1.0
      }
    });
  }

  initializeIrrigationSchedules() {
    // Irrigation schedules based on crop type and region
    this.irrigationSchedules.set('sorghum', {
      name: 'Sorghum Irrigation',
      cropType: 'sorghum',
      waterRequirement: 450, // mm per season
      irrigationFrequency: 14, // days
      criticalStages: ['germination', 'flowering', 'grain_fill'],
      optimalPlanting: ['April', 'May', 'June'],
      stateAdjustments: {
        '16': 1.2, // Gezira - more water
        '01': 1.1, // Khartoum - more water
        '06': 0.8, // North Darfur - less water
        '08': 0.7 // East Darfur - less water
      }
    });

    this.irrigationSchedules.set('wheat', {
      name: 'Wheat Irrigation',
      cropType: 'wheat',
      waterRequirement: 500,
      irrigationFrequency: 10,
      criticalStages: ['tillering', 'heading', 'grain_fill'],
      optimalPlanting: ['November', 'December', 'January'],
      stateAdjustments: {
        '16': 1.3, // Gezira
        '03': 1.1, // North Kordofan
        '18': 1.2, // Al Qadarif
        '06': 0.7 // North Darfur
      }
    });

    this.irrigationSchedules.set('cotton', {
      name: 'Cotton Irrigation',
      cropType: 'cotton',
      waterRequirement: 800,
      irrigationFrequency: 7,
      criticalStages: ['squaring', 'flowering', 'boll_development'],
      optimalPlanting: ['April', 'May'],
      stateAdjustments: {
        '16': 1.4, // Gezira
        '17': 1.3, // Sennar
        '18': 1.2, // Al Qadarif
        '01': 1.1 // Khartoum
      }
    });

    this.irrigationSchedules.set('dates', {
      name: 'Date Palm Irrigation',
      cropType: 'dates',
      waterRequirement: 1500, // dates are very water intensive
      irrigationFrequency: 21,
      criticalStages: ['fruit_set', 'fruit_development', 'ripening'],
      optimalPlanting: ['March', 'April'],
      stateAdjustments: {
        '14': 1.5, // Kassala - date capital
        '15': 1.4, // Red Sea
        '02': 1.3 // Port Sudan
      }
    });
  }

  async calculateWaterAllocation(regionCode, sector, cropType = null, population = 0) {
    const allocationRules = this.waterAllocationRules.get(sector);

    if (!allocationRules) {
      throw new Error(`No allocation rule found for sector: ${sector}`);
    }

    let baseAllocation = allocationRules.baseAllocation;
    let multiplier = 1.0;

    // Apply state adjustments
    if (regionCode && allocationRules.stateAdjustments) {
      multiplier *= allocationRules.stateAdjustments[regionCode] || 1.0;
    }

    // Apply crop multipliers
    if (sector === 'agricultural' && cropType && allocationRules.cropMultipliers) {
      multiplier *= allocationRules.cropMultipliers[cropType] || 1.0;
    }

    // Apply seasonal adjustment
    const season = await this.getCurrentSeason(regionCode);
    if (allocationRules.seasonalAdjustment && allocationRules.seasonalAdjustment[season]) {
      multiplier *= allocationRules.seasonalAdjustment[season];
    }

    // Apply population multiplier for domestic
    if (sector === 'domestic' && population > 0) {
      const stateCode = regionCode || '01';
      const urbanMultiplier = stateCode === '01' || stateCode === '02' ?
        allocationRules.urbanMultiplier : allocationRules.ruralMultiplier;
      baseAllocation = baseAllocation * urbanMultiplier * (population / 1000000); // per million people
    }

    // Calculate final allocation
    const allocation = baseAllocation * multiplier;

    // Add environmental reserve
    const environmentalReserve = allocation * (allocationRules.emergencyReserve || 0);

    return {
      baseAllocation,
      multiplier,
      finalAllocation: Math.round(allocation),
      environmentalReserve: Math.round(environmentalReserve),
      season,
      timestamp: new Date().toISOString()
    };
  }

  async getCurrentSeason(regionCode) {
    // Calculate season based on rainfall patterns
    const month = new Date().getMonth() + 1;
    const stateCode = regionCode || '01';

    // Sudanese rainfall patterns
    const rainfallPatterns = {
      '01': { // Khartoum
        dry: [11, 12, 1, 2, 3, 4],
        normal: [5, 6, 9, 10],
        wet: [7, 8]
      },
      '16': { // Gezira
        dry: [11, 12, 1, 2, 3, 4],
        normal: [5, 6, 9, 10],
        wet: [7, 8]
      },
      '06': { // North Darfur
        dry: [11, 12, 1, 2, 3, 4, 5],
        normal: [6, 7, 8, 9],
        wet: [10]
      },
      '14': { // Kassala
        dry: [1, 2, 3, 4, 5, 6],
        normal: [7, 8, 9, 10],
        wet: [11, 12]
      },
      'default': {
        dry: [1, 2, 3, 4, 5, 6],
        normal: [7, 8, 9, 10],
        wet: [11, 12]
      }
    };

    const pattern = rainfallPatterns[stateCode] || rainfallPatterns['default'];

    if (pattern.wet.includes(month)) return 'wet';
    if (pattern.dry.includes(month)) return 'dry';
    return 'normal';
  }

  async monitorNileLevels() {
    // Simulate IoT sensors monitoring Nile levels
    const monitoringData = [];

    for (const [stationId, station] of this.nileStations) {
      // Simulate current water level (in production, this would come from sensors)
      const baseLevel = station.normalRange.min +
        (station.normalRange.max - station.normalRange.min) * Math.random();

      // Add seasonal variation
      const season = await this.getCurrentSeason('01'); // Use Khartoum as reference
      const seasonalVariation = season === 'wet' ? 1.2 : season === 'dry' ? 0.8 : 1.0;

      const currentLevel = baseLevel * seasonalVariation;

      station.currentLevel = currentLevel;
      station.lastUpdate = new Date().toISOString();

      // Check for alerts
      const alerts = [];
      if (currentLevel >= station.floodThreshold) {
        alerts.push({
          type: 'FLOOD_WARNING',
          severity: 'HIGH',
          message: `Flood warning at ${station.name}: Level ${currentLevel.toFixed(1)}m`,
          threshold: station.floodThreshold
        });
      } else if (currentLevel <= station.droughtThreshold) {
        alerts.push({
          type: 'DROUGHT_WARNING',
          severity: 'HIGH',
          message: `Drought warning at ${station.name}: Level ${currentLevel.toFixed(1)}m`,
          threshold: station.droughtThreshold
        });
      } else if (currentLevel < station.normalRange.min) {
        alerts.push({
          type: 'LOW_LEVEL_WARNING',
          severity: 'MEDIUM',
          message: `Low water level at ${station.name}: Level ${currentLevel.toFixed(1)}m`,
          threshold: station.normalRange.min
        });
      } else if (currentLevel > station.normalRange.max) {
        alerts.push({
          type: 'HIGH_LEVEL_WARNING',
          severity: 'MEDIUM',
          message: `High water level at ${station.name}: Level ${currentLevel.toFixed(1)}m`,
          threshold: station.normalRange.max
        });
      }

      monitoringData.push({
        station: stationId,
        name: station.name,
        river: station.river,
        level: currentLevel,
        normalRange: station.normalRange,
        status: this.getWaterStatus(currentLevel, station),
        alerts,
        lastUpdate: station.lastUpdate
      });

      // Store in database
      await pool.query(
        `INSERT INTO nile_monitoring
         (station_id, station_name, river, water_level, status, alerts, timestamp)
         VALUES ($1, $2, $3, $4, $5, $6, $7)`,
        [
          stationId,
          station.name,
          station.river,
          currentLevel,
          this.getWaterStatus(currentLevel, station),
          JSON.stringify(alerts),
          new Date().toISOString()
        ]
      );

      // Send alerts if needed
      if (alerts.length > 0) {
        await this.sendNileAlerts(stationId, alerts);
      }
    }

    return monitoringData;
  }

  getWaterStatus(level, station) {
    if (level >= station.floodThreshold) return 'FLOOD';
    if (level <= station.droughtThreshold) return 'DROUGHT';
    if (level < station.normalRange.min) return 'LOW';
    if (level > station.normalRange.max) return 'HIGH';
    return 'NORMAL';
  }

  async sendNileAlerts(stationId, alerts) {
    const producer = kafka.producer();
    await producer.connect();

    for (const alert of alerts) {
      await producer.send({
        topic: 'nile-alerts',
        messages: [{
          value: JSON.stringify({
            stationId,
            alert,
            timestamp: new Date().toISOString()
          })
        }]
      });
    }

    await producer.disconnect();
  }

  async calculateIrrigationSchedule(farmerOid, farmLocation, cropType, farmArea) {
    const schedule = this.irrigationSchedules.get(cropType);

    if (!schedule) {
      throw new Error(`No irrigation schedule found for crop: ${cropType}`);
    }

    const stateCode = await this.getStateFromLocation(farmLocation);
    const season = await this.getCurrentSeason(stateCode);

    // Calculate base irrigation needs
    let waterRequirement = schedule.waterRequirement;
    let frequency = schedule.irrigationFrequency;

    // Apply state adjustments
    if (schedule.stateAdjustments && schedule.stateAdjustments[stateCode]) {
      waterRequirement *= schedule.stateAdjustments[stateCode];
    }

    // Adjust for season
    if (season === 'dry') {
      waterRequirement *= 1.2;
      frequency = Math.max(7, frequency - 2);
    } else if (season === 'wet') {
      waterRequirement *= 0.8;
      frequency = Math.min(21, frequency + 3);
    }

    // Calculate total water needed for the farm
    const totalWaterNeeded = Math.round(waterRequirement * farmArea); // liters

    // Generate irrigation schedule for next 30 days
    const scheduleDates = [];
    const today = new Date();

    for (let i = 0; i < 30; i += frequency) {
      const irrigationDate = new Date(today);
      irrigationDate.setDate(today.getDate() + i);

      scheduleDates.push({
        date: irrigationDate.toISOString().split('T')[0],
        waterAmount: Math.round(totalWaterNeeded / (30 / frequency)),
        criticalStage: this.checkCriticalStage(cropType, irrigationDate)
      });
    }

    // Calculate water allocation
    const allocation = await this.calculateWaterAllocation(
      stateCode,
      'agricultural',
      cropType,
      0
    );

    return {
      farmerOid,
      farmLocation,
      cropType,
      farmArea,
      stateCode,
      season,
      waterRequirement,
      totalWaterNeeded,
      irrigationFrequency: frequency,
      schedule: scheduleDates,
      waterAllocation: allocation,
      optimalPlanting: schedule.optimalPlanting,
      criticalStages: schedule.criticalStages,
      generated checkCriticalStage(cropType, date) {
    const month = date.getMonth() + 1;
    const schedules = {
      'sorghum': { germination: [5, 6], flowering: [8, 9], grain_fill: [10, 11] },
      'wheat': { tillering: [12, 1], heading: [2, 3], grain_fill: [3, 4] },
      'cotton': { squaring: [6, 7], flowering: [7, 8], boll_development: [8,At: new Date().toISOString()
    };
  }

  9] },
      'dates': { fruit_set: [4, 5], fruit_development: [6, 7], ripening: [8, 9] }
    };

    const stages = schedules[cropType];
    if (!stages) return null;

    for (const [stage, months] of Object.entries(stages)) {
      if (months.includes(month)) return stage;
    }

    return null;
  }

  async getStateFromLocation(location) {
    // Simplified geocoding - in production, use proper geocoding service
    // This is a simplified version based on Sudanese states
    const stateCodes = {
      'Khartoum': '01',
      'Port Sudan': '02',
      'Kassala': '14',
      'Gezira': '16',
      'Sennar': '17',
      'Al Qadarif': '18',
      'River Nile': '13',
      'White Nile': '11',
      'Blue Nile': '12'
    };

    for (const [name, code] of Object.entries(stateCodes)) {
      if (location.toLowerCase().includes(name.toLowerCase())) {
        return code;
      }
    }

    return '01'; // Default to Khartoum
  }

  async startDailyCalculations() {
    // Schedule daily water calculations
    cron.schedule('0 6 * * *', async () => { // 6 AM daily
      logger.info('Starting daily water calculations');

      try {
        // Update Nile monitoring
        const nileData = await this.monitorNileLevels();
        logger.info(`Nile monitoring completed: ${nileData.length} stations`);

        // Calculate water allocations for today
        const allocations = await this.calculateDailyAllocations();
        logger.info(`Water allocations calculated: ${allocations.length} allocations`);

        // Generate irrigation recommendations
        const recommendations = await this.generateIrrigationRecommendations();
        logger.info(`Irrigation recommendations generated: ${recommendations.length}`);

        // Publish daily report
        await this.publishDailyReport(nileData, allocations, recommendations);

      } catch (error) {
        logger.error('Daily calculations failed', { error: error.message });
      }
    });
  }

  async calculateDailyAllocations() {
    // Calculate water allocations for all sectors
    const allocations = [];

    // Get all farmers from database
    const farmersResult = await pool.query(`
      SELECT
        c.oid as farmer_oid,
        c.state_code,
        f.farm_area,
        f.crop_type,
        f.location
      FROM citizens c
      JOIN farm_registry f ON c.oid = f.owner_oid
      WHERE f.status = 'active'
    `);

    for (const farmer of farmersResult.rows) {
      const allocation = await this.calculateIrrigationSchedule(
        farmer.farmer_oid,
        farmer.location,
        farmer.crop_type,
        farmer.farm_area
      );

      allocations.push(allocation);

      // Store in database
      await pool.query(
        `INSERT INTO water_allocations
         (farmer_oid, state_code, crop_type, farm_area, allocation_data, calculated_at)
         VALUES ($1, $2, $3, $4, $5, $6)`,
        [
          farmer.farmer_oid,
          farmer.state_code,
          farmer.crop_type,
          farmer.farm_area,
          JSON.stringify(allocation),
          new Date().toISOString()
        ]
      );
    }

    return allocations;
  }

  async generateIrrigationRecommendations() {
    // Generate smart irrigation recommendations based on current conditions
    const recommendations = [];

    // Get current Nile levels
    const nileLevels = await pool.query(`
      SELECT station_id, water_level, status
      FROM nile_monitoring
      WHERE timestamp >= NOW() - INTERVAL '24 hours'
      ORDER BY timestamp DESC
      LIMIT 10
    `);

    // Get current weather (simulated - in production, use weather API)
    const weather = {
      temperature: 35, // °C
      humidity: 40, // %
      rainfall: 0, // mm
      evaporation: 15 // mm/day
    };

    // Analyze water stress
    const waterStress = await this.calculateWaterStress(nileLevels.rows, weather);

    // Generate recommendations for each farmer
    const farmersResult = await pool.query(`
      SELECT
        f.owner_oid,
        f.farm_area,
        f.crop_type,
        f.state_code,
        f.last_irrigation_date,
        c.phone_number,
        c.email
      FROM farm_registry f
      JOIN citizens c ON f.owner_oid = c.oid
      WHERE f.status = 'active'
    `);

    for (const farmer of farmersResult.rows) {
      const recommendation = await this.generateFarmerRecommendation(
        farmer,
        waterStress,
        weather
      );

      recommendations.push(recommendation);

      // Send notification if needed
      if (recommendation.urgency === 'HIGH') {
        await this.sendIrrigationAlert(farmer, recommendation);
      }
    }

    return recommendations;
  }

  async calculateWaterStress(nileLevels, weather) {
    // Calculate overall water stress for Sudan
    let stressScore = 0;
    const alerts = [];

    // Analyze Nile levels
    const criticalStations = nileLevels.filter(l =>
      l.status === 'FLOOD' || l.status === 'DROUGHT' || l.status === 'LOW'
    );

    if (criticalStations.length > 0) {
      stressScore += criticalStations.length * 20;

      criticalStations.forEach(station => {
        alerts.push({
          type: 'WATER_STRESS',
          station: station.station_id,
          status: station.status,
          severity: station.status === 'FLOOD' ? 'HIGH' : 'MEDIUM'
        });
      });
    }

    // Analyze weather
    if (weather.rainfall < 10) {
      stressScore += 10;
      alerts.push({
        type: 'LOW_RAINFALL',
        rainfall: weather.rainfall,
        severity: 'MEDIUM'
      });
    }

    if (weather.temperature > 40) {
      stressScore += 15;
      alerts.push({
        type: 'HIGH_TEMPERATURE',
        temperature: weather.temperature,
        severity: 'MEDIUM'
      });
    }

    if (weather.evaporation > 20) {
      stressScore += 10;
      alerts.push({
        type: 'HIGH_EVAPORATION',
        evaporation: weather.evaporation,
        severity: 'LOW'
      });
    }

    // Determine overall level
    let level = 'LOW';
    if (stressScore > 60) level = 'HIGH';
    else if (stressScore > 30) level = 'MEDIUM';

    return {
      score: Math.min(stressScore, 100),
      level,
      alerts,
      timestamp: new Date().toISOString()
    };
  }

  async generateFarmerRecommendation(farmer, waterStress, weather) {
    const schedule = this.irrigationSchedules.get(farmer.crop_type);
    if (!schedule) {
      return {
        farmerOid: farmer.owner_oid,
        recommendation: 'No schedule available',
        urgency: 'LOW'
      };
    }

    // Calculate days since last irrigation
    const lastIrrigation = new Date(farmer.last_irrigation_date || new Date());
    const daysSinceIrrigation = Math.floor((new Date() - lastIrrigation) / (1000 * 60 * 60 * 24));

    // Determine urgency based on multiple factors
    let urgency = 'LOW';
    let recommendation = '';

    if (waterStress.level === 'HIGH') {
      urgency = 'HIGH';
      recommendation = 'CRITICAL: Water stress detected. Reduce irrigation frequency by 20% and consider drought-resistant crops for next season.';
    } else if (daysSinceIrrigation >= schedule.irrigationFrequency - 2) {
      urgency = 'MEDIUM';
      recommendation = `Irrigation due soon. Current schedule: every ${schedule.irrigationFrequency} days. Last irrigation: ${daysSinceIrrigation} days ago.`;
    } else if (weather.temperature > 38) {
      urgency = 'MEDIUM';
      recommendation = `High temperature detected (${weather.temperature}°C). Consider increasing irrigation frequency by 10%.`;
    } else {
      recommendation = 'Irrigation schedule on track. Continue current schedule.';
    }

    // Add state-specific advice
    const stateAdvice = {
      '01': 'Khartoum: Water is precious. Consider drip irrigation.',
      '16': 'Gezira: Good water access. Optimize irrigation timing.',
      '06': 'North Darfur: Limited water. Prioritize drought-resistant crops.',
      '14': 'Kassala: Date palm water needs are high. Monitor closely.',
      '02': 'Port Sudan: Seawater intrusion risk. Use water efficiently.'
    };

    if (stateAdvice[farmer.state_code]) {
      recommendation += ` ${stateAdvice[farmer.state_code]}`;
    }

    return {
      farmerOid: farmer.owner_oid,
      cropType: farmer.crop_type,
      farmArea: farmer.farm_area,
      daysSinceIrrigation,
      waterStress: waterStress.level,
      recommendation,
      urgency,
      weather,
      generatedAt: new Date().toISOString()
    };
  }

  async sendIrrigationAlert(farmer, recommendation) {
    // Send alert to farmer
    const notificationSystem = {
      send: async (recipient, subject, content) => {
        // In production, this would call the notification service
        logger.info(`Irrigation alert to ${recipient}: ${subject}`);

        // Store in database
        await pool.query(
          `INSERT INTO irrigation_alerts
           (farmer_oid, alert_type, message, urgency, sent_at)
           VALUES ($1, $2, $3, $4, $5)`,
          [
            farmer.owner_oid,
            'IRRIGATION_ALERT',
            recommendation.recommendation,
            recommendation.urgency,
            new Date().toISOString()
          ]
        );
      }
    };

    await notificationSystem.send(
      farmer.owner_oid,
      `Irrigation Alert - ${recommendation.urgency} Priority`,
      recommendation.recommendation
    );
  }

  async publishDailyReport(nileData, allocations, recommendations) {
    const report = {
      date: new Date().toISOString().split('T')[0],
      nileMonitoring: nileData,
      waterAllocations: allocations.length,
      recommendations: recommendations.length,
      summary: {
        criticalAlerts: nileData.filter(d => d.alerts.length > 0).length,
        highStressFarmers: recommendations.filter(r => r.urgency === 'HIGH').length,
        totalWaterAllocated: allocations.reduce((sum, a) => sum + a.totalWaterNeeded, 0)
      }
    };

    // Store report
    await pool.query(
      `INSERT INTO daily_water_reports
       (report_date, report_data, generated_at)
       VALUES ($1, $2, $3)`,
      [report.date, JSON.stringify(report), new Date().toISOString()]
    );

    // Publish to Kafka for real-time monitoring
    const producer = kafka.producer();
    await producer.connect();
    await producer.send({
      topic: 'daily-water-reports',
      messages: [{ value: JSON.stringify(report) }]
    });
    await producer.disconnect();

    logger.info(`Daily water report published for ${report.date}`);
  }

  async getWaterStatistics() {
    const result = await pool.query(`
      SELECT
        DATE(timestamp) as date,
        COUNT(DISTINCT station_id) as stations,
        AVG(water_level) as avg_level,
        MIN(water_level) as min_level,
        MAX(water_level) as max_level,
        COUNT(CASE WHEN status = 'FLOOD' THEN 1 END) as flood_alerts,
        COUNT(CASE WHEN status = 'DROUGHT' THEN 1 END) as drought_alerts
      FROM nile_monitoring
      WHERE timestamp >= NOW() - INTERVAL '30 days'
      GROUP BY DATE(timestamp)
      ORDER BY date DESC
      LIMIT 30
    `);

    const allocationStats = await pool.query(`
      SELECT
        state_code,
        COUNT(*) as farmers,
        SUM((allocation_data->>'totalWaterNeeded')::numeric) as total_water,
        AVG((allocation_data->>'waterRequirement')::numeric) as avg_requirement
      FROM water_allocations
      WHERE calculated_at >= NOW() - INTERVAL '7 days'
      GROUP BY state_code
    `);

    return {
      dailyStats: result.rows,
      allocationStats: allocationStats.rows,
      timestamp: new Date().toISOString()
    };
  }
}

const nileWaterManagement = new NileWaterManagement();

// API Endpoints

// Get water allocation for a farmer
app.post('/api/v1/nile-water/allocation', async (req, res) => {
  try {
    const { farmerOid, farmLocation, cropType, farmArea } = req.body;

    if (!farmerOid || !farmLocation || !cropType || !farmArea) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const allocation = await nileWaterManagement.calculateIrrigationSchedule(
      farmerOid,
      farmLocation,
      cropType,
      farmArea
    );

    res.json({
      success: true,
      allocation,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Water allocation error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Get Nile monitoring data
app.get('/api/v1/nile-water/monitoring', async (req, res) => {
  try {
    const { station, days = 7 } = req.query;

    let query = `
      SELECT * FROM nile_monitoring
      WHERE timestamp >= NOW() - INTERVAL '${days} days'
    `;

    const params = [];

    if (station) {
      query += ` AND station_id = $1`;
      params.push(station);
    }

    query += ` ORDER BY timestamp DESC`;

    const result = await pool.query(query, params);

    res.json({
      success: true,
      data: result.rows,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Monitoring data error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Get irrigation recommendations
app.get('/api/v1/nile-water/recommendations', async (req, res) => {
  try {
    const { farmerOid, urgency } = req.query;

    let query = `
      SELECT * FROM irrigation_alerts
      WHERE sent_at >= NOW() - INTERVAL '7 days'
    `;

    const params = [];

    if (farmerOid) {
      query += ` AND farmer_oid = $1`;
      params.push(farmerOid);
    }

    if (urgency) {
      query += ` AND urgency = $${params.length + 1}`;
      params.push(urgency);
    }

    query += ` ORDER BY sent_at DESC`;

    const result = await pool.query(query, params);

    res.json({
      success: true,
      recommendations: result.rows,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Recommendations error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Get water statistics
app.get('/api/v1/nile-water/statistics', async (req, res) => {
  try {
    const stats = await nileWaterManagement.getWaterStatistics();

    res.json({
      success: true,
      stats,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Statistics error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Health check
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    service: 'Nile Water Management',
    timestamp: new Date().toISOString(),
    version: '1.0.0',
    stations: nileWaterManagement.nileStations.size,
    allocationRules: nileWaterManagement.waterAllocationRules.size,
    irrigationSchedules: nileWaterManagement.irrigationSchedules.size
  });
});

const PORT = process.env.PORT || 3020;
app.listen(PORT, () => {
  logger.info(`Nile Water Management running on port ${PORT}`);
  console.log(`Nile Water Management running on port ${PORT}`);
});

module.exports = app;
 
2. FARMING & AGRICULTURE MANAGEMENT SYSTEM
 
Module Overview
Smart farming, crop management, livestock tracking, and agricultural supply chain integration.
 
File: backend/farming-agriculture-system/src/app.js
javascript
javascript
const express = require('express');
const { Pool } = require('pg');
const Redis = require('ioredis');
const { Kafka } = require('kafkajs');
const winston = require('winston');
const { v4: uuidv4 } = require('uuid');
const axios = require('axios');
const cron = require('node-cron');
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);

const app = express();
app.use(express.json());

// Database connection
const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: process.env.DB_PORT
});

// Redis for caching
const redis = new Redis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD
});

// Kafka for event streaming
const kafka = new Kafka({
  clientId: 'farming-agriculture-system',
  brokers: process.env.KAFKA_BROKERS?.split(',') || ['localhost:9092']
});

// Logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'farming-errors.log', level: 'error' }),
    new winston.transports.File({ filename: 'farming-combined.log' })
  ]
});

// Farming & Agriculture System
class FarmingAgricultureSystem {
  constructor() {
    this.cropSchedules = new Map();
    this.livestockBreeds = new Map();
    this.agriculturalZones = new Map();
    this.marketPrices = new Map();
    this.initializeCropSchedules();
    this.initializeLivestockBreeds();
    this.initializeAgriculturalZones();
    this.startMarketMonitoring();
  }

  initializeCropSchedules() {
    // Sudanese crop calendar
    this.cropSchedules.set('sorghum', {
      name: 'Sorghum',
      scientificName: 'Sorghum bicolor',
      waterRequirement: 450, // mm per season
      growthPeriod: 120, // days
      plantingWindow: {
        start: 'April',
        end: 'June',
        optimal: 'May'
      },
      harvestWindow: {
        start: 'August',
        end: 'October',
        optimal: 'September'
      },
      yieldPerHectare: 2.5, // tons
      pricePerTon: 80000, // SDG
      states: ['01', '03', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '16', '17', '18'],
      droughtTolerance: 'high',
      pestResistance: 'medium'
    });

    this.cropSchedules.set('wheat', {
      name: 'Wheat',
      scientificName: 'Triticum aestivum',
      waterRequirement: 500,
      growthPeriod: 150,
      plantingWindow: {
        start: 'November',
        end: 'January',
        optimal: 'December'
      },
      harvestWindow: {
        start: 'March',
        end: 'May',
        optimal: 'April'
      },
      yieldPerHectare: 3.0,
      pricePerTon: 120000,
      states: ['01', '03', '05', '11', '12', '13', '16', '17', '18'],
      droughtTolerance: 'medium',
      pestResistance: 'low'
    });

    this.cropSchedules.set('cotton', {
      name: 'Cotton',
      scientificName: 'Gossypium hirsutum',
      waterRequirement: 800,
      growthPeriod: 180,
      plantingWindow: {
        start: 'April',
        end: 'May',
        optimal: 'April'
      },
      harvestWindow: {
        start: 'October',
        end: 'December',
        optimal: 'November'
      },
      yieldPerHectare: 1.8, // tons of seed cotton
      pricePerTon: 150000,
      states: ['01', '16', '17', '18'],
      droughtTolerance: 'low',
      pestResistance: 'medium'
    });

    this.cropSchedules.set('sesame', {
      name: 'Sesame',
      scientificName: 'Sesamum indicum',
      waterRequirement: 300,
      growthPeriod: 90,
      plantingWindow: {
        start: 'June',
        end: 'July',
        optimal: 'June'
      },
      harvestWindow: {
        start: 'September',
        end: 'October',
        optimal: 'September'
      },
      yieldPerHectare: 0.8,
      pricePerTon: 250000,
      states: ['03', '04', '05', '06', '07', '08', '09', '10', '14', '18'],
      droughtTolerance: 'high',
      pestResistance: 'high'
    });

    this.cropSchedules.set('groundnuts', {
      name: 'Groundnuts',
      scientificName: 'Arachis hypogaea',
      waterRequirement: 350,
      growthPeriod: 120,
      plantingWindow: {
        start: 'May',
        end: 'June',
        optimal: 'May'
      },
      harvestWindow: {
        start: 'September',
        end: 'October',
        optimal: 'September'
      },
      yieldPerHectare: 1.5,
      pricePerTon: 180000,
      states: ['01', '03', '04', '05', '16', '17', '18'],
      droughtTolerance: 'medium',
      pestResistance: 'medium'
    });

    this.cropSchedules.set('dates', {
      name: 'Date Palm',
      scientificName: 'Phoenix dactylifera',
      waterRequirement: 1500,
      growthPeriod: 365, // perennial
      plantingWindow: {
        start: 'March',
        end: 'April',
        optimal: 'March'
      },
      harvestWindow: {
        start: 'August',
        end: 'November',
        optimal: 'September'
      },
      yieldPerHectare: 15, // tons of dates
      pricePerTon: 60000,
      states: ['14', '15', '02'],
      droughtTolerance: 'high',
      pestResistance: 'high'
    });

    this.cropSchedules.set('millet', {
      name: 'Millet',
      scientificName: 'Pennisetum glaucum',
      waterRequirement: 250,
      growthPeriod: 80,
      plantingWindow: {
        start: 'June',
        end: 'July',
        optimal: 'June'
      },
      harvestWindow: {
        start: 'September',
        end: 'October',
        optimal: 'September'
      },
      yieldPerHectare: 1.2,
      pricePerTon: 60000,
      states: ['06', '07', '08', '09', '10', '14'],
      droughtTolerance: 'very_high',
      pestResistance: 'high'
    });
  }

  initializeLivestockBreeds() {
    // Sudanese livestock breeds
    this.livestockBreeds.set('boran', {
      name: 'Boran Cattle',
      type: 'cattle',
      origin: 'East Africa',
      characteristics: {
        weight: 500, // kg
        milkYield: 8, // liters/day
        meatYield: 250, // kg carcass
        droughtResistance: 'high',
        diseaseResistance: 'medium'
      },
      feedRequirement: 8, // kg dry matter/day
      waterRequirement: 40, // liters/day
      idealStates: ['03', '04', '05', '06', '07', '08', '09', '10', '14']
    });

    this.livestockBreeds.set('duba', {
      name: 'Duba Sheep',
      type: 'sheep',
      origin: 'Sudan',
      characteristics: {
        weight: 50, // kg
        woolYield: 1.5, // kg/year
        meatYield: 25, // kg carcass
        droughtResistance: 'very_high',
        diseaseResistance: 'high'
      },
      feedRequirement: 1.5, // kg dry matter/day
      waterRequirement: 3, // liters/day
      idealStates: ['06', '07', '08', '09', '10', '14']
    });

    this.livestockBreeds.set('nubian', {
      name: 'Nubian Goat',
      type: 'goat',
      origin: 'Sudan',
      characteristics: {
        weight: 60, // kg
        milkYield: 2.5, // liters/day
        meatYield: 30, // kg carcass
        droughtResistance: 'high',
        diseaseResistance: 'medium'
      },
      feedRequirement: 2, // kg dry matter/day
      waterRequirement: 4, // liters/day
      idealStates: ['01', '02', '03', '04', '05', '11', '12', '13', '16', '17', '18']
    });

    this.livestockBreeds.set('arabian', {
      name: 'Arabian Camel',
      type: 'camel',
      origin: 'Arabian Peninsula',
      characteristics: {
        weight: 600, // kg
        milkYield: 10, // liters/day
        meatYield: 400, // kg carcass
        droughtResistance: 'very_high',
        diseaseResistance: 'high'
      },
      feedRequirement: 10, // kg dry matter/day
      waterRequirement: 20, // liters/day (can go without for days)
      idealStates: ['02', '06', '07', '08', '09', '10', '14', '15']
    });

    this.livestockBreeds.set('sudani', {
      name: 'Sudani Chicken',
      type: 'poultry',
      origin: 'Sudan',
      characteristics: {
        weight: 2, // kg
        eggYield: 200, // eggs/year
        meatYield: 1.5, // kg
        droughtResistance: 'medium',
        diseaseResistance: 'high'
      },
      feedRequirement: 0.12, // kg/day
      waterRequirement: 0.2, // liters/day
      idealStates: ['01', '03', '11', '12', '13', '16', '17', '18']
    });
  }

  initializeAgriculturalZones() {
    // Sudanese agricultural zones
    this.agriculturalZones.set('gezira', {
      name: 'Gezira Scheme',
      location: 'Central Sudan',
      states: ['16', '17', '18'],
      area: 2.1, // million hectares
      primaryCrops: ['cotton', 'wheat', 'sorghum'],
      waterSource: 'Nile (Sennar Dam)',
      irrigationType: 'canal',
      productivity: 'high',
      infrastructure: 'developed'
    });

    this.agriculturalZones.set('gum arabic', {
      name: 'Gum Arabic Belt',
      location: 'Western Sudan',
      states: ['03', '04', '05', '06', '07', '08', '09', '10'],
      area: 5.0, // million hectares
      primaryCrops: ['gum arabic', 'sesame', 'millet'],
      waterSource: 'Rainfall',
      irrigationType: 'rainfed',
      productivity: 'medium',
      infrastructure: 'developed'
    });

    this.agriculturalZones.set('kassala', {
      name: 'Kassala Dates',
      location: 'Eastern Sudan',
      states: ['14', '15'],
      area: 0.5, // million hectares
      primaryCrops: ['dates', 'cotton', 'groundnuts'],
      waterSource: 'Gash River',
      irrigationType: 'flood',
      productivity: 'high',
      infrastructure: 'moderate'
    });

    this.agriculturalZones.set('nile_valley', {
      name: 'Nile Valley',
      location: 'Northern Sudan',
      states: ['02', '13'],
      area: 0.8, // million hectares
      primaryCrops: ['wheat', 'vegetables', 'fruits'],
      waterSource: 'Nile',
      irrigationType: 'pump',
      productivity: 'high',
      infrastructure: 'developed'
    });

    this.agriculturalZones.set('pastoral', {
      name: 'Pastoral Belt',
      location: 'Eastern and Western Sudan',
      states: ['03', '04', '05', '06', '07', '08', '09', '10', '14'],
      area: 15.0, // million hectares
      primaryLivestock: ['cattle', 'sheep', 'goats', 'camels'],
      waterSource: 'Boreholes',
      irrigationType: 'none',
      productivity: 'low',
      infrastructure: 'developed'
    });
  }

  async getCropRecommendations(farmerOid, stateCode, farmArea, soilType) {
    const recommendations = [];
    const season = await this.getCurrentSeason(stateCode);

    // Filter crops by state and season
    for (const [cropCode, crop] of this.cropSchedules) {
      if (crop.states.includes(stateCode)) {
        const suitability = this.calculateCropSuitability(crop, stateCode, season, soilType, farmArea);

        if (suitability.score > 50) {
          const projectedYield = this.calculateProjectedYield(crop, farmArea, stateCode);
          const projectedRevenue = projectedYield * crop.pricePerTon;

          recommendations.push({
            cropCode,
            cropName: crop.name,
            scientificName: crop.scientificName,
            suitability,
            projectedYield,
            projectedRevenue,
            waterRequirement: crop.waterRequirement,
            growthPeriod: crop.growthPeriod,
            plantingWindow: crop.plantingWindow,
            harvestWindow: crop.harvestWindow,
            droughtTolerance: crop.droughtTolerance,
            pestResistance: crop.pestResistance
          });
        }
      }
    }

    // Sort by suitability score
    recommendations.sort((a, b) => b.suitability.score - a.suitability.score);

    return {
      farmerOid,
      stateCode,
      farmArea,
      soilType,
      season,
      recommendations: recommendations.slice(0, 5), // Top 5
      generatedAt: new Date().toISOString()
    };
  }

  calculateCropSuitability(crop, stateCode, season, soilType, farmArea) {
    let score = 100;
    const factors = [];

    // Climate suitability
    const stateClimate = this.getStateClimate(stateCode);
    if (stateClimate === 'arid' && crop.droughtTolerance === 'low') {
      score -= 30;
      factors.push({ factor: 'climate', reason: 'Low drought tolerance in arid region', impact: -30 });
    }

    // Soil suitability
    const soilMatch = this.checkSoilCompatibility(crop, soilType);
    if (!soilMatch) {
      score -= 20;
      factors.push({ factor: 'soil', reason: 'Soil type not optimal', impact: -20 });
    }

    // Seasonal suitability
    if (season === 'dry' && crop.waterRequirement > 500) {
      score -= 15;
      factors.push({ factor: 'season', reason: 'High water requirement in dry season', impact: -15 });
    }

    // Farm size suitability
    if (farmArea < 1 && crop.growthPeriod > 150) {
      score -= 10;
      factors.push({ factor: 'size', reason: 'Long growth period for small farm', impact: -10 });
    }

    // Market demand (simulated)
    const marketDemand = this.checkMarketDemand(crop, stateCode);
    if (marketDemand < 50) {
      score -= 15;
      factors.push({ factor: 'market', reason: 'Low market demand', impact: -15 });
    }

    return {
      score: Math.max(0, score),
      factors,
      recommendation: score > 70 ? 'Highly recommended' : score > 50 ? 'Recommended' : 'Not recommended'
    };
  }

  calculateProjectedYield(crop, farmArea, stateCode) {
    let baseYield = crop.yieldPerHectare;

    // Adjust for state
    const stateMultiplier = {
      '16': 1.3, // Gezira - high productivity
      '01': 1.2, // Khartoum
      '17': 1.1, // Sennar
      '18': 1.1, // Al Qadarif
      '03': 0.9, // North Kordofan
      '06': 0.7, // North Darfur
      '08': 0.6, // East Darfur
      '14': 0.8 // Kassala
    };

    const multiplier = stateMultiplier[stateCode] || 1.0;
    return baseYield * farmArea * multiplier;
  }

  async getLivestockRecommendations(farmerOid, stateCode, farmArea, existingLivestock) {
    const recommendations = [];

    for (const [breedCode, breed] of this.livestockBreeds) {
      if (breed.idealStates.includes(stateCode)) {
        const suitability = this.calculateLivestockSuitability(breed, stateCode, farmArea, existingLivestock);

        if (suitability.score > 60) {
          const capacity = this.calculateStockingCapacity(breed, farmArea);
          const projectedRevenue = this.calculateLivestockRevenue(breed, capacity);

          recommendations.push({
            breedCode,
            breedName: breed.name,
            type: breed.type,
            suitability,
            capacity,
            projectedRevenue,
            feedRequirement: breed.feedRequirement,
            waterRequirement: breed.waterRequirement,
            characteristics: breed.characteristics
          });
        }
      }
    }

    recommendations.sort((a, b) => b.suitability.score - a.suitability.score);

    return {
      farmerOid,
      stateCode,
      farmArea,
      existingLivestock,
      recommendations: recommendations.slice(0, 3),
      generatedAt: new Date().toISOString()
    };
  }

  calculateLivestockSuitability(breed, stateCode, farmArea, existingLivestock) {
    let score = 100;
    const factors = [];

    // Climate suitability
    const stateClimate = this.getStateClimate(stateCode);
    if (stateClimate === 'arid' && breed.characteristics.droughtResistance === 'low') {
      score -= 25;
      factors.push({ factor: 'climate', reason: 'Low drought resistance', impact: -25 });
    }

    // Water availability
    const waterAvailability = await this.getWaterAvailability(stateCode);
    if (waterAvailability < breed.waterRequirement * 10) { // Simplified check
      score -= 20;
      factors.push({ factor: 'water', reason: 'Limited water availability', impact: -20 });
    }

    // Feed availability
    const feedAvailability = await this.getFeedAvailability(stateCode);
    if (feedAvailability < breed.feedRequirement * 10) {
      score -= 15;
      factors.push({ factor: 'feed', reason: 'Limited feed availability', impact: -15 });
    }

    // Market demand
    const marketDemand = this.checkLivestockMarketDemand(breed, stateCode);
    if (marketDemand < 60) {
      score -= 15;
      factors.push({ factor: 'market', reason: 'Low market demand', impact: -15 });
    }

    // Existing livestock compatibility
    if (existingLivestock && existingLivestock.length > 0) {
      const compatible = this.checkLivestockCompatibility(breed, existingLivestock);
      if (!compatible) {
        score -= 10;
        factors.push({ factor: 'compatibility', reason: 'May not be compatible with existing livestock', impact: -10 });
      }
    }

    return {
      score: Math.max(0, score),
      factors,
      recommendation: score > 75 ? 'Highly recommended' : score > 60 ? 'Recommended' : 'Consider alternatives'
    };
  }

  calculateStockingCapacity(breed, farmArea) {
    // Calculate how many animals can be supported
    let capacity = 0;

    switch (breed.type) {
      case 'cattle':
        capacity = Math.floor(farmArea * 0.5); // 0.5 cattle per hectare
        break;
      case 'sheep':
        capacity = Math.floor(farmArea * 2); // 2 sheep per hectare
        break;
      case 'goat':
        capacity = Math.floor(farmArea * 2.5); // 2.5 goats per hectare
        break;
      case 'camel':
        capacity = Math.floor(farmArea * 0.2); // 0.2 camels per hectare
        break;
      case 'poultry':
        capacity = Math.floor(farmArea * 50); // 50 chickens per hectare
        break;
    }

    return capacity;
  }

  calculateLivestockRevenue(breed, capacity) {
    let annualRevenue = 0;

    switch (breed.type) {
      case 'cattle':
        // Meat + Milk
        annualRevenue = capacity * (breed.characteristics.meatYield * 50000 + breed.characteristics.milkYield * 365 * 20);
        break;
      case 'sheep':
        // Meat + Wool
        annualRevenue = capacity * (breed.characteristics.meatYield * 40000 + breed.characteristics.woolYield * 10000);
        break;
      case 'goat':
        // Meat + Milk
        annualRevenue = capacity * (breed.characteristics.meatYield * 45000 + breed.characteristics.milkYield * 365 * 15);
        break;
      case 'camel':
        // Meat + Milk
        annualRevenue = capacity * (breed.characteristics.meatYield * 60000 + breed.characteristics.milkYield * 365 * 25);
        break;
      case 'poultry':
        // Eggs + Meat
        annualRevenue = capacity * (breed.characteristics.eggYield * 10 + breed.characteristics.meatYield * 30000);
        break;
    }

    return annualRevenue;
  }

  async generateAgriculturalPlan(farmerOid, farmData) {
    // Generate comprehensive agricultural plan
    const plan = {
      farmerOid,
      farmData,
      generatedAt: new Date().toISOString(),
      sections: []
    };

    // Section 1: Crop Plan
    const cropRecommendations = await this.getCropRecommendations(
      farmerOid,
      farmData.stateCode,
      farmData.farmArea,
      farmData.soilType
    );

    plan.sections.push({
      title: 'Crop Selection and Rotation',
      data: cropRecommendations,
      recommendations: this.generateCropRotationPlan(cropRecommendations)
    });

    // Section 2: Livestock Plan
    if (farmData.includeLivestock) {
      const livestockRecommendations = await this.getLivestockRecommendations(
        farmerOid,
        farmData.stateCode,
        farmData.farmArea,
        farmData.existingLivestock
      );

      plan.sections.push({
        title: 'Livestock Management',
        data: livestockRecommendations,
        recommendations: this.generateLivestockPlan(livestockRecommendations)
      });
    }

    // Section 3: Water Management
    const waterPlan = await this.generateWaterManagementPlan(farmerOid, farmData);
    plan.sections.push({
      title: 'Water Management',
      data: waterPlan,
      recommendations: waterPlan.recommendations
    });

    // Section 4: Market Access
    const marketPlan = await this.generateMarketAccessPlan(farmerOid, farmData);
    plan.sections.push({
      title: 'Market Access and Supply Chain',
      data: marketPlan,
      recommendations: marketPlan.recommendations
    });

    // Section 5: Financial Projections
    const financialPlan = await this.generateFinancialProjections(farmerOid, farmData);
    plan.sections.push({
      title: 'Financial Projections',
      data: financialPlan,
      recommendations: financialPlan.recommendations
    });

    // Store plan
    await pool.query(
      `INSERT INTO agricultural_plans
       (farmer_oid, plan_data, generated_at)
       VALUES ($1, $2, $3)`,
      [farmerOid, JSON.stringify(plan), new Date().toISOString()]
    );

    // Send notifications
    await this.sendPlanNotifications(farmerOid, plan);

    return plan;
  }

  generateCropRotationPlan(cropRecommendations) {
    const recommendations = [];

    if (cropRecommendations.recommendations.length > 1) {
      // Suggest crop rotation for better soil health
      const topCrops = cropRecommendations.recommendations.slice(0, 2);

      recommendations.push({
        type: 'rotation',
        message: `Consider rotating between ${topCrops[0].cropName} and ${topCrops[1].cropName} to maintain soil fertility`,
        reasoning: 'Different crops have different nutrient requirements and pest profiles'
      });
    }

    if (cropRecommendations.recommendations.some(c => c.suitability.score > 80)) {
      recommendations.push({
        type: 'focus',
        message: 'Focus on crops with high suitability scores (>80) for maximum profitability',
        reasoning: 'Higher suitability means better adaptation to local conditions'
      });
    }

    return recommendations;
  }

  generateLivestockPlan(livestockRecommendations) {
    const recommendations = [];

    if (livestockRecommendations.recommendations.length > 0) {
      const topBreed = livestockRecommendations.recommendations[0];

      recommendations.push({
        type: 'starter',
        message: `Start with ${topBreed.breedName} - best suited for your region`,
        reasoning: 'High suitability score indicates good adaptation'
      });
    }

    if (livestockRecommendations.existingLivestock && livestockRecommendations.existingLivestock.length > 0) {
      recommendations.push({
        type: 'integration',
        message: 'Consider integrating new livestock with existing stock gradually',
        reasoning: 'Reduces stress and allows for health monitoring'
      });
    }

    return recommendations;
  }

  async generateWaterManagementPlan(farmerOid, farmData) {
    // Integrate with Nile Water Management system
    const waterAllocation = await axios.post(
      `${process.env.NILE_WATER_SERVICE_URL}/api/v1/nile-water/allocation`,
      {
        farmerOid,
        farmLocation: farmData.location,
        cropType: farmData.preferredCrop || 'sorghum',
        farmArea: farmData.farmArea
      }
    );

    return {
      waterAllocation: waterAllocation.data.allocation,
      recommendations: [
        {
          type: 'irrigation',
          message: `Allocate ${waterAllocation.data.allocation.totalWaterNeeded} liters per season`,
          reasoning: 'Based on crop water requirements and local climate'
        },
        {
          type: 'conservation',
          message: 'Consider drip irrigation to reduce water usage by 30%',
          reasoning: 'Efficient irrigation reduces water waste and costs'
        }
      ]
    };
  }

  async generateMarketAccessPlan(farmerOid, farmData) {
    // Get market information
    const marketData = await this.getMarketData(farmData.stateCode);

    const recommendations = [];

    if (marketData.priceTrend === 'rising') {
      recommendations.push({
        type: 'timing',
        message: 'Market prices are rising - consider selling at optimal time',
        reasoning: 'Timing your sales can maximize revenue'
      });
    }

    if (marketData.localMarkets.length > 0) {
      recommendations.push({
        type: 'local_market',
        message: `Sell to local markets in ${marketData.localMarkets.join(', ')} for better margins`,
        reasoning: 'Reduced transportation costs'
      });
    }

    if (marketData.exportOpportunities.length > 0) {
      recommendations.push({
        type: 'export',
        message: 'Consider export opportunities for premium crops',
        reasoning: 'Higher prices in international markets'
      });
    }

    return {
      marketData,
      recommendations
    };
  }

  async generateFinancialProjections(farmerOid, farmData) {
    // Calculate costs and revenues
    const costs = {
      seeds: farmData.farmArea * 5000, // SDG per hectare
      fertilizer: farmData.farmArea * 3000,
      labor: farmData.farmArea * 2000,
      water: farmData.farmArea * 1000,
      equipment: 50000,
      total: 0
    };

    costs.total = Object.values(costs).reduce((sum, val) => sum + (typeof val === 'number' ? val : 0), 0);

    const revenues = {
      crop: 0,
      livestock: 0,
      total: 0
    };

    // Get crop recommendations
    const cropRecs = await this.getCropRecommendations(
      farmerOid,
      farmData.stateCode,
      farmData.farmArea,
      farmData.soilType
    );

    if (cropRecs.recommendations.length > 0) {
      revenues.crop = cropRecs.recommendations[0].projectedRevenue;
    }

    if (farmData.includeLivestock) {
      const livestockRecs = await this.getLivestockRecommendations(
        farmerOid,
        farmData.stateCode,
        farmData.farmArea,
        farmData.existingLivestock
      );

      if (livestockRecs.recommendations.length > 0) {
        revenues.livestock = livestockRecs.recommendations[0].projectedRevenue;
      }
    }

    revenues.total = revenues.crop + revenues.livestock;
    const netProfit = revenues.total - costs.total;
    const roi = costs.total > 0 ? ((netProfit / costs.total) * 100).toFixed(1) : 0;

    const recommendations = [];

    if (netProfit > 0) {
      recommendations.push({
        type: 'profit',
        message: `Projected annual profit: SDG ${netProfit.toLocaleString()}`,
        reasoning: 'Positive return on investment'
      });
    } else {
      recommendations.push({
        type: 'cost',
        message: 'Projected costs exceed revenues - consider reducing costs or increasing efficiency',
        reasoning: 'Financial sustainability required'
      });
    }

    if (roi > 20) {
      recommendations.push({
        type: 'investment',
        message: `Strong ROI of ${roi}% - consider expanding operations`,
        reasoning: 'Highly profitable venture'
      });
    }

    return {
      costs,
      revenues,
      netProfit,
      roi: parseFloat(roi),
      recommendations
    };
  }

  async startMarketMonitoring() {
    // Schedule market price updates
    cron.schedule('0 8 * * *', async () => { // 8 AM daily
      logger.info('Starting market price monitoring');

      try {
        await this.updateMarketPrices();
        await this.generateMarketAlerts();
      } catch (error) {
        logger.error('Market monitoring failed', { error: error.message });
      }
    });
  }

  async updateMarketPrices() {
    // Update market prices for agricultural products
    const products = [
      'sorghum', 'wheat', 'cotton', 'sesame', 'groundnuts', 'dates',
      'beef', 'mutton', 'goat_meat', 'camel_milk', 'chicken', 'eggs'
    ];

    for (const product of products) {
      // Simulate price updates (in production, integrate with market data APIs)
      const basePrice = this.getBasePrice(product);
      const variation = (Math.random() - 0.5) * 0.2; // ±10% variation
      const currentPrice = Math.round(basePrice * (1 + variation));

      await pool.query(
        `INSERT INTO market_prices
         (product, price, unit, state_code, recorded_at)
         VALUES ($1, $2, $3, $4, $5)`,
        [product, currentPrice, 'SDG/ton', '16', new Date().toISOString()]
      );

      this.marketPrices.set(product, {
        currentPrice,
        previousPrice: this.marketPrices.get(product)?.currentPrice || currentPrice,
        trend: this.calculatePriceTrend(currentPrice, this.marketPrices.get(product)?.currentPrice),
        lastUpdate: new Date().toISOString()
      });
    }

    logger.info('Market prices updated');
  }

  getBasePrice(product) {
    const prices = {
      'sorghum': 80000,
      'wheat': 120000,
      'cotton': 150000,
      'sesame': 250000,
      'groundnuts': 180000,
      'dates': 60000,
      'beef': 45000,
      'mutton': 40000,
      'goat_meat': 45000,
      'camel_milk': 25,
      'chicken': 30000,
      'eggs': 10
    };
    return prices[product] || 50000;
  }

  calculatePriceTrend(current, previous) {
    if (!previous) return 'stable';
    const change = ((current - previous) / previous) * 100;
    if (change > 5) return 'rising';
    if (change < -5) return 'falling';
    return 'stable';
  }

  async generateMarketAlerts() {
    // Generate price alerts for farmers
    const farmers = await pool.query(`
      SELECT
        c.oid as farmer_oid,
        c.phone_number,
        c.email,
        f.crop_type
      FROM citizens c
      JOIN farm_registry f ON c.oid = f.owner_oid
      WHERE f.status = 'active'
    `);

    for (const farmer of farmers.rows) {
      const currentPrice = this.marketPrices.get(farmer.crop_type);

      if (currentPrice && currentPrice.trend === 'rising') {
        // Send price increase alert
        await this.sendPriceAlert(farmer, currentPrice);
      }
    }
  }

  async sendPriceAlert(farmer, priceInfo) {
    const message = `Market Alert: ${farmer.crop_type} prices are rising! Current: SDG ${priceInfo.currentPrice.toLocaleString()}/ton. Consider selling soon.`;

    // In production, this would send SMS/email
    logger.info(`Price alert to ${farmer.farmer_oid}: ${message}`);

    await pool.query(
      `INSERT INTO market_alerts
       (farmer_oid, product, message, alert_type, sent_at)
       VALUES ($1, $2, $3, $4, $5)`,
      [farmer.farmer_oid, farmer.crop_type, message, 'PRICE_RISING', new Date().toISOString()]
    );
  }

  async sendPlanNotifications(farmerOid, plan) {
    // Send notifications about the generated plan
    const message = `Agricultural plan generated for your farm. Includes crop selection, livestock recommendations, and financial projections.`;

    // In production, this would send SMS/email
    logger.info(`Agricultural plan notification to ${farmerOid}`);

    await pool.query(
      `INSERT INTO agricultural_notifications
       (farmer_oid, message, type, sent_at)
       VALUES ($1, $2, $3, $4)`,
      [farmerOid, message, 'PLAN_GENERATED', new Date().toISOString()]
    );
  }

  // Helper methods
  getStateClimate(stateCode) {
    const climates = {
      '01': 'semi_arid', // Khartoum
      '02': 'arid', // Port Sudan
      '03': 'semi_arid', // North Kordofan
      '06': 'arid', // North Darfur
      '14': 'semi_arid', // Kassala
      '16': 'semi_arid', // Gezira
      '18': 'semi_arid' // Al Qadarif
    };
    return climates[stateCode] || 'semi_arid';
  }

  checkSoilCompatibility(crop, soilType) {
    const soilCompatibility = {
      'sorghum': ['sandy_loam', 'clay_loam', 'loam'],
      'wheat': ['loam', 'clay_loam'],
      'cotton': ['sandy_loam', 'loam'],
      'sesame': ['sandy_loam', 'loam'],
      'groundnuts': ['sandy_loam', 'loam'],
      'dates': ['sandy_loam', 'clay_loam'],
      'millet': ['sandy_loam', 'sandy']
    };

    const compatible = soilCompatibility[crop.scientificName?.split(' ')[0]?.toLowerCase()] || [];
    return compatible.includes(soilType);
  }

  checkMarketDemand(crop, stateCode) {
    // Simulate market demand
    const demandFactors = {
      '01': 90, // Khartoum - high demand
      '16': 85, // Gezira - high demand
      '06': 60, // North Darfur - medium demand
      '14': 70, // Kassala - medium demand
      '02': 50 // Port Sudan - lower demand
    };

    return demandFactors[stateCode] || 70;
  }

  checkLivestockMarketDemand(breed, stateCode) {
    const demandFactors = {
      'cattle': { '01': 90, '16': 85, '06': 70, '14': 75 },
      'sheep': { '06': 85, '07': 80, '08': 75, '09': 80, '10': 75 },
      'goat': { '01': 80, '03': 85, '14': 90, '16': 75 },
      'camel': { '02': 95, '14': 90, '06': 85 },
      'poultry': { '01': 95, '16': 90, '03': 85 }
    };

    const stateDemand = demandFactors[breed.type]?.[stateCode] || 70;
    return stateDemand;
  }

  checkLivestockCompatibility(newBreed, existingLivestock) {
    // Check if new breed is compatible with existing livestock
    // Simplified compatibility check
    const compatibleTypes = {
      'cattle': ['cattle', 'sheep', 'goat'],
      'sheep': ['sheep', 'goat', 'cattle'],
      'goat': ['goat', 'sheep', 'cattle'],
      'camel': ['camel'],
      'poultry': ['poultry']
    };

    const newType = newBreed.type;
    const existingTypes = existingLivestock.map(l => l.type);

    for (const existingType of existingTypes) {
      if (!compatibleTypes[newType]?.includes(existingType)) {
        return false;
      }
    }

    return true;
  }

  async getWaterAvailability(stateCode) {
    // Get water availability from Nile Water Management
    try {
      const response = await axios.get(
        `${process.env.NILE_WATER_SERVICE_URL}/api/v1/nile-water/monitoring`,
        { params: { days: 7 } }
      );

      const stationData = response.data.data.filter(d => {
        // Map state to station
        const stationMap = {
          '01': 'khartoum',
          '16': 'khartoum',
          '06': 'shandi',
          '14': 'kosti'
        };
        return d.station_id === stationMap[stateCode];
      });

      if (stationData.length > 0) {
        const latest = stationData[0];
        return latest.water_level > 10 ? 100 : 50; // Simplified availability
      }
    } catch (error) {
      logger.error('Failed to get water availability', { error: error.message });
    }

    return 70; // Default
  }

  async getFeedAvailability(stateCode) {
    // Get feed availability (simplified)
    const feedFactors = {
      '01': 80, // Khartoum - good feed access
      '16': 85, // Gezira - good feed access
      '06': 50, // North Darfur - limited feed
      '14': 60, // Kassala - moderate feed
      '02': 40 // Port Sudan - limited feed
    };

    return feedFactors[stateCode] || 60;
  }

  async getMarketData(stateCode) {
    // Get market data for state
    const prices = await pool.query(`
      SELECT product, price, recorded_at
      FROM market_prices
      WHERE state_code = $1
      ORDER BY recorded_at DESC
      LIMIT 50
    `, [stateCode]);

    const localMarkets = this.getLocalMarkets(stateCode);
    const exportOpportunities = this.getExportOpportunities(stateCode);
    const priceTrend = this.calculatePriceTrendFromData(prices.rows);

    return {
      prices: prices.rows,
      localMarkets,
      exportOpportunities,
      priceTrend,
      timestamp: new Date().toISOString()
    };
  }

  getLocalMarkets(stateCode) {
    const markets = {
      '01': ['Omdurman Market', 'Khartoum Central', 'Khartoum North'],
      '16': ['Wad Medani Market', 'Hasaheisa Market', 'Rabak Market'],
      '06': ['El Fasher Market', 'Nyala Market', 'Zalingei Market'],
      '14': ['Kassala Market', 'Doka Market', 'Gedaref Market'],
      '02': ['Port Sudan Market', 'Suakin Market']
    };

    return markets[stateCode] || ['Local Market'];
  }

  getExportOpportunities(stateCode) {
    const opportunities = {
      '01': ['Gum Arabic', 'Sesame', 'Cotton'],
      '16': ['Cotton', 'Wheat', 'Sorghum'],
      '06': ['Sesame', 'Gum Arabic', 'Groundnuts'],
      '14': ['Dates', 'Cotton', 'Sesame'],
      '02': ['Fish', 'Gum Arabic', 'Sesame']
    };

    return opportunities[stateCode] || [];
  }

  calculatePriceTrendFromData(prices) {
    if (prices.length < 2) return 'stable';

    const recent = prices.slice(0, 10);
    const older = prices.slice(10, 20);

    const avgRecent = recent.reduce((sum, p) => sum + p.price, 0) / recent.length;
    const avgOlder = older.length > 0 ? older.reduce((sum, p) => sum + p.price, 0) / older.length : avgRecent;

    const change = ((avgRecent - avgOlder) / avgOlder) * 100;

    if (change > 5) return 'rising';
    if (change < -5) return 'falling';
    return 'stable';
  }

  async getCurrentSeason(stateCode) {
    // Use same logic as Nile Water Management
    const month = new Date().getMonth() + 1;
    const rainfallPatterns = {
      '01': { dry: [11, 12, 1, 2, 3, 4], wet: [7, 8] },
      '16': { dry: [11, 12, 1, 2, 3, 4], wet: [7, 8] },
      '06': { dry: [11, 12, 1, 2, 3, 4, 5], wet: [10] },
      '14': { dry: [1, 2, 3, 4, 5, 6], wet: [11, 12] }
    };

    const pattern = rainfallPatterns[stateCode] || rainfallPatterns['01'];

    if (pattern.wet.includes(month)) return 'wet';
    if (pattern.dry.includes(month)) return 'dry';
    return 'normal';
  }
}

const farmingSystem = new FarmingAgricultureSystem();

// API Endpoints

// Get crop recommendations
app.post('/api/v1/farming/crop-recommendations', async (req, res) => {
  try {
    const { farmerOid, stateCode, farmArea, soilType } = req.body;

    if (!farmerOid || !stateCode || !farmArea || !soilType) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const recommendations = await farmingSystem.getCropRecommendations(
      farmerOid,
      stateCode,
      farmArea,
      soilType
    );

    res.json({
      success: true,
      recommendations,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Crop recommendations error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Get livestock recommendations
app.post('/api/v1/farming/livestock-recommendations', async (req, res) => {
  try {
    const { farmerOid, stateCode, farmArea, existingLivestock } = req.body;

    if (!farmerOid || !stateCode || !farmArea) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const recommendations = await farmingSystem.getLivestockRecommendations(
      farmerOid,
      stateCode,
      farmArea,
      existingLivestock || []
    );

    res.json({
      success: true,
      recommendations,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Livestock recommendations error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Generate agricultural plan
app.post('/api/v1/farming/generate-plan', async (req, res) => {
  try {
    const { farmerOid, farmData } = req.body;

    if (!farmerOid || !farmData) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const plan = await farmingSystem.generateAgriculturalPlan(farmerOid, farmData);

    res.json({
      success: true,
      plan,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Plan generation error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Get market data
app.get('/api/v1/farming/market-data', async (req, res) => {
  try {
    const { stateCode } = req.query;

    if (!stateCode) {
      return res.status(400).json({ error: 'Missing stateCode' });
    }

    const marketData = await farmingSystem.getMarketData(stateCode);

    res.json({
      success: true,
      marketData,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Market data error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Get agricultural plans
app.get('/api/v1/farming/plans/:farmerOid', async (req, res) => {
  try {
    const { farmerOid } = req.params;

    const result = await pool.query(
      `SELECT * FROM agricultural_plans
       WHERE farmer_oid = $1
       ORDER BY generated_at DESC
       LIMIT 10`,
      [farmerOid]
    );

    res.json({
      success: true,
      plans: result.rows,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Get plans error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Health check
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    service: 'Farming & Agriculture System',
    timestamp: new Date().toISOString(),
    version: '1.0.0',
    crops: farmingSystem.cropSchedules.size,
    livestock: farmingSystem.livestockBreeds.size,
    zones: farmingSystem.agriculturalZones.size
  });
});

const PORT = process.env.PORT || 3021;
app.listen(PORT, () => {
  logger.info(`Farming & Agriculture System running on port ${PORT}`);
  console.log(`Farming & Agriculture System running on port ${PORT}`);
});

module.exports = app;
 
3. GOLD & UNDERGROUND TREASURES MANAGEMENT SYSTEM
 
Module Overview
Automated management of gold, oil, uranium, and other underground resources with regulatory compliance and export tracking.
 
File: backend/gold-treasures-management/src/app.js
javascript
javascript
const express = require('express');
const { Pool } = require('pg');
const Redis = require('ioredis');
const { Kafka } = require('kafkajs');
const winston = require('winston');
const { v4: uuidv4 } = require('uuid');
const axios = require('axios');
const cron = require('node-cron');
const crypto = require('crypto');

const app = express();
app.use(express.json());

// Database connection
const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: process.env.DB_PORT
});

// Redis for caching
const redis = new Redis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD
});

// Kafka for event streaming
const kafka = new Kafka({
  clientId: 'gold-treasures-management',
  brokers: process.env.KAFKA_BROKERS?.split(',') || ['localhost:9092']
});

// Logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'gold-errors.log', level: 'error' }),
    new winston.transports.File({ filename: 'gold-combined.log' })
  ]
});

// Gold & Underground Treasures Management System
class GoldTreasuresManagement {
  constructor() {
    this.resourceTypes = new Map();
    this.miningZones = new Map();
    this.exportRegulations = new Map();
    this.priceIndices = new Map();
    this.initializeResourceTypes();
    this.initializeMiningZones();
    this.initializeExportRegulations();
    this.startPriceMonitoring();
  }

  initializeResourceTypes() {
    // Sudan's underground treasures
    this.resourceTypes.set('gold', {
      name: 'Gold',
      symbol: 'Au',
      density: 19.3, // g/cm³
      mohsHardness: 2.5,
      occurrence: 'Primary deposits in Nubian Shield, alluvial in rivers',
      majorDeposits: ['Haijder', 'Abu Marawat', 'Bir Nakheel', 'Koka'],
      production: 80, // tons/year (estimated)
      reserves: 1000, // tons (estimated)
      exportValue: 2.5, // billion USD/year
      regulatoryBody: 'Ministry of Minerals',
      licenseRequired: true,
      environmentalImpact: 'High',
      securityRisk: 'High'
    });

    this.resourceTypes.set('oil', {
      name: 'Oil',
      symbol: 'C,H',
      density: 0.85,
      mohsHardness: null,
      occurrence: 'Sedimentary basins in Sudan',
      majorDeposits: ['Muglad Basin', 'Melut Basin', 'Red Sea Basin'],
      production: 150000, // barrels/day
      reserves: 7000000000, // barrels
      exportValue: 5, // billion USD/year
      regulatoryBody: 'Ministry of Petroleum',
      licenseRequired: true,
      environmentalImpact: 'Very High',
      securityRisk: 'Medium'
    });

    this.resourceTypes.set('uranium', {
      name: 'Uranium',
      symbol: 'U',
      density: 19.1,
      mohsHardness: 6,
      occurrence: 'Granitic areas in Nubian Shield',
      majorDeposits: ['Nuba Mountains', 'Red Sea Hills'],
      production: 0, // tons/year (not currently produced)
      reserves: 5000, // tons (estimated)
      exportValue: 0, // billion USD/year
      regulatoryBody: 'Atomic Energy Commission',
      licenseRequired: 'Special',
      environmentalImpact: 'Very High',
      securityRisk: 'High'
    });

    this.resourceTypes.set('copper', {
      name: 'Copper',
      symbol: 'Cu',
      density: 8.96,
      mohsHardness: 3,
      occurrence: 'Porphyry deposits in Nubian Shield',
      majorDeposits: ['Abu Ghusun', 'Kabgawa'],
      production: 5000, // tons/year
      reserves: 200000, // tons
      exportValue: 0.1, // billion USD/year
      regulatoryBody: 'Ministry of Minerals',
      licenseRequired: true,
      environmentalImpact: 'Medium',
      securityRisk: 'Low'
    });

    this.resourceTypes.set('chromite', {
      name: 'Chromite',
      symbol: 'FeCr₂O₄',
      density: 4.5,
      mohsHardness: 5.5,
      occurrence: 'Layered intrusions in Nubian Shield',
      majorDeposits: ['Darfur', 'Kordofan'],
      production: 30000, // tons/year
      reserves: 500000, // tons
      exportValue: 0.05, // billion USD/year
      regulatoryBody: 'Ministry of Minerals',
      licenseRequired: true,
      environmentalImpact: 'Medium',
      securityRisk: 'Low'
    });

    this.resourceTypes.set('gypsum', {
      name: 'Gypsum',
      symbol: 'CaSO₄·2H₂O',
      density: 2.3,
      mohsHardness: 2,
      occurrence: 'Sedimentary deposits',
      majorDeposits: ['Khartoum', 'Kassala', 'Port Sudan'],
      production: 1000000, // tons/year
      reserves: 10000000, // tons
      exportValue: 0.02, // billion USD/year
      regulatoryBody: 'Ministry of Minerals',
      licenseRequired: false,
      environmentalImpact: 'Low',
      securityRisk: 'Low'
    });
  }

  initializeMiningZones() {
    // Sudanese mining zones
    this.miningZones.set('nubian_shield', {
      name: 'Nubian Shield',
      location: 'Eastern Sudan',
      states: ['14', '15'],
      area: 200000, // km²
      resources: ['gold', 'copper', 'chromite', 'uranium'],
      infrastructure: 'developed',
      security: 'medium',
      environmentalSensitivity: 'high',
      productionCapacity: 100, // tons gold equivalent/year
      licenseFee: 500000, // USD
      royaltyRate: 5 // %
    });

    this.miningZones.set('red_sea_basin', {
      name: 'Red Sea Basin',
      location: 'Eastern Sudan',
      states: ['02', '15'],
      area: 50000, // km²
      resources: ['oil', 'gas', 'gold'],
      infrastructure: 'developed',
      security: 'high',
      environmentalSensitivity: 'very_high',
      productionCapacity: 200000, // barrels oil/day
      licenseFee: 2000000, // USD
      royaltyRate: 10 // %
    });

    this.miningZones.set('muglad_basin', {
      name: 'Muglad Basin',
      location: 'Central Sudan',
      states: ['03', '04', '05'],
      area: 100000, // km²
      resources: ['oil'],
      infrastructure: 'moderate',
      security: 'medium',
      environmentalSensitivity: 'high',
      productionCapacity: 100000, // barrels oil/day
      licenseFee: 1500000, // USD
      royaltyRate: 8 // %
    });

    this.miningZones.set('melut_basin', {
      name: 'Melut Basin',
      location: 'South Sudan',
      states: ['06', '07', '08', '09', '10'],
      area: 80000, // km²
      resources: ['oil'],
      infrastructure: 'developing',
      security: 'low',
      environmentalSensitivity: 'medium',
      productionCapacity: 50000, // barrels oil/day
      licenseFee: 1000000, // USD
      royaltyRate: 7 // %
    });

    this.miningZones.set('nuba_mountains', {
      name: 'Nuba Mountains',
      location: 'South Kordofan',
      states: ['04'],
      area: 30000, // km²
      resources: ['uranium', 'gold', 'copper'],
      infrastructure: 'developing',
      security: 'low',
      environmentalSensitivity: 'very_high',
      productionCapacity: 0, // tons uranium/year
      licenseFee: 2000000, // USD
      royaltyRate: 15 // % (special rate for uranium)
    });
  }

  initializeExportRegulations() {
    // Sudanese export regulations for resources
    this.exportRegulations.set('gold', {
      name: 'Gold Export Regulations',
      exportDuty: 5, // %
      processingFee: 2, // %
      certificationRequired: true,
      certificationBody: 'Ministry of Minerals',
      assayRequirement: true,
      assayBodies: ['Sudan Gold Refinery', 'International Assayers'],
      exportQuota: null, // No quota
      prohibitedDestinations: ['Israel'],
      requiredDocuments: [
        'Mining License',
        'Export License',
        'Assay Certificate',
        'Certificate of Origin',
        'Customs Declaration'
      ],
      processingTime: 7, // days
      specialRequirements: [
        'Gold must be refined to 99.9% purity',
        'Export through designated ports only',
        'Transaction must be in USD or EUR'
      ]
    });

    this.exportRegulations.set('oil', {
      name: 'Oil Export Regulations',
      exportDuty: 0, // % (often exempt)
      processingFee: 1, // %
      certificationRequired: true,
      certificationBody: 'Ministry of Petroleum',
      assayRequirement: false,
      exportQuota: null,
      prohibitedDestinations: [],
      requiredDocuments: [
        'Production Sharing Agreement',
        'Export License',
        'Quality Certificate',
        'Bill of Lading',
        'Insurance Certificate'
      ],
      processingTime: 3, // days
      specialRequirements: [
        'Must use Sudanese tankers when available',
        'Environmental compliance required',
        'Revenue sharing with government'
      ]
    });

    this.exportRegulations.set('uranium', {
      name: 'Uranium Export Regulations',
      exportDuty: 25, // %
      processingFee: 5, // %
      certificationRequired: 'Special',
      certificationBody: 'Atomic Energy Commission',
      assayRequirement: true,
      exportQuota: 100, // tons/year
      prohibitedDestinations: ['All non-IAEA members'],
      requiredDocuments: [
        'Nuclear Material License',
        'IAEA Certification',
        'Export License (Special)',
        'Security Clearance',
        'Transportation Authorization'
      ],
      processingTime: 30, // days
      specialRequirements: [
        'Only for peaceful use',
        'Must comply with IAEA safeguards',
        'Special transportation requirements',
        'High security protocols'
      ]
    });

    this.exportRegulations.set('copper', {
      name: 'Copper Export Regulations',
      exportDuty: 3, // %
      processingFee: 1, // %
      certificationRequired: true,
      certificationBody: 'Ministry of Minerals',
      assayRequirement: true,
      exportQuota: null,
      prohibitedDestinations: [],
      requiredDocuments: [
        'Mining License',
        'Export License',
        'Assay Certificate',
        'Certificate of Origin',
        'Customs Declaration'
      ],
      processingTime: 5, // days
      specialRequirements: [
        'Must be in standard forms (ingots, cathodes)',
        'Quality standards must be met',
        'Environmental compliance required'
      ]
    });
  }

  async getMiningLicense(resourceType, zoneCode, companyInfo) {
    const resource = this.resourceTypes.get(resourceType);
    const zone = this.miningZones.get(zoneCode);

    if (!resource || !zone) {
      throw new Error('Invalid resource type or zone');
    }

    // Check if resource is available in zone
    if (!zone.resources.includes(resourceType)) {
      throw new Error(`${resourceType} not available in ${zone.name}`);
    }

    // Check company requirements
    const companyCheck = await this.checkCompanyRequirements(companyInfo, resource);

    if (!companyCheck.approved) {
      return {
        approved: false,
        reasons: companyCheck.reasons,
        requirements: companyCheck.requirements
      };
    }

    // Generate license
    const licenseId = uuidv4();
    const licenseNumber = `ML-${new Date().getFullYear()}-${resourceType.toUpperCase().slice(0, 3)}-${licenseId.slice(0, 8).toUpperCase()}`;

    const license = {
      licenseId,
      licenseNumber,
      resourceType,
      zoneCode,
      zoneName: zone.name,
      companyInfo,
      validityPeriod: {
        start: new Date().toISOString(),
        end: new Date(new Date().setFullYear(new Date().getFullYear() + 5)).toISOString()
      },
      productionQuota: this.calculateProductionQuota(resourceType, zone),
      royaltyRate: zone.royaltyRate,
      environmentalRequirements: this.getEnvironmentalRequirements(resourceType),
      securityRequirements: this.getSecurityRequirements(resourceType),
      complianceRequirements: this.getComplianceRequirements(resourceType),
      issuedAt: new Date().toISOString(),
      status: 'ACTIVE'
    };

    // Store license
    await pool.query(
      `INSERT INTO mining_licenses
       (license_id, license_number, resource_type, zone_code, company_info, license_data, issued_at, status)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
      [
        licenseId,
        licenseNumber,
        resourceType,
        zoneCode,
        JSON.stringify(companyInfo),
        JSON.stringify(license),
        new Date().toISOString(),
        'ACTIVE'
      ]
    );

    // Generate compliance certificate
    const complianceCert = await this.generateComplianceCertificate(license);

    return {
      approved: true,
      license,
      complianceCertificate: complianceCert,
      nextSteps: this.getNextSteps(resourceType)
    };
  }

  async checkCompanyRequirements(companyInfo, resource) {
    const requirements = {
      'gold': {
        minCapital: 1000000, // USD
        experience: 3, // years
        equipment: ['excavator', 'crusher', 'separator'],
        safety: true,
        environmental: true
      },
      'oil': {
        minCapital: 10000000, // USD
        experience: 5, // years
        equipment: ['drilling_rig', 'pipeline', 'storage'],
        safety: true,
        environmental: true,
        insurance: true
      },
      'uranium': {
        minCapital: 5000000, // USD
        experience: 10, // years
        equipment: ['specialized', 'security'],
        safety: true,
        environmental: true,
        nuclearLicense: true,
        securityClearance: true
      },
      'copper': {
        minCapital: 500000, // USD
        experience: 2, // years
        equipment: ['excavator', 'crusher', 'smelter'],
        safety: true,
        environmental: true
      }
    };

    const reqs = requirements[resource.name.toLowerCase()] || requirements['copper'];
    const reasons = [];
    const missingRequirements = [];

    if (companyInfo.capital < reqs.minCapital) {
      reasons.push(`Insufficient capital: ${companyInfo.capital} < ${reqs.minCapital} USD`);
      missingRequirements.push(`Minimum capital: ${reqs.minCapital} USD`);
    }

    if (companyInfo.experience < reqs.experience) {
      reasons.push(`Insufficient experience: ${companyInfo.experience} years < ${reqs.experience} years`);
      missingRequirements.push(`Minimum experience: ${reqs.experience} years`);
    }

    if (reqs.safety && !companyInfo.safetyCertified) {
      reasons.push('Safety certification required');
      missingRequirements.push('Safety certification');
    }

    if (reqs.environmental && !companyInfo.environmentalCertified) {
      reasons.push('Environmental certification required');
      missingRequirements.push('Environmental certification');
    }

    if (reqs.nuclearLicense && !companyInfo.nuclearLicense) {
      reasons.push('Nuclear license required');
      missingRequirements.push('Nuclear license');
    }

    if (reqs.securityClearance && !companyInfo.securityClearance) {
      reasons.push('Security clearance required');
      missingRequirements.push('Security clearance');
    }

    return {
      approved: reasons.length === 0,
      reasons,
      requirements: missingRequirements
    };
  }

  calculateProductionQuota(resourceType, zone) {
    const quotas = {
      'gold': {
        small: 10, // kg/year
        medium: 50,
        large: 200
      },
      'oil': {
        small: 10000, // barrels/day
        medium: 50000,
        large: 100000
      },
      'uranium': {
        small: 10, // tons/year
        medium: 50,
        large: 100
      },
      'copper': {
        small: 1000, // tons/year
        medium: 5000,
        large: 20000
      }
    };

    const category = zone.productionCapacity > 100000 ? 'large' :
                     zone.productionCapacity > 10000 ? 'medium' : 'small';

    return quotas[resourceType.toLowerCase()]?.[category] || 100;
  }

  getEnvironmentalRequirements(resourceType) {
    const requirements = {
      'gold': [
        'Environmental Impact Assessment (EIA)',
        'Water management plan',
        'Waste disposal plan',
        'Reclamation bond',
        'Monitoring program'
      ],
      'oil': [
        'Environmental Impact Assessment (EIA)',
        'Oil spill response plan',
        'Air emissions monitoring',
        'Water treatment facilities',
        'Decommissioning plan'
      ],
      'uranium': [
        'Radiation safety plan',
        'Waste management plan',
        'Environmental monitoring',
        'Security measures',
        'Decommissioning plan'
      ],
      'copper': [
        'Environmental Impact Assessment (EIA)',
        'Tailings management plan',
        'Water treatment plan',
        'Air quality monitoring',
        'Reclamation plan'
      ]
    };

    return requirements[resourceType.toLowerCase()] || requirements['copper'];
  }

  getSecurityRequirements(resourceType) {
    const requirements = {
      'gold': [
        'Security personnel',
        'Perimeter fencing',
        'Surveillance systems',
        'Access control',
        'Transport security'
      ],
      'oil': [
        'Pipeline security',
        'Facility security',
        'Transport security',
        'Cybersecurity measures',
        'Emergency response'
      ],
      'uranium': [
        'High-security fencing',
        'Armed guards',
        'Access control with biometrics',
        '24/7 surveillance',
        'Transport security (special)'
      ],
      'copper': [
        'Perimeter security',
        'Inventory control',
        'Transport security',
        'Access control'
      ]
    };

    return requirements[resourceType.toLowerCase()] || requirements['copper'];
  }

  getComplianceRequirements(resourceType) {
    const requirements = {
      'gold': [
        'Monthly production reports',
        'Quarterly financial reports',
        'Annual environmental audit',
        'Safety inspections',
        'Royalty payments'
      ],
      'oil': [
        'Daily production reports',
        'Monthly financial reports',
        'Quarterly environmental reports',
        'Safety inspections',
        'Revenue sharing payments'
      ],
      'uranium': [
        'Weekly security reports',
        'Monthly production reports',
        'Quarterly IAEA reports',
        'Annual safety audit',
        'Special royalty payments'
      ],
      'copper': [
        'Monthly production reports',
        'Quarterly financial reports',
        'Annual environmental audit',
        'Safety inspections',
        'Royalty payments'
      ]
    };

    return requirements[resourceType.toLowerCase()] || requirements['copper'];
  }

  getNextSteps(resourceType) {
    const steps = {
      'gold': [
        'Pay license fee',
        'Obtain environmental permits',
        'Set up security infrastructure',
        'Begin exploration',
        'Submit monthly reports'
      ],
      'oil': [
        'Pay license fee',
        'Obtain environmental permits',
        'Set up drilling infrastructure',
        'Begin exploration drilling',
        'Submit daily production reports'
      ],
      'uranium': [
        'Pay license fee',
        'Obtain nuclear permits',
        'Set up high-security infrastructure',
        'Begin exploration',
        'Submit weekly security reports',
        'Coordinate with IAEA'
      ],
      'copper': [
        'Pay license fee',
        'Obtain environmental permits',
        'Set up mining infrastructure',
        'Begin exploration',
        'Submit monthly reports'
      ]
    };

    return steps[resourceType.toLowerCase()] || steps['copper'];
  }

  async generateComplianceCertificate(license) {
    const certificateId = uuidv4();
    const certificateNumber = `CC-${new Date().getFullYear()}-${certificateId.slice(0, 8).toUpperCase()}`;

    const certificate = {
      certificateId,
      certificateNumber,
      licenseId: license.licenseId,
      licenseNumber: license.licenseNumber,
      resourceType: license.resourceType,
      complianceStatus: 'PENDING',
      requirements: license.complianceRequirements,
      auditSchedule: this.getAuditSchedule(license.resourceType),
      validUntil: license.validityPeriod.end,
      issuedAt: new Date().toISOString()
    };

    // Store certificate
    await pool.query(
      `INSERT INTO compliance_certificates
       (certificate_id, certificate_number, license_id, license_number, resource_type, certificate_data, issued_at)
       VALUES ($1, $2, $3, $4, $5, $6, $7)`,
      [
        certificateId,
        certificateNumber,
        license.licenseId,
        license.licenseNumber,
        license.resourceType,
        JSON.stringify(certificate),
        new Date().toISOString()
      ]
    );

    return certificate;
  }

  getAuditSchedule(resourceType) {
    const schedules = {
      'gold': ['Monthly', 'Quarterly', 'Annual'],
      'oil': ['Daily', 'Weekly', 'Monthly', 'Quarterly'],
      'uranium': ['Weekly', 'Monthly', 'Quarterly', 'Annual'],
      'copper': ['Monthly', 'Quarterly', 'Annual']
    };

    return schedules[resourceType.toLowerCase()] || schedules['copper'];
  }

  async exportResource(resourceType, quantity, quality, destination, companyLicense) {
    const resource = this.resourceTypes.get(resourceType);
    const regulation = this.exportRegulations.get(resourceType);

    if (!resource || !regulation) {
      throw new Error('Invalid resource type');
    }

    // Check license validity
    const licenseCheck = await this.checkLicenseValidity(companyLicense);
    if (!licenseCheck.valid) {
      throw new Error(`License invalid: ${licenseCheck.reason}`);
    }

    // Check export quota
    const quotaCheck = await this.checkExportQuota(resourceType, quantity);
    if (!quotaCheck.withinQuota) {
      throw new Error(`Export quota exceeded: ${quotaCheck.current} / ${quotaCheck.limit}`);
    }

    // Check destination restrictions
    if (regulation.prohibitedDestinations.includes(destination)) {
      throw new Error(`Export to ${destination} is prohibited`);
    }

    // Calculate duties and fees
    const valuation = await this.calculateExportValue(resourceType, quantity, quality);
    const duties = valuation * (regulation.exportDuty / 100);
    const fees = valuation * (regulation.processingFee / 100);
    const totalCost = duties + fees;

    // Generate export license
    const exportLicense = await this.generateExportLicense(
      resourceType,
      quantity,
      quality,
      destination,
      companyLicense,
      valuation,
      totalCost
    );

    // Update quota usage
    await this.updateExportQuota(resourceType, quantity);

    // Generate transport documents
    const transportDocs = await this.generateTransportDocuments(exportLicense);

    // Log export
    await this.logExport(resourceType, quantity, destination, valuation);

    return {
      exportLicense,
      transportDocuments: transportDocs,
      costs: {
        valuation,
        exportDuty: duties,
        processingFee: fees,
        total: totalCost
      },
      nextSteps: [
        'Arrange transportation',
        'Arrange insurance',
        'Submit customs declaration',
        'Arrange port clearance'
      ]
    };
  }

  async checkLicenseValidity(licenseNumber) {
    const result = await pool.query(
      `SELECT status, license_data
       FROM mining_licenses
       WHERE license_number = $1`,
      [licenseNumber]
    );

    if (result.rows.length === 0) {
      return { valid: false, reason: 'License not found' };
    }

    const license = result.rows[0];
    const licenseData = license.license_data;

    if (license.status !== 'ACTIVE') {
      return { valid: false, reason: `License status: ${license.status}` };
    }

    const validUntil = new Date(licenseData.validityPeriod.end);
    if (new Date() > validUntil) {
      return { valid: false, reason: 'License expired' };
    }

    return { valid: true, license: licenseData };
  }

  async checkExportQuota(resourceType, quantity) {
    const regulation = this.exportRegulations.get(resourceType);

    if (!regulation.exportQuota) {
      return { withinQuota: true, current: 0, limit: null };
    }

    const result = await pool.query(
      `SELECT SUM(quantity) as total
       FROM export_logs
       WHERE resource_type = $1
       AND EXTRACT(YEAR FROM exported_at) = EXTRACT(YEAR FROM CURRENT_DATE)`,
      [resourceType]
    );

    const current = parseFloat(result.rows[0]?.total || 0);
    const limit = regulation.exportQuota;

    return {
      withinQuota: current + quantity <= limit,
      current,
      limit,
      remaining: limit - current
    };
  }

  async calculateExportValue(resourceType, quantity, quality) {
    // Get current price
    const price = await this.getCurrentPrice(resourceType);

    // Quality adjustment
    let qualityMultiplier = 1.0;
    if (resourceType === 'gold') {
      if (quality >= 99.99) qualityMultiplier = 1.5;
      else if (quality >= 99.9) qualityMultiplier = 1.2;
      else if (quality >= 99.0) qualityMultiplier = 1.0;
      else qualityMultiplier = 0.8;
    } else if (resourceType === 'oil') {
      if (quality === 'light') qualityMultiplier = 1.1;
      else if (quality === 'medium') qualityMultiplier = 1.0;
      else qualityMultiplier = 0.9;
    }

    return price * quantity * qualityMultiplier;
  }

  async generateExportLicense(
    resourceType,
    quantity,
    quality,
    destination,
    companyLicense,
    valuation,
    totalCost
  ) {
    const licenseId = uuidv4();
    const licenseNumber = `EL-${new Date().getFullYear()}-${resourceType.toUpperCase().slice(0, 2)}-${licenseId.slice(0, 8).toUpperCase()}`;

    const license = {
      licenseId,
      licenseNumber,
      resourceType,
      quantity,
      quality,
      destination,
      companyLicense,
      valuation,
      totalCost,
      validity: {
        start: new Date().toISOString(),
        end: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString() // 30 days
      },
      issuedAt: new Date().toISOString(),
      status: 'ISSUED'
    };

    // Store export license
    await pool.query(
      `INSERT INTO export_licenses
       (license_id, license_number, resource_type, quantity, quality, destination, company_license,
        valuation, total_cost, validity_data, issued_at, status)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)`,
      [
        licenseId,
        licenseNumber,
        resourceType,
        quantity,
        quality,
        destination,
        companyLicense,
        valuation,
        totalCost,
        JSON.stringify(license.validity),
        new Date().toISOString(),
        'ISSUED'
      ]
    );

    return license;
  }

  async generateTransportDocuments(exportLicense) {
    const documents = {
      billOfLading: {
        number: `BOL-${exportLicense.licenseNumber.slice(-8)}`,
        issuedAt: new Date().toISOString(),
        vessel: 'To be assigned',
        portOfLoading: 'Port Sudan',
        portOfDischarge: exportLicense.destination,
        quantity: exportLicense.quantity,
        description: exportLicense.resourceType
      },
      insuranceCertificate: {
        number: `INS-${exportLicense.licenseNumber.slice(-8)}`,
        issuedAt: new Date().toISOString(),
        coverage: 'All risks',
        amount: exportLicense.valuation * 1.1,
        validity: exportLicense.validity.end
      },
      certificateOfOrigin: {
        number: `COO-${exportLicense.licenseNumber.slice(-8)}`,
        issuedAt: new Date().toISOString(),
        origin: 'Sudan',
        exporter: exportLicense.companyLicense
      }
    };

    return documents;
  }

  async logExport(resourceType, quantity, destination, valuation) {
    await pool.query(
      `INSERT INTO export_logs
       (resource_type, quantity, destination, valuation, exported_at)
       VALUES ($1, $2, $3, $4, $5)`,
      [resourceType, quantity, destination, valuation, new Date().toISOString()]
    );
  }

  async updateExportQuota(resourceType, quantity) {
    const regulation = this.exportRegulations.get(resourceType);

    if (regulation.exportQuota) {
      // Update quota tracking (simplified)
      await pool.query(
        `INSERT INTO export_quotas
         (resource_type, year, used, quota)
         VALUES ($1, EXTRACT(YEAR FROM CURRENT_DATE), $2, $3)
         ON CONFLICT (resource_type, year)
         DO UPDATE SET used = export_quotas.used + $2`,
        [resourceType, quantity, regulation.exportQuota]
      );
    }
  }

  async getCurrentPrice(resourceType) {
    // Get current price from database or API
    const result = await pool.query(
      `SELECT price, recorded_at
       FROM resource_prices
       WHERE resource_type = $1
       ORDER BY recorded_at DESC
       LIMIT 1`,
      [resourceType]
    );

    if (result.rows.length > 0) {
      return result.rows[0].price;
    }

    // Default prices (SDG per kg for metals, SDG per barrel for oil)
    const defaultPrices = {
      'gold': 25000000, // SDG per kg
      'oil': 2000, // SDG per barrel
      'uranium': 50000000, // SDG per kg
      'copper': 50000, // SDG per kg
      'chromite': 15000, // SDG per ton
      'gypsum': 500 // SDG per ton
    };

    return defaultPrices[resourceType] || 10000;
  }

  startPriceMonitoring() {
    // Schedule price updates
    cron.schedule('0 9 * * *', async () => { // 9 AM daily
      logger.info('Starting resource price monitoring');

      try {
        await this.updateResourcePrices();
        await this.generatePriceAlerts();
      } catch (error) {
        logger.error('Price monitoring failed', { error: error.message });
      }
    });
  }

  async updateResourcePrices() {
    // Update prices for all resources
    for (const [resourceType, resource] of this.resourceTypes) {
      const currentPrice = await this.getCurrentPrice(resourceType);

      // Simulate price change (±5%)
      const change = (Math.random() - 0.5) * 0.1;
      const newPrice = Math.round(currentPrice * (1 + change));

      await pool.query(
        `INSERT INTO resource_prices
         (resource_type, price, unit, recorded_at)
         VALUES ($1, $2, $3, $4)`,
        [resourceType, newPrice, 'SDG', new Date().toISOString()]
      );

      this.priceIndices.set(resourceType, {
        current: newPrice,
        previous: currentPrice,
        change: change * 100,
        trend: change > 0 ? 'rising' : 'falling',
        lastUpdate: new Date().toISOString()
      });
    }

    logger.info('Resource prices updated');
  }

  async generatePriceAlerts() {
    // Generate alerts for significant price changes
    for (const [resourceType, priceInfo] of this.priceIndices) {
      if (Math.abs(priceInfo.change) > 5) {
        await this.sendPriceAlert(resourceType, priceInfo);
      }
    }
  }

  async sendPriceAlert(resourceType, priceInfo) {
    const message = `Price Alert: ${resourceType} prices have changed by ${priceInfo.change.toFixed(1)}%. Current: SDG ${priceInfo.current.toLocaleString()}. Trend: ${priceInfo.trend}.`;

    // In production, send to relevant stakeholders
    logger.info(`Price alert for ${resourceType}: ${message}`);

    await pool.query(
      `INSERT INTO price_alerts
       (resource_type, message, change_percent, trend, sent_at)
       VALUES ($1, $2, $3, $4, $5)`,
      [resourceType, message, priceInfo.change, priceInfo.trend, new Date().toISOString()]
    );
  }

  async getResourceStatistics() {
    const productionStats = await pool.query(`
      SELECT
        resource_type,
        SUM(quantity) as total_quantity,
        AVG(valuation) as avg_value,
        COUNT(DISTINCT destination) as export_destinations
      FROM export_logs
      WHERE exported_at >= NOW() - INTERVAL '1 year'
      GROUP BY resource_type
    `);

    const licenseStats = await pool.query(`
      SELECT
        resource_type,
        COUNT(*) as active_licenses,
        SUM((license_data->>'productionQuota')::numeric) as total_quota
      FROM mining_licenses
      WHERE status = 'ACTIVE'
      GROUP BY resource_type
    `);

    const priceStats = await pool.query(`
      SELECT
        resource_type,
        AVG(price) as avg_price,
        MIN(price) as min_price,
        MAX(price) as max_price
      FROM resource_prices
      WHERE recorded_at >= NOW() - INTERVAL '30 days'
      GROUP BY resource_type
    `);

    return {
      production: productionStats.rows,
      licenses: licenseStats.rows,
      prices: priceStats.rows,
      timestamp: new Date().toISOString()
    };
  }
}

const goldManagement = new GoldTreasuresManagement();

// API Endpoints

// Apply for mining license
app.post('/api/v1/gold-treasures/mining-license', async (req, res) => {
  try {
    const { resourceType, zoneCode, companyInfo } = req.body;

    if (!resourceType || !zoneCode || !companyInfo) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const result = await goldManagement.getMiningLicense(resourceType, zoneCode, companyInfo);

    res.json({
      success: result.approved,
      ...result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Mining license error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Export resource
app.post('/api/v1/gold-treasures/export', async (req, res) => {
  try {
    const { resourceType, quantity, quality, destination, companyLicense } = req.body;

    if (!resourceType || !quantity || !destination || !companyLicense) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const result = await goldManagement.exportResource(
      resourceType,
      quantity,
      quality,
      destination,
      companyLicense
    );

    res.json({
      success: true,
      ...result,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Export error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Get resource statistics
app.get('/api/v1/gold-treasures/statistics', async (req, res) => {
  try {
    const stats = await goldManagement.getResourceStatistics();

    res.json({
      success: true,
      stats,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Statistics error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Get current prices
app.get('/api/v1/gold-treasures/prices', async (req, res) => {
  try {
    const prices = {};

    for (const [resourceType, info] of goldManagement.priceIndices) {
      prices[resourceType] = info;
    }

    res.json({
      success: true,
      prices,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Prices error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Health check
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    service: 'Gold & Treasures Management',
    timestamp: new Date().toISOString(),
    version: '1.0.0',
    resources: goldManagement.resourceTypes.size,
    zones: goldManagement.miningZones.size,
    regulations: goldManagement.exportRegulations.size
  });
});

const PORT = process.env.PORT || 3022;
app.listen(PORT, () => {
  logger.info(`Gold & Treasures Management running on port ${PORT}`);
  console.log(`Gold & Treasures Management running on port ${PORT}`);
});

module.exports = app;
 
4. RED SEA & PORTS MANAGEMENT SYSTEM
 
Module Overview
Automated port management, shipping logistics, customs clearance, and maritime security for Red Sea operations.
 
File: backend/red-sea-ports-management/src/app.js
javascript
javascript
const express = require('express');
const { Pool } = require('pg');
const Redis = require('ioredis');
const { Kafka } = require('kafkajs');
const winston = require('winston');
const { v4: uuidv4 } = require('uuid');
const axios = require('axios');
const cron = require('node-cron');

const app = express();
app.use(express.json());

// Database connection
const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: process.env.DB_PORT
});

// Redis for caching
const redis = new Redis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD
});

// Kafka for event streaming
const kafka = new Kafka({
  clientId: 'red-sea-ports-management',
  brokers: process.env.KAFKA_BROKERS?.split(',') || ['localhost:9092']
});

// Logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'port-errors.log', level: 'error' }),
    new winston.transports.File({ filename: 'port-combined.log' })
  ]
});

// Red Sea & Ports Management System
class RedSeaPortsManagement {
  constructor() {
    this.ports = new Map();
    this.shippingRoutes = new Map();
    this.customsProcedures = new Map();
    this.maritimeSecurityZones = new Map();
    this.initializePorts();
    this.initializeShippingRoutes();
    this.initializeCustomsProcedures();
    this.initializeMaritimeSecurityZones();
    this.startPortMonitoring();
  }

  initializePorts() {
    // Sudanese Red Sea ports
    this.ports.set('port_sudan', {
      name: 'Port Sudan',
      code: 'PSD',
      location: { lat: 19.6175, lng: 37.2164 },
      type: 'multi-purpose',
      capacity: {
        containers: 500000, // TEU/year
        general: 2000000, // tons/year
        bulk: 1000000, // tons/year
        liquid: 500000 // tons/year
      },
      infrastructure: {
        berths: 12,
        cranes: 8,
        warehouses: 15,
        storage: 500000, // m²
        depth: 14, // meters
        draft: 13.5 // meters
      },
      operations: {
        workingHours: '24/7',
        shiftPattern: '3 shifts',
        congestion: 'medium',
        efficiency: 75 // %
      },
      services: {
        bunkering: true,
        shipRepair: true,
        containerTerminal: true,
        RoRo: true,
        coldStorage: true
      },
      security: 'high',
      customs: 'automated',
      fees: {
        berthing: 500, // USD per meter per day
        pilotage: 2000, // USD per ship
        towage: 1500, // USD per operation
        portDues: 0.5 // % of cargo value
      }
    });

    this.ports.set('suakin', {
      name: 'Suakin',
      code: 'SUK',
      location: { lat: 19.1167, lng: 37.3333 },
      type: 'passenger',
      capacity: {
        passengers: 1000000, // per year
        vehicles: 50000 // per year
      },
      infrastructure: {
        berths: 4,
        passengerTerminal: true,
        vehicleRamp: true,
        depth: 10,
        draft: 9.5
      },
      operations: {
        workingHours: 'Daylight',
        shiftPattern: '1 shift',
        congestion: 'low',
        efficiency: 60 // %
      },
      services: {
        passengerFerry: true,
        vehicleFerry: true,
        customs: true
      },
      security: 'medium',
      customs: 'manual',
      fees: {
        passenger: 50, // USD per passenger
        vehicle: 200, // USD per vehicle
        portDues: 0.3 // % of cargo value
      }
    });

    this.ports.set('port_dongola', {
      name: 'Port Dongola',
      code: 'DGL',
      location: { lat: 19.1667, lng: 30.4833 },
      type: 'river',
      capacity: {
        general: 500000, // tons/year
        agricultural: 300000 // tons/year
      },
      infrastructure: {
        berths: 6,
        cranes: 3,
        warehouses: 8,
        storage: 200000,
        depth: 5,
        draft: 4.5
      },
      operations: {
        workingHours: 'Daylight',
        shiftPattern: '2 shifts',
        congestion: 'medium',
        efficiency: 65 // %
      },
      services: {
        agricultural: true,
        bulk: true,
        container: false
      },
      security: 'medium',
      customs: 'manual',
      fees: {
        berthing: 200,
        portDues: 0.4
      }
    });
  }

  initializeShippingRoutes() {
    // Red Sea shipping routes
    this.shippingRoutes.set('sudan_egypt', {
      name: 'Sudan-Egypt',
      from: 'port_sudan',
      to: 'suez', // Egypt
      distance: 650, // nautical miles
      transitTime: 2, // days
      frequency: 'daily',
      vessels: 'container, bulk, general',
      restrictions: 'None',
      securityRisk: 'medium',
      fees: {
        canal: 300000, // USD for Suez Canal
        insurance: 0.5 // % of cargo value
      }
    });

    this.shippingRoutes.set('sudan_saudi', {
      name: 'Sudan-Saudi Arabia',
      from: 'port_sudan',
      to: 'jeddah', // Saudi Arabia
      distance: 450, // nautical miles
      transitTime: 1.5, // days
      frequency: 'daily',
      vessels: 'container, RoRo, passenger',
      restrictions: 'None',
      securityRisk: 'low',
      fees: {
        port: 1000, // USD
        insurance: 0.3 // % of cargo value
      }
    });

    this.shippingRoutes.set('sudan_uae', {
      name: 'Sudan-UAE',
      from: 'port_sudan',
      to: 'dubai', // UAE
      distance: 1200, // nautical miles
      transitTime: 4, // days
      frequency: '3 times weekly',
      vessels: 'container, bulk, tanker',
      restrictions: 'None',
      securityRisk: 'low',
      fees: {
        port: 1500, // USD
        insurance: 0.4 // % of cargo value
      }
    });

    this.shippingRoutes.set('sudan_india', {
      name: 'Sudan-India',
      from: 'port_sudan',
      to: 'mumbai', // India
      distance: 2500, // nautical miles
      transitTime: 10, // days
      frequency: 'weekly',
      vessels: 'container, bulk',
      restrictions: 'None',
      securityRisk: 'medium',
      fees: {
        port: 2000, // USD
        insurance: 0.5 // % of cargo value
      }
    });

    this.shippingRoutes.set('sudan_europe', {
      name: 'Sudan-Europe',
      from: 'port_sudan',
      to: 'rotterdam', // Netherlands
      distance: 4500, // nautical miles
      transitTime: 18, // days
      frequency: 'bi-weekly',
      vessels: 'container, bulk, tanker',
      restrictions: 'None',
      securityRisk: 'medium',
      fees: {
        canal: 400000, // USD for Suez Canal
        insurance: 0.6 // % of cargo value
      }
    });
  }

  initializeCustomsProcedures() {
    // Customs procedures for different cargo types
    this.customsProcedures.set('general_cargo', {
      name: 'General Cargo',
      documents: [
        'Commercial Invoice',
        'Packing List',
        'Bill of Lading',
        'Certificate of Origin',
        'Import/Export License'
      ],
      clearanceTime: 2, // days
      inspections: '10% random',
      duties: {
        import: 15, // %
        export: 5, // %
        vat: 17 // %
      },
      specialRequirements: []
    });

    this.customsProcedures.set('containerized', {
      name: 'Containerized Cargo',
      documents: [
        'Commercial Invoice',
        'Packing List',
        'Bill of Lading',
        'Container Manifest',
        'Certificate of Origin',
        'Import/Export License'
      ],
      clearanceTime: 1, // days
      inspections: '5% random',
      duties: {
        import: 15, // %
        export: 5, // %
        vat: 17 // %
      },
      specialRequirements: [
        'Container must be sealed',
        'X-ray inspection available',
        'Priority clearance for perishables'
      ]
    });

    this.customsProcedures.set('bulk_cargo', {
      name: 'Bulk Cargo',
      documents: [
        'Commercial Invoice',
        'Bill of Lading',
        'Certificate of Origin',
        'Quality Certificate',
        'Import/Export License'
      ],
      clearanceTime: 3, // days
      inspections: '100% physical inspection',
      duties: {
        import: 10, // %
        export: 3, // %
        vat: 17 // %
      },
      specialRequirements: [
        'Weight verification',
        'Quality analysis',
        'Environmental compliance'
      ]
    });

    this.customsProcedures.set('liquid_cargo', {
      name: 'Liquid Cargo',
      documents: [
        'Commercial Invoice',
        'Bill of Lading',
        'Certificate of Origin',
        'Safety Data Sheet',
        'Import/Export License',
        'Environmental Permit'
      ],
      clearanceTime: 4, // days
      inspections: '100% inspection',
      duties: {
        import: 20, // %
        export: 8, // %
        vat: 17 // %
      },
      specialRequirements: [
        'Special handling facilities',
        'Environmental impact assessment',
        'Safety compliance certificate'
      ]
    });

    this.customsProcedures.set('perishable_cargo', {
      name: 'Perishable Cargo',
      documents: [
        'Commercial Invoice',
        'Packing List',
        'Bill of Lading',
        'Health Certificate',
        'Phytosanitary Certificate',
        'Import/Export License'
      ],
      clearanceTime: 0.5, // days (12 hours)
      inspections: '100% inspection',
      duties: {
        import: 5, // %
        export: 2, // %
        vat: 17 // %
      },
      specialRequirements: [
        'Priority clearance',
        'Cold chain maintenance',
        'Rapid inspection'
      ]
    });
  }

  initializeMaritimeSecurityZones() {
    // Red Sea maritime security zones
    this.maritimeSecurityZones.set('sudanese_waters', {
      name: 'Sudanese Territorial Waters',
      area: '0-12 nautical miles',
      jurisdiction: 'Sudan Navy',
      securityLevel: 'medium',
      patrolFrequency: 'daily',
      restrictions: [
        'No unauthorized vessels',
        'Fishing license required',
        'No military exercises without permission'
      ],
      emergencyProcedures: [
        'Contact Port Sudan VTS',
        'Sudan Navy will respond within 2 hours',
        'Coordinate with coast guard'
      ]
    });

    this.maritimeSecurityZones.set('red_sea_corridor', {
      name: 'Red Sea Shipping Corridor',
      area: '12-24 nautical miles',
      jurisdiction: 'Joint Patrol (Sudan, Egypt, Saudi)',
      securityLevel: 'high',
      patrolFrequency: 'continuous',
      restrictions: [
        'Mandatory AIS tracking',
        'Convoy system during high risk',
        'No anchoring without permission'
      ],
      emergencyProcedures: [
        'Contact regional coordination center',
        'Naval escort available',
        'International naval support available'
      ]
    });

    this.maritimeSecurityZones.set('piracy_risk_zone', {
      name: 'High Risk Zone',
      area: 'Gulf of Aden',
      jurisdiction: 'International Maritime Security',
      securityLevel: 'very_high',
      patrolFrequency: 'continuous',
      restrictions: [
        'Mandatory armed guards',
        'Convoy system required',
        'No night transit',
        'High risk insurance required'
      ],
      emergencyProcedures: [
        'Contact UKMTO',
        'Naval protection available',
        'Evacuation protocols'
      ]
    });
  }

  async getPortAvailability(portCode, vesselType, arrivalDate) {
    const port = this.ports.get(portCode);

    if (!port) {
      throw new Error(`Port ${portCode} not found`);
    }

    // Check vessel compatibility
    if (!this.isVesselCompatible(vesselType, port)) {
      return {
        available: false,
        reason: `Vessel type ${vesselType} not compatible with ${port.name}`,
        compatibleTypes: this.getCompatibleVessels(port)
      };
    }

    // Check berth availability
    const berthsAvailable = await this.checkBerthAvailability(portCode, arrivalDate);

    if (berthsAvailable < 1) {
      return {
        available: false,
        reason: 'No berths available on requested date',
        nextAvailable: await this.getNextAvailableDate(portCode, arrivalDate),
        waitTime: await this.getWaitTime(portCode, arrivalDate)
      };
    }

    // Calculate costs
    const costs = await this.calculatePortCosts(portCode, vesselType);

    return {
      available: true,
      port: port.name,
      berth: `Berth ${Math.floor(Math.random() * port.infrastructure.berths) + 1}`,
      arrivalDate,
      estimatedDuration: this.estimateBerthingTime(vesselType),
      costs,
      services: port.services,
      security: port.security,
      nextSteps: this.getPortNextSteps(portCode)
    };
  }

  isVesselCompatible(vesselType, port) {
    const compatibility = {
      'container': ['port_sudan'],
      'bulk': ['port_sudan', 'port_dongola'],
      'tanker': ['port_sudan'],
      'general': ['port_sudan', 'port_dongola'],
      'passenger': ['port_sudan', 'suakin'],
      'RoRo': ['port_sudan', 'suakin'],
      'fishing': ['port_sudan', 'suakin', 'port_dongola']
    };

    return compatibility[vesselType]?.includes(port.code) || false;
  }

  getCompatibleVessels(port) {
    const vesselTypes = {
      'port_sudan': ['container', 'bulk', 'tanker', 'general', 'passenger', 'RoRo', 'fishing'],
      'suakin': ['passenger', 'RoRo', 'fishing'],
      'port_dongola': ['bulk', 'general', 'fishing']
    };

    return vesselTypes[port.code] || [];
  }

  async checkBerthAvailability(portCode, date) {
    // Simulate berth availability check
    // In production, this would query real-time berth management system
    const port = this.ports.get(portCode);

    // Simulate congestion
    const congestion = port.operations.congestion;
    let availableBerths = port.infrastructure.berths;

    if (congestion === 'high') availableBerths = Math.floor(availableBerths * 0.3);
    else if (congestion === 'medium') availableBerths = Math.floor(availableBerths * 0.6);
    else if (congestion === 'low') availableBerths = Math.floor(availableBerths * 0.8);

    // Simulate some berths being occupied
    const occupied = Math.floor(Math.random() * (port.infrastructure.berths - availableBerths));

    return availableBerths - occupied;
  }

  async getNextAvailableDate(portCode, requestedDate) {
    // Find next available date (simplified)
    const date = new Date(requestedDate);
    date.setDate(date.getDate() + Math.floor(Math.random() * 3) + 1);
    return date.toISOString().split('T')[0];
  }

  async getWaitTime(portCode, requestedDate) {
    // Calculate wait time based on congestion
    const port = this.ports.get(portCode);
    const congestion = port.operations.congestion;

    const waitTimes = {
      'low': '0-2 hours',
      'medium': '2-12 hours',
      'high': '12-48 hours'
    };

    return waitTimes[congestion] || '2-12 hours';
  }

  calculatePortCosts(portCode, vesselType) {
    const port = this.ports.get(portCode);

    // Base costs
    const baseCosts = {
      berthing: port.fees.berthing * 20, // Assuming 20m vessel
      pilotage: port.fees.pilotage,
      towage: port.fees.towage
    };

    // Vessel type adjustments
    const adjustments = {
      'container': { berthing: 1.5, towage: 1.2 },
      'tanker': { berthing: 2.0, towage: 1.5 },
      'bulk': { berthing: 1.3, towage: 1.1 },
      'passenger': { berthing: 1.8, towage: 1.0 },
      'RoRo': { berthing: 1.4, towage: 1.1 }
    };

    const adjustment = adjustments[vesselType] || { berthing: 1.0, towage: 1.0 };

    return {
      berthing: Math.round(baseCosts.berthing * adjustment.berthing),
      pilotage: baseCosts.pilotage,
      towage: Math.round(baseCosts.towage * adjustment.towage),
      total: Math.round(
        baseCosts.berthing * adjustment.berthing +
        baseCosts.pilotage +
        baseCosts.towage * adjustment.towage
      )
    };
  }

  estimateBerthingTime(vesselType) {
    const times = {
      'container': 24, // hours
      'tanker': 36,
      'bulk': 48,
      'passenger': 12,
      'RoRo': 8,
      'fishing': 6
    };

    return times[vesselType] || 24;
  }

  getPortNextSteps(portCode) {
    const steps = {
      'port_sudan': [
        'Submit vessel arrival notification',
        'Arrange pilotage services',
        'Clear customs for cargo',
        'Coordinate with terminal operator',
        'Arrange cargo handling equipment'
      ],
      'suakin': [
        'Submit passenger manifest',
        'Arrange customs for passengers',
        'Coordinate with ferry terminal',
        'Arrange vehicle handling',
        'Clear immigration'
      ],
      'port_dongola': [
        'Submit arrival notification',
        'Arrange barge services',
        'Coordinate with agricultural warehouse',
        'Arrange bulk handling equipment',
        'Clear customs'
      ]
    };

    return steps[portCode] || steps['port_sudan'];
  }

  async calculateShippingCosts(routeCode, vesselType, cargoValue, cargoWeight) {
    const route = this.shippingRoutes.get(routeCode);

    if (!route) {
      throw new Error(`Route ${routeCode} not found`);
    }

    // Base costs
    const baseCosts = {
      fuel: Math.round(route.distance * 50), // USD per nautical mile
      crew: 5000, // USD per day
      portCharges: 2000,
      insurance: Math.round(cargoValue * (route.fees.insurance / 100))
    };

    // Canal fees (if applicable)
    let canalFee = 0;
    if (route.to === 'suez' || route.to === 'rotterdam') {
      canalFee = route.fees.canal;
    }

    // Vessel type adjustments
    const vesselAdjustments = {
      'container': 1.2,
      'tanker': 1.5,
      'bulk': 1.0,
      'passenger': 1.3,
      'RoRo': 1.1
    };

    const vesselMultiplier = vesselAdjustments[vesselType] || 1.0;

    // Calculate total
    const totalTransitCost = Math.round(
      (baseCosts.fuel + baseCosts.crew * route.transitTime + baseCosts.portCharges) * vesselMultiplier
    );

    const totalCost = totalTransitCost + canalFee + baseCosts.insurance;

    return {
      route: route.name,
      distance: route.distance,
      transitTime: route.transitTime,
      costs: {
        fuel: baseCosts.fuel,
        crew: baseCosts.crew * route.transitTime,
        portCharges: baseCosts.portCharges,
        canalFee,
        insurance: baseCosts.insurance,
        transitCost: totalTransitCost,
        total: totalCost
      },
      restrictions: route.restrictions,
      securityRisk: route.securityRisk
    };
  }

  async scheduleVesselArrival(portCode, vesselInfo, cargoDetails, arrivalDate) {
    // Generate vessel arrival schedule
    const port = this.ports.get(portCode);

    const scheduleId = uuidv4();
    const scheduleNumber = `VAS-${new Date().getFullYear()}-${scheduleId.slice(0, 8).toUpperCase()}`;

    const schedule = {
      scheduleId,
      scheduleNumber,
      portCode,
      portName: port.name,
      vesselInfo,
      cargoDetails,
      arrivalDate,
      estimatedBerthing: this.calculateBerthingTime(arrivalDate, port),
      servicesRequired: this.determineServices(vesselInfo.type, cargoDetails.type),
      estimatedCosts: await this.calculatePortCosts(portCode, vesselInfo.type),
      customsProcedure: this.getCustomsProcedure(cargoDetails.type),
      securityRequirements: this.getSecurityRequirements(portCode, vesselInfo),
      status: 'SCHEDULED',
      createdAt: new Date().toISOString()
    };

    // Store schedule
    await pool.query(
      `INSERT INTO vessel_schedules
       (schedule_id, schedule_number, port_code, vessel_info, cargo_details,
        arrival_date, schedule_data, status, created_at)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,
      [
        scheduleId,
        scheduleNumber,
        portCode,
        JSON.stringify(vesselInfo),
        JSON.stringify(cargoDetails),
        arrivalDate,
        JSON.stringify(schedule),
        'SCHEDULED',
        new Date().toISOString()
      ]
    );

    // Generate notifications
    await this.generateArrivalNotifications(schedule);

    return schedule;
  }

  calculateBerthingTime(arrivalDate, port) {
    // Add processing time based on port efficiency
    const processingTime = 24 - port.operations.efficiency; // hours
    const berthingDate = new Date(arrivalDate);
    berthingDate.setHours(berthingDate.getHours() + processingTime);

    return berthingDate.toISOString();
  }

  determineServices(vesselType, cargoType) {
    const services = {
      'container': ['container_terminal', 'crane_services', 'customs_clearance'],
      'tanker': ['liquid_terminal', 'pipeline_services', 'environmental_monitoring'],
      'bulk': ['bulk_terminal', 'conveyor_services', 'weight_verification'],
      'passenger': ['passenger_terminal', 'immigration_services', 'baggage_handling'],
      'RoRo': ['RoRo_terminal', 'vehicle_ramp', 'customs_clearance']
    };

    return services[vesselType] || ['general_terminal', 'customs_clearance'];
  }

  getCustomsProcedure(cargoType) {
    const procedures = {
      'containerized': 'containerized',
      'bulk': 'bulk_cargo',
      'liquid': 'liquid_cargo',
      'perishable': 'perishable_cargo',
      'general': 'general_cargo'
    };

    return procedures[cargoType] || 'general_cargo';
  }

  getSecurityRequirements(portCode, vesselInfo) {
    const requirements = [];

    if (portCode === 'port_sudan' && vesselInfo.type === 'tanker') {
      requirements.push('Firefighting equipment inspection');
      requirements.push('Environmental compliance check');
    }

    if (vesselInfo.grossTonnage > 10000) {
      requirements.push('Pilotage mandatory');
      requirements.push('Towage assistance required');
    }

    if (vesselInfo.hasHazardousCargo) {
      requirements.push('Special handling procedures');
      requirements.push('Emergency response plan');
    }

    return requirements;
  }

  async generateArrivalNotifications(schedule) {
    // Notify relevant authorities
    const notifications = [
      { recipient: 'Port Authority', message: `Vessel arrival scheduled: ${schedule.scheduleNumber}` },
      { recipient: 'Customs', message: `Cargo declaration required for: ${schedule.scheduleNumber}` },
      { recipient: 'Pilot Service', message: `Pilotage required for: ${schedule.scheduleNumber}` },
      { recipient: 'Terminal Operator', message: `Berth allocation: ${schedule.scheduleNumber}` }
    ];

    for (const notification of notifications) {
      await pool.query(
        `INSERT INTO arrival_notifications
         (schedule_id, recipient, message, sent_at)
         VALUES ($1, $2, $3, $4)`,
        [schedule.scheduleId, notification.recipient, notification.message, new Date().toISOString()]
      );
    }
  }

  async processCustomsClearance(scheduleId, documents) {
    const scheduleResult = await pool.query(
      `SELECT schedule_data FROM vessel_schedules WHERE schedule_id = $1`,
      [scheduleId]
    );

    if (scheduleResult.rows.length === 0) {
      throw new Error('Schedule not found');
    }

    const schedule = scheduleResult.rows[0].schedule_data;
    const procedure = this.customsProcedures.get(schedule.customsProcedure);

    // Validate documents
    const missingDocs = procedure.documents.filter(doc => !documents[doc]);

    if (missingDocs.length > 0) {
      return {
        cleared: false,
        missingDocuments: missingDocs,
        requiredDocuments: procedure.documents
      };
    }

    // Calculate duties
    const duties = this.calculateDuties(schedule, procedure);

    // Generate clearance certificate
    const clearanceId = uuidv4();
    const clearanceNumber = `CC-${new Date().getFullYear()}-${clearanceId.slice(0, 8).toUpperCase()}`;

    const clearance = {
      clearanceId,
      clearanceNumber,
      scheduleId,
      scheduleNumber: schedule.scheduleNumber,
      cargoType: schedule.cargoDetails.type,
      cargoValue: schedule.cargoDetails.value,
      duties,
      clearanceDate: new Date().toISOString(),
      validity: 30, // days
      status: 'CLEARED'
    };

    // Store clearance
    await pool.query(
      `INSERT INTO customs_clearances
       (clearance_id, clearance_number, schedule_id, schedule_number,
        cargo_type, cargo_value, duties, clearance_data, status, issued_at)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`,
      [
        clearanceId,
        clearanceNumber,
        scheduleId,
        schedule.scheduleNumber,
        schedule.cargoDetails.type,
        schedule.cargoDetails.value,
        JSON.stringify(duties),
        JSON.stringify(clearance),
        'CLEARED',
        new Date().toISOString()
      ]
    );

    // Update schedule status
    await pool.query(
      `UPDATE vessel_schedules SET status = 'CLEARED' WHERE schedule_id = $1`,
      [scheduleId]
    );

    return {
      cleared: true,
      clearance,
      duties,
      nextSteps: [
        'Arrange cargo handling',
        'Pay duties and fees',
        'Collect clearance certificate',
        'Proceed with loading/unloading'
      ]
    };
  }

  calculateDuties(schedule, procedure) {
    const cargoValue = schedule.cargoDetails.value;
    const duties = procedure.duties;

    const importDuty = Math.round(cargoValue * (duties.import / 100));
    const exportDuty = Math.round(cargoValue * (duties.export / 100));
    const vat = Math.round(cargoValue * (duties.vat / 100));

    const totalDuties = schedule.cargoDetails.direction === 'import' ?
      importDuty + vat : exportDuty + vat;

    return {
      importDuty,
      exportDuty,
      vat,
      total: totalDuties
    };
  }

  async startPortMonitoring() {
    // Schedule port status updates
    cron.schedule('*/30 * * * *', async () => { // Every 30 minutes
      logger.info('Starting port monitoring');

      try {
        await this.updatePortStatus();
        await this.generateCongestionAlerts();
      } catch (error) {
        logger.error('Port monitoring failed', { error: error.message });
      }
    });
  }

  async updatePortStatus() {
    // Update port congestion and efficiency
    for (const [portCode, port] of this.ports) {
      // Simulate status changes
      const efficiencyChange = (Math.random() - 0.5) * 5;
      const newEfficiency = Math.max(50, Math.min(95, port.operations.efficiency + efficiencyChange));

      port.operations.efficiency = newEfficiency;

      // Update congestion based on efficiency
      if (newEfficiency > 80) port.operations.congestion = 'low';
      else if (newEfficiency > 65) port.operations.congestion = 'medium';
      else port.operations.congestion = 'high';

      // Store in database
      await pool.query(
        `INSERT INTO port_status
         (port_code, port_name, efficiency, congestion, updated_at)
         VALUES ($1, $2, $3, $4, $5)
         ON CONFLICT (port_code)
         DO UPDATE SET efficiency = EXCLUDED.efficiency,
                       congestion = EXCLUDED.congestion,
                       updated_at = EXCLUDED.updated_at`,
        [
          portCode,
          port.name,
          newEfficiency,
          port.operations.congestion,
          new Date().toISOString()
        ]
      );
    }

    logger.info('Port status updated');
  }

  async generateCongestionAlerts() {
    // Generate alerts for high congestion
    for (const [portCode, port] of this.ports) {
      if (port.operations.congestion === 'high') {
        await this.sendCongestionAlert(portCode, port);
      }
    }
  }

  async sendCongestionAlert(portCode, port) {
    const message = `High congestion alert at ${port.name}. Current efficiency: ${port.operations.efficiency}%.`;

    await pool.query(
      `INSERT INTO port_alerts
       (port_code, alert_type, message, severity, sent_at)
       VALUES ($1, $2, $3, $4, $5)`,
      [portCode, 'CONGESTION', message, 'HIGH', new Date().toISOString()]
    );

    logger.info(`Congestion alert for ${port.name}`);
  }

  async getPortStatistics() {
    const scheduleStats = await pool.query(`
      SELECT
        port_code,
        COUNT(*) as total_schedules,
        COUNT(CASE WHEN status = 'SCHEDULED' THEN 1 END) as scheduled,
        COUNT(CASE WHEN status = 'CLEARED' THEN 1 END) as cleared,
        AVG((schedule_data->>'estimatedCosts'->>'total')::numeric) as avg_cost
      FROM vessel_schedules
      WHERE created_at >= NOW() - INTERVAL '30 days'
      GROUP BY port_code
    `);

    const customsStats = await pool.query(`
      SELECT
        cargo_type,
        COUNT(*) as total_clearances,
        AVG((duties->>'total')::numeric) as avg_duties,
        AVG(clearance_time) as avg_time
      FROM customs_clearances
      WHERE issued_at >= NOW() - INTERVAL '30 days'
      GROUP BY cargo_type
    `);

    const portStatus = await pool.query(`
      SELECT * FROM port_status
      WHERE updated_at >= NOW() - INTERVAL '1 hour'
    `);

    return {
      schedules: scheduleStats.rows,
      customs: customsStats.rows,
      status: portStatus.rows,
      timestamp: new Date().toISOString()
    };
  }
}

const redSeaPortsManagement = new RedSeaPortsManagement();

// API Endpoints

// Check port availability
app.post('/api/v1/ports/availability', async (req, res) => {
  try {
    const { portCode, vesselType, arrivalDate } = req.body;

    if (!portCode || !vesselType || !arrivalDate) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const availability = await redSeaPortsManagement.getPortAvailability(
      portCode,
      vesselType,
      arrivalDate
    );

    res.json({
      success: true,
      availability,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Port availability error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Calculate shipping costs
app.post('/api/v1/ports/shipping-costs', async (req, res) => {
  try {
    const { routeCode, vesselType, cargoValue, cargoWeight } = req.body;

    if (!routeCode || !vesselType || !cargoValue) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const costs = await redSeaPortsManagement.calculateShippingCosts(
      routeCode,
      vesselType,
      cargoValue,
      cargoWeight || 0
    );

    res.json({
      success: true,
      costs,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Shipping costs error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Schedule vessel arrival
app.post('/api/v1/ports/schedule-arrival', async (req, res) => {
  try {
    const { portCode, vesselInfo, cargoDetails, arrivalDate } = req.body;

    if (!portCode || !vesselInfo || !cargoDetails || !arrivalDate) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const schedule = await redSeaPortsManagement.scheduleVesselArrival(
      portCode,
      vesselInfo,
      cargoDetails,
      arrivalDate
    );

    res.json({
      success: true,
      schedule,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Schedule arrival error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Process customs clearance
app.post('/api/v1/ports/customs-clearance', async (req, res) => {
  try {
    const { scheduleId, documents } = req.body;

    if (!scheduleId || !documents) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const clearance = await redSeaPortsManagement.processCustomsClearance(
      scheduleId,
      documents
    );

    res.json({
      success: clearance.cleared,
      ...clearance,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Customs clearance error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Get port statistics
app.get('/api/v1/ports/statistics', async (req, res) => {
  try {
    const stats = await redSeaPortsManagement.getPortStatistics();

    res.json({
      success: true,
      stats,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Port statistics error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Health check
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    service: 'Red Sea & Ports Management',
    timestamp: new Date().toISOString(),
    version: '1.0.0',
    ports: redSeaPortsManagement.ports.size,
    routes: redSeaPortsManagement.shippingRoutes.size,
    customs: redSeaPortsManagement.customsProcedures.size
  });
});

const PORT = process.env.PORT || 3023;
app.listen(PORT, () => {
  logger.info(`Red Sea & Ports Management running on port ${PORT}`);
  console.log(`Red Sea & Ports Management running on port ${PORT}`);
});

module.exports = app;
 
5. EDUCATION MANAGEMENT SYSTEM
 
Module Overview
Automated education management, student tracking, curriculum management, and educational resource allocation.
 
File: backend/education-management/src/app.js
javascript
javascript
const express = require('express');
const { Pool } = require('pg');
const Redis = require('ioredis');
const { Kafka } = require('kafkajs');
const winston = require('winston');
const { v4: uuidv4 } = require('uuid');
const axios = require('axios');
const cron = require('node-cron');

const app = express();
app.use(express.json());

// Database connection
const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: process.env.DB_PORT
});

// Redis for caching
const redis = new Redis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD
});

// Kafka for event streaming
const kafka = new Kafka({
  clientId: 'education-management',
  brokers: process.env.KAFKA_BROKERS?.split(',') || ['localhost:9092']
});

// Logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'education-errors.log', level: 'error' }),
    new winston.transports.File({ filename: 'education-combined.log' })
  ]
});

// Education Management System
class EducationManagement {
  constructor() {
    this.educationLevels = new Map();
    this.curriculum = new Map();
    this.schools = new Map();
    this.studentPerformance = new Map();
    this.initializeEducationLevels();
    this.initializeCurriculum();
    this.initializeSchools();
    this.startPerformanceMonitoring();
  }

  initializeEducationLevels() {
    // Sudanese education system
    this.educationLevels.set('pre_primary', {
      name: 'Pre-Primary',
      duration: 2, // years
      ageRange: '3-5',
      focus: 'Early childhood development',
      curriculum: 'Play-based learning',
      requirements: ['Basic health check', 'Age verification'],
      capacityPerClass: 25,
      teacherQualification: 'Diploma in Early Childhood'
    });

    this.educationLevels.set('primary', {
      name: 'Primary',
      duration: 6, // years
      ageRange: '6-11',
      focus: 'Foundation skills',
      curriculum: 'National Curriculum',
      requirements: ['Completion of pre-primary', 'Age verification'],
      capacityPerClass: 35,
      teacherQualification: 'Bachelor in Education'
    });

    this.educationLevels.set('intermediate', {
      name: 'Intermediate',
      duration: 3, // years
      ageRange: '12-14',
      focus: 'General education',
      curriculum: 'National Curriculum',
      requirements: ['Completion of primary', 'Entrance exam'],
      capacityPerClass: 40,
      teacherQualification: 'Bachelor in Subject + Education'
    });

    this.educationLevels.set('secondary', {
      name: 'Secondary',
      duration: 3, // years
      ageRange: '15-17',
      focus: 'Specialized education',
      curriculum: 'Science/Arts streams',
      requirements: ['Completion of intermediate', 'Entrance exam'],
      capacityPerClass: 40,
      teacherQualification: 'Master in Subject + Education'
    });

    this.educationLevels.set('university', {
      name: 'University',
      duration: 4, // years
      ageRange: '18-22',
      focus: 'Higher education',
      curriculum: 'Degree programs',
      requirements: ['Secondary certificate', 'University entrance exam'],
      capacityPerClass: 100,
      teacherQualification: 'PhD or Master in Subject'
    });

    this.educationLevels.set('vocational', {
      name: 'Vocational Training',
      duration: 2, // years
      ageRange: '16+',
      focus: 'Skills development',
      curriculum: 'Technical/vocational',
      requirements: ['Secondary education or equivalent'],
      capacityPerClass: 20,
      teacherQualification: 'Industry experience + certification'
    });
  }

  initializeCurriculum() {
    // Sudanese national curriculum
    this.curriculum.set('primary_arabic', {
      level: 'primary',
      subject: 'Arabic Language',
      hoursPerWeek: 8,
      objectives: [
        'Reading and writing proficiency',
        'Basic grammar',
        'Comprehension skills',
        'Creative writing'
      ],
      assessment: ['Class tests', 'Oral exams', 'Written assignments'],
      resources: ['Textbooks', 'Workbooks', 'Digital content']
    });

    this.curriculum.set('primary_math', {
      level: 'primary',
      subject: 'Mathematics',
      hoursPerWeek: 6,
      objectives: [
        'Basic arithmetic',
        'Geometry fundamentals',
        'Problem solving',
        'Measurement'
      ],
      assessment: ['Class tests', 'Practical exercises', 'Exams'],
      resources: ['Textbooks', 'Manipulatives', 'Digital tools']
    });

    this.curriculum.set('primary_science', {
      level: 'primary',
      subject: 'Science',
      hoursPerWeek: 4,
      objectives: [
        'Basic biology',
        'Basic physics',
        'Environmental awareness',
        'Scientific method'
      ],
      assessment: ['Projects', 'Experiments', 'Tests'],
      resources: ['Textbooks', 'Lab equipment', 'Field trips']
    });

    this.curriculum.set('secondary_science', {
      level: 'secondary',
      subject: 'Science Stream',
      hoursPerWeek: 20,
      objectives: [
        'Physics fundamentals',
        'Chemistry fundamentals',
        'Biology fundamentals',
        'Mathematics for science'
      ],
      assessment: ['Internal exams', 'Practical exams', 'National exams'],
      resources: ['Textbooks', 'Lab equipment', 'Research projects']
    });

    this.curriculum.set('secondary_humanities', {
      level: 'secondary',
      subject: 'Humanities Stream',
      hoursPerWeek: 20,
      objectives: [
        'History of Sudan',
        'Islamic studies',
        'Geography',
        'Literature'
      ],
      assessment: ['Essays', 'Research papers', 'Oral presentations'],
      resources: ['Textbooks', 'Library resources', 'Field visits']
    });

    this.curriculum.set('vocational_electrical', {
      level: 'vocational',
      subject: 'Electrical Engineering',
      hoursPerWeek: 25,
      objectives: [
        'Circuit design',
        'Installation skills',
        'Safety procedures',
        'Maintenance'
      ],
      assessment: ['Practical tests', 'Project work', 'Certification exam'],
      resources: ['Workshop equipment', 'Safety gear', 'Industry visits']
    });
  }

  initializeSchools() {
    // Sudanese schools and educational institutions
    this.schools.set('khartoum_primary_1', {
      name: 'Khartoum Primary School #1',
      type: 'primary',
      location: { lat: 15.5007, lng: 32.5599 },
      stateCode: '01',
      capacity: 500,
      currentStudents: 450,
      teachers: 25,
      facilities: ['Library', 'Playground', 'Computer lab', 'Science lab'],
      performance: 85, // %
      resources: 'adequate',
      infrastructure: 'developed'
    });

    this.schools.set('gezira_secondary', {
      name: 'Gezira Secondary School',
      type: 'secondary',
      location: { lat: 14.4000, lng: 33.5167 },
      stateCode: '16',
      capacity: 800,
      currentStudents: 750,
      teachers: 40,
      facilities: ['Library', 'Science labs', 'Computer lab', 'Sports field', 'Auditorium'],
      performance: 78,
      resources: 'good',
      infrastructure: 'developed'
    });

    this.schools.set('port_sudan_vocational', {
      name: 'Port Sudan Vocational Training Center',
      type: 'vocational',
      location: { lat: 19.6175, lng: 37.2164 },
      stateCode: '02',
      capacity: 300,
      currentStudents: 280,
      teachers: 15,
      facilities: ['Workshops', 'Computer lab', 'Library', 'Dormitory'],
      performance: 82,
      resources: 'good',
      infrastructure: 'developed'
    });

    this.schools.set('kassala_primary', {
      name: 'Kassala Primary School',
      type: 'primary',
      location: { lat: 15.4500, lng: 36.4000 },
      stateCode: '14',
      capacity: 400,
      currentStudents: 350,
      teachers: 18,
      facilities: ['Library', 'Playground'],
      performance: 72,
      resources: 'limited',
      infrastructure: 'developing'
    });

    this.schools.set('university_khartoum', {
      name: 'University of Khartoum',
      type: 'university',
      location: { lat: 15.5007, lng: 32.5599 },
      stateCode: '01',
      capacity: 15000,
      currentStudents: 14000,
      teachers: 800,
      facilities: ['Library', 'Research labs', 'Sports facilities', 'Dormitories', 'Cafeterias'],
      performance: 88,
      resources: 'excellent',
      infrastructure: 'developed'
    });
  }

  async getStudentRecommendations(studentOid, age, currentLevel, stateCode) {
    const recommendations = [];
    const student = await this.getStudentProfile(studentOid);

    // Determine appropriate education level
    const currentLevelConfig = this.educationLevels.get(currentLevel);
    const nextLevel = this.getNextLevel(currentLevel, age);

    if (nextLevel) {
      const nextLevelConfig = this.educationLevels.get(nextLevel);

      recommendations.push({
        type: 'level_recommendation',
        currentLevel,
        nextLevel,
        nextLevelName: nextLevelConfig.name,
        duration: nextLevelConfig.duration,
        ageRange: nextLevelConfig.ageRange,
        requirements: nextLevelConfig.requirements,
        recommendation: 'Proceed to next level'
      });
    }

    // Get school recommendations based on performance and location
    const schoolRecommendations = await this.getSchoolRecommendations(
      studentOid,
      nextLevel || currentLevel,
      stateCode,
      student?.academicPerformance || 0
    );

    if (schoolRecommendations.length > 0) {
      recommendations.push({
        type: 'school_recommendations',
        schools: schoolRecommendations,
        recommendation: 'Consider these schools based on your location and performance'
      });
    }

    // Get curriculum recommendations
    const curriculumRecommendations = this.getCurriculumRecommendations(nextLevel || currentLevel);

    if (curriculumRecommendations.length > 0) {
      recommendations.push({
        type: 'curriculum_recommendations',
        subjects: curriculumRecommendations,
        recommendation: 'Focus on these subjects for academic success'
      });
    }

    // Get scholarship opportunities
    const scholarships = await this.getScholarshipOpportunities(studentOid, stateCode);

    if (scholarships.length > 0) {
      recommendations.push({
        type: 'scholarship_opportunities',
        scholarships,
        recommendation: 'Apply for scholarships to support education'
      });
    }

    return {
      studentOid,
      age,
      currentLevel,
      stateCode,
      recommendations,
      generatedAt: new Date().toISOString()
    };
  }

  getNextLevel(currentLevel, age) {
    const levelOrder = ['pre_primary', 'primary', 'intermediate', 'secondary', 'university', 'vocational'];
    const currentIndex = levelOrder.indexOf(currentLevel);

    if (currentIndex === -1) return null;
    if (currentIndex === levelOrder.length - 1) return null;

    const nextLevel = levelOrder[currentIndex + 1];
    const nextLevelConfig = this.educationLevels.get(nextLevel);

    // Check age appropriateness
    const ageRange = nextLevelConfig.ageRange.split('-').map(Number);
    if (age >= ageRange[0] && age <= ageRange[1]) {
      return nextLevel;
    }

    return null;
  }

  async getSchoolRecommendations(studentOid, level, stateCode, academicPerformance) {
    const schools = [];

    for (const [schoolCode, school] of this.schools) {
      if (school.type === level && school.stateCode === stateCode) {
        // Check capacity
        if (school.currentStudents < school.capacity) {
          // Calculate suitability score
          let score = 100;

          // Performance matching
          if (academicPerformance >= 80 && school.performance >= 80) {
            score += 10;
          } else if (academicPerformance >= 60 && school.performance >= 60) {
            score += 5;
          }

          // Resource matching
          if (school.resources === 'excellent' && academicPerformance >= 85) {
            score += 15;
          } else if (school.resources === 'good' && academicPerformance >= 70) {
            score += 10;
          }

          // Infrastructure
          if (school.infrastructure === 'developed') {
            score += 5;
          }

          schools.push({
            schoolCode,
            name: school.name,
            type: school.type,
            capacity: school.capacity,
            currentStudents: school.currentStudents,
            availableSeats: school.capacity - school.currentStudents,
            performance: school.performance,
            resources: school.resources,
            infrastructure: school.infrastructure,
            facilities: school.facilities,
            score,
            recommendation: score > 80 ? 'Highly recommended' : score > 60 ? 'Recommended' : 'Consider'
          });
        }
      }
    }

    // Sort by score
    return schools.sort((a, b) => b.score - a.score).slice(0, 3);
  }

  getCurriculumRecommendations(level) {
    const recommendations = [];

    const levelCurriculum = Array.from(this.curriculum.values())
      .filter(c => c.level === level)
      .slice(0, 5); // Top 5 subjects

    levelCurriculum.forEach(subject => {
      recommendations.push({
        subject: subject.subject,
        hoursPerWeek: subject.hoursPerWeek,
        objectives: subject.objectives.slice(0, 3), // Top 3 objectives
        assessment: subject.assessment,
        resources: subject.resources
      });
    });

    return recommendations;
  }

  async getScholarshipOpportunities(studentOid, stateCode) {
    // Get student profile
    const student = await this.getStudentProfile(studentOid);

    const scholarships = [];

    // Government scholarships
    if (student?.academicPerformance >= 70) {
      scholarships.push({
        name: 'Government Merit Scholarship',
        provider: 'Ministry of Education',
        amount: 'Full tuition',
        eligibility: 'Academic performance > 70%',
        applicationDeadline: '2024-06-30',
        priority: 'high'
      });
    }

    // State-specific scholarships
    const stateScholarships = {
      '01': ['Khartoum Excellence Scholarship'],
      '16': ['Gezira Agricultural Scholarship'],
      '02': ['Port Sudan Maritime Scholarship'],
      '14': ['Kassala Development Scholarship']
    };

    if (stateScholarships[stateCode]) {
      stateScholarships[stateCode].forEach(scholarship => {
        scholarships.push({
          name: scholarship,
          provider: `State of ${stateCode}`,
          amount: 'Partial tuition',
          eligibility: 'Resident of state',
          applicationDeadline: '2024-05-31',
          priority: 'medium'
        });
      });
    }

    // International scholarships
    if (student?.academicPerformance >= 85) {
      scholarships.push({
        name: 'International Excellence Scholarship',
        provider: 'Various International Organizations',
        amount: 'Full tuition + living expenses',
        eligibility: 'Top 10% academic performance',
        applicationDeadline: '2024-04-30',
        priority: 'high'
      });
    }

    return scholarships;
  }

  async getStudentProfile(studentOid) {
    const cacheKey = `student:${studentOid}`;
    const cached = await redis.get(cacheKey);

    if (cached) {
      return JSON.parse(cached);
    }

    const result = await pool.query(
      `SELECT
        c.oid,
        c.first_name,
        c.last_name,
        c.date_of_birth,
        c.state_code,
        s.academic_performance,
        s.grade_level,
        s.school_name,
        s.attendance_rate
       FROM citizens c
       LEFT JOIN student_profiles s ON c.oid = s.student_oid
       WHERE c.oid = $1`,
      [studentOid]
    );

    if (result.rows.length === 0) {
      return null;
    }

    const student = result.rows[0];
    await redis.setex(cacheKey, 3600, JSON.stringify(student));

    return student;
  }

  async generateEducationalPlan(studentOid, educationLevel, goals) {
    const student = await this.getStudentProfile(studentOid);

    if (!student) {
      throw new Error('Student not found');
    }

    const plan = {
      studentOid,
      studentName: `${student.first_name} ${student.last_name}`,
      educationLevel,
      goals,
      generatedAt: new Date().toISOString(),
      sections: []
    };

    // Section 1: Academic Pathway
    const academicPathway = await this.generateAcademicPathway(studentOid, educationLevel);
    plan.sections.push({
      title: 'Academic Pathway',
      data: academicPathway,
      recommendations: this.generateAcademicRecommendations(academicPathway)
    });

    // Section 2: Skill Development
    const skillDevelopment = await this.generateSkillDevelopmentPlan(studentOid, educationLevel);
    plan.sections.push({
      title: 'Skill Development',
      data: skillDevelopment,
      recommendations: skillDevelopment.recommendations
    });

    // Section 3: Career Planning
    const careerPlan = await this.generateCareerPlan(studentOid, educationLevel, goals);
    plan.sections.push({
      title: 'Career Planning',
      data: careerPlan,
      recommendations: careerPlan.recommendations
    });

    // Section 4: Extracurricular Activities
    const extracurricular = await this.generateExtracurricularPlan(studentOid);
    plan.sections.push({
      title: 'Extracurricular Activities',
      data: extracurricular,
      recommendations: extracurricular.recommendations
    });

    // Section 5: Support Services
    const supportServices = await this.generateSupportServices(studentOid);
    plan.sections.push({
      title: 'Support Services',
      data: supportServices,
      recommendations: supportServices.recommendations
    });

    // Store plan
    await pool.query(
      `INSERT INTO educational_plans
       (student_oid, plan_data, generated_at)
       VALUES ($1, $2, $3)`,
      [studentOid, JSON.stringify(plan), new Date().toISOString()]
    );

    // Send notifications
    await this.sendPlanNotifications(studentOid, plan);

    return plan;
  }

  async generateAcademicPathway(studentOid, currentLevel) {
    const pathway = {
      currentLevel,
      recommendedNextLevels: [],
      timeline: [],
      milestones: []
    };

    // Get next level recommendations
    const student = await this.getStudentProfile(studentOid);
    const age = this.calculateAge(student.date_of_birth);

    let level = currentLevel;
    for (let i = 0; i < 5; i++) {
      const nextLevel = this.getNextLevel(level, age + i * 2);
      if (nextLevel) {
        pathway.recommendedNextLevels.push({
          level: nextLevel,
          name: this.educationLevels.get(nextLevel).name,
          duration: this.educationLevels.get(nextLevel).duration,
          age: age + i * 2
        });
        level = nextLevel;
      } else {
        break;
      }
    }

    // Generate timeline
    let currentYear = new Date().getFullYear();
    pathway.recommendedNextLevels.forEach((levelInfo, index) => {
      pathway.timeline.push({
        year: currentYear + index,
        level: levelInfo.name,
        focus: this.educationLevels.get(levelInfo.level).focus
      });
    });

    // Set milestones
    pathway.milestones = [
      { year: currentYear, milestone: 'Complete current level' },
      { year: currentYear + 1, milestone: 'Transition to next level' },
      { year: currentYear + 2, milestone: 'Achieve target grades' },
      { year: currentYear + 3, milestone: 'Career planning begins' }
    ];

    return pathway;
  }

  generateAcademicRecommendations(pathway) {
    const recommendations = [];

    if (pathway.recommendedNextLevels.length > 0) {
      const nextLevel = pathway.recommendedNextLevels[0];
      recommendations.push({
        type: 'academic',
        message: `Focus on completing ${this.educationLevels.get(pathway.currentLevel).name} with good grades to qualify for ${nextLevel.name}`,
        priority: 'high'
      });
    }

    if (pathway.recommendedNextLevels.some(l => l.level === 'university')) {
      recommendations.push({
        type: 'university',
        message: 'Start preparing for university entrance exams 1 year in advance',
        priority: 'medium'
      });
    }

    return recommendations;
  }

  async generateSkillDevelopmentPlan(studentOid, educationLevel) {
    const skills = {
      digital: ['Computer literacy', 'Digital research', 'Online collaboration'],
      language: ['Arabic proficiency', 'English proficiency', 'Communication skills'],
      criticalThinking: ['Problem solving', 'Analysis', 'Creative thinking'],
      vocational: this.getVocationalSkills(educationLevel)
    };

    const recommendations = [];

    if (educationLevel === 'primary') {
      recommendations.push({
        type: 'foundation',
        message: 'Focus on reading, writing, and arithmetic fundamentals',
        priority: 'high'
      });
    } else if (educationLevel === 'secondary') {
      recommendations.push({
        type: 'specialization',
        message: 'Choose science or humanities stream based on interests',
        priority: 'high'
      });
      recommendations.push({
        type: 'digital',
        message: 'Develop computer skills for modern job market',
        priority: 'medium'
      });
    } else if (educationLevel === 'vocational') {
      recommendations.push({
        type: 'practical',
        message: 'Focus on hands-on skills and industry certifications',
        priority: 'high'
      });
    }

    return {
      skills,
      recommendations
    };
  }

  getVocationalSkills(level) {
    const skills = {
      'vocational': ['Technical skills', 'Safety procedures', 'Equipment operation', 'Quality control'],
      'secondary': ['Basic technical skills', 'Work ethics', 'Teamwork'],
      'university': ['Research skills', 'Project management', 'Specialized technical skills']
    };

    return skills[level] || [];
  }

  async generateCareerPlan(studentOid, educationLevel, goals) {
    const careers = await this.getCareerRecommendations(educationLevel, goals);

    const plan = {
      educationLevel,
      goals,
      recommendedCareers: careers.slice(0, 3),
      timeline: this.generateCareerTimeline(educationLevel, careers[0]?.timeline || 5),
      developmentPath: this.generateDevelopmentPath(educationLevel)
    };

    const recommendations = [];

    if (careers.length > 0) {
      recommendations.push({
        type: 'career',
        message: `Consider ${careers[0].name} - high growth potential in Sudan`,
        priority: 'high'
      });
    }

    if (educationLevel === 'university') {
      recommendations.push({
        type: 'internship',
        message: 'Seek internship opportunities during university years',
        priority: 'medium'
      });
    }

    return {
      ...plan,
      recommendations
    };
  }

  async getCareerRecommendations(educationLevel, goals) {
    const careers = [];

    // Education-based careers
    const educationCareers = {
      'primary': ['Primary Teacher', 'Childcare Worker', 'Educational Assistant'],
      'secondary': ['Secondary Teacher', 'Academic Advisor', 'Education Administrator'],
      'university': ['University Professor', 'Researcher', 'Academic Administrator'],
      'vocational': ['Vocational Trainer', 'Technical Instructor', 'Skills Assessor']
    };

    // Sudan-specific high-demand careers
    const sudanCareers = [
      { name: 'Agricultural Engineer', sector: 'Agriculture', growth: 15, education: 'university' },
      { name: 'Mining Engineer', sector: 'Mining', growth: 20, education: 'university' },
      { name: 'Renewable Energy Technician', sector: 'Energy', growth: 25, education: 'vocational' },
      { name: 'Port Logistics Manager', sector: 'Logistics', growth: 18, education: 'university' },
      { name: 'Digital Marketing Specialist', sector: 'Technology', growth: 30, education: 'university' },
      { name: 'Healthcare Administrator', sector: 'Healthcare', growth: 15, education: 'university' },
      { name: 'Construction Supervisor', sector: 'Construction', growth: 12, education: 'vocational' }
    ];

    // Filter by education level
    const levelCareers = sudanCareers.filter(c =>
      c.education === educationLevel ||
      (educationLevel === 'secondary' && c.education === 'vocational') ||
      (educationLevel === 'vocational' && c.education === 'secondary')
    );

    // Add education-based careers
    if (educationCareers[educationLevel]) {
      educationCareers[educationLevel].forEach(career => {
        careers.push({
          name: career,
          sector: 'Education',
          growth: 10,
          education: educationLevel
        });
      });
    }

    // Add Sudan-specific careers
    careers.push(...levelCareers);

    // Sort by growth
    return careers.sort((a, b) => b.growth - a.growth);
  }

  generateCareerTimeline(educationLevel, years) {
    const timeline = [];
    const startYear = new Date().getFullYear();

    for (let i = 0; i < years; i++) {
      let milestone = '';

      if (i === 0) milestone = 'Complete current education';
      else if (i === 1) milestone = 'Entry-level position';
      else if (i === 2) milestone = 'Skill development';
      else if (i === 3) milestone = 'Mid-level position';
      else if (i === 4) milestone = 'Advanced certification';
      else milestone = 'Senior position';

      timeline.push({
        year: startYear + i,
        milestone,
        actions: this.getCareerActions(educationLevel, i)
      });
    }

    return timeline;
  }

  getCareerActions(educationLevel, yearIndex) {
    const actions = {
      'primary': [
        'Focus on basic skills',
        'Develop good study habits',
        'Explore interests'
      ],
      'secondary': [
        'Choose academic stream',
        'Develop specialized skills',
        'Start career research'
      ],
      'university': [
        'Select major',
        'Gain internship experience',
        'Build professional network'
      ],
      'vocational': [
        'Choose technical field',
        'Complete certification',
        'Gain practical experience'
      ]
    };

    return actions[educationLevel] || [];
  }

  generateDevelopmentPath(educationLevel) {
    const paths = {
      'primary': [
        'Complete primary education',
        'Transition to intermediate',
        'Develop reading and math skills'
      ],
      'secondary': [
        'Choose science/humanities stream',
        'Prepare for university entrance',
        'Develop specialized knowledge'
      ],
      'university': [
        'Complete degree program',
        'Gain research experience',
        'Prepare for professional career'
      ],
      'vocational': [
        'Complete vocational training',
        'Obtain industry certification',
        'Gain work experience'
      ]
    };

    return paths[educationLevel] || [];
  }

  async generateExtracurricularPlan(studentOid) {
    const activities = [
      { name: 'Sports Club', benefits: ['Physical fitness', 'Teamwork', 'Discipline'] },
      { name: 'Arts & Culture', benefits: ['Creativity', 'Cultural awareness', 'Expression'] },
      { name: 'Science Club', benefits: ['Critical thinking', 'Problem solving', 'Innovation'] },
      { name: 'Debate Society', benefits: ['Communication', 'Leadership', 'Confidence'] },
      { name: 'Community Service', benefits: ['Social responsibility', 'Empathy', 'Networking'] }
    ];

    const recommendations = [
      {
        type: 'balance',
        message: 'Choose 1-2 activities that align with your interests and career goals',
        priority: 'high'
      },
      {
        type: 'development',
        message: 'Focus on activities that develop soft skills for future employment',
        priority: 'medium'
      }
    ];

    return {
      activities,
      recommendations
    };
  }

  async generateSupportServices(studentOid) {
    const services = [
      {
        name: 'Academic Tutoring',
        description: 'Additional help with challenging subjects',
        provider: 'School/Community',
        cost: 'Free or low cost',
        access: 'Available at school'
      },
      {
        name: 'Counseling Services',
        description: 'Academic and career guidance',
        provider: 'School counselor',
        cost: 'Free',
        access: 'By appointment'
      },
      {
        name: 'Library Access',
        description: 'Books, computers, research materials',
        provider: 'Public/School library',
        cost: 'Free',
        access: 'During library hours'
      },
      {
        name: 'Digital Learning',
        description: 'Online courses and educational platforms',
        provider: 'Various providers',
        cost: 'Free and paid options',
        access: 'Internet required'
      }
    ];

    const recommendations = [
      {
        type: 'utilization',
        message: 'Regularly use library and digital resources for self-study',
        priority: 'high'
      },
      {
        type: 'counseling',
        message: 'Meet with school counselor at least once per term',
        priority: 'medium'
      }
    ];

    return {
      services,
      recommendations
    };
  }

  async sendPlanNotifications(studentOid, plan) {
    const message = `Educational plan generated for ${plan.studentName}. Includes academic pathway, skill development, and career planning.`;

    // In production, this would send SMS/email
    logger.info(`Educational plan notification to ${studentOid}`);

    await pool.query(
      `INSERT INTO educational_notifications
       (student_oid, message, type, sent_at)
       VALUES ($1, $2, $3, $4)`,
      [studentOid, message, 'PLAN_GENERATED', new Date().toISOString()]
    );
  }

  calculateAge(dateOfBirth) {
    const birthDate = new Date(dateOfBirth);
    const today = new Date();
    let age = today.getFullYear() - birthDate.getFullYear();
    const monthDiff = today.getMonth() - birthDate.getMonth();

    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
      age--;
    }

    return age;
  }

  startPerformanceMonitoring() {
    // Schedule performance monitoring
    cron.schedule('0 6 * * *', async () => { // 6 AM daily
      logger.info('Starting education performance monitoring');

      try {
        await this.updateSchoolPerformance();
        await this.generatePerformanceAlerts();
      } catch (error) {
        logger.error('Performance monitoring failed', { error: error.message });
      }
    });
  }

  async updateSchoolPerformance() {
    // Update school performance metrics
    for (const [schoolCode, school] of this.schools) {
      // Simulate performance changes
      const performanceChange = (Math.random() - 0.5) * 5;
      const newPerformance = Math.max(50, Math.min(100, school.performance + performanceChange));

      school.performance = newPerformance;

      // Store in database
      await pool.query(
        `INSERT INTO school_performance
         (school_code, school_name, performance, updated_at)
         VALUES ($1, $2, $3, $4)
         ON CONFLICT (school_code)
         DO UPDATE SET performance = EXCLUDED.performance,
                       updated_at = EXCLUDED.updated_at`,
        [schoolCode, school.name, newPerformance, new Date().toISOString()]
      );
    }

    logger.info('School performance updated');
  }

  async generatePerformanceAlerts() {
    // Generate alerts for schools with low performance
    for (const [schoolCode, school] of this.schools) {
      if (school.performance < 60) {
        await this.sendPerformanceAlert(schoolCode, school);
      }
    }
  }

  async sendPerformanceAlert(schoolCode, school) {
    const message = `Performance alert: ${school.name} has performance of ${school.performance}%. Needs attention.`;

    await pool.query(
      `INSERT INTO performance_alerts
       (school_code, alert_type, message, severity, sent_at)
       VALUES ($1, $2, $3, $4, $5)`,
      [schoolCode, 'LOW_PERFORMANCE', message, 'MEDIUM', new Date().toISOString()]
    );

    logger.info(`Performance alert for ${school.name}`);
  }

  async getEducationStatistics() {
    const studentStats = await pool.query(`
      SELECT
        state_code,
        COUNT(*) as total_students,
        AVG(academic_performance) as avg_performance,
        AVG(attendance_rate) as avg_attendance
      FROM student_profiles
      WHERE updated_at >= NOW() - INTERVAL '30 days'
      GROUP BY state_code
    `);

    const schoolStats = await pool.query(`
      SELECT
        type,
        COUNT(*) as total_schools,
        AVG(capacity) as avg_capacity,
        AVG(current_students) as avg_enrollment,
        AVG(performance) as avg_performance
      FROM school_performance
      WHERE updated_at >= NOW() - INTERVAL '7 days'
      GROUP BY type
    `);

    const planStats = await pool.query(`
      SELECT
        DATE(generated_at) as date,
        COUNT(*) as total_plans
      FROM educational_plans
      WHERE generated_at >= NOW() - INTERVAL '30 days'
      GROUP BY DATE(generated_at)
      ORDER BY date DESC
      LIMIT 30
    `);

    return {
      students: studentStats.rows,
      schools: schoolStats.rows,
      plans: planStats.rows,
      timestamp: new Date().toISOString()
    };
  }
}

const educationManagement = new EducationManagement();

// API Endpoints

// Get student recommendations
app.post('/api/v1/education/student-recommendations', async (req, res) => {
  try {
    const { studentOid, age, currentLevel, stateCode } = req.body;

    if (!studentOid || !age || !currentLevel || !stateCode) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const recommendations = await educationManagement.getStudentRecommendations(
      studentOid,
      age,
      currentLevel,
      stateCode
    );

    res.json({
      success: true,
      recommendations,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Student recommendations error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Generate educational plan
app.post('/api/v1/education/generate-plan', async (req, res) => {
  try {
    const { studentOid, educationLevel, goals } = req.body;

    if (!studentOid || !educationLevel) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const plan = await educationManagement.generateEducationalPlan(
      studentOid,
      educationLevel,
      goals || []
    );

    res.json({
      success: true,
      plan,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Plan generation error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Get education statistics
app.get('/api/v1/education/statistics', async (req, res) => {
  try {
    const stats = await educationManagement.getEducationStatistics();

    res.json({
      success: true,
      stats,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Statistics error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Health check
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    service: 'Education Management',
    timestamp: new Date().toISOString(),
    version: '1.0.0',
    levels: educationManagement.educationLevels.size,
    curriculum: educationManagement.curriculum.size,
    schools: educationManagement.schools.size
  });
});

const PORT = process.env.PORT || 3024;
app.listen(PORT, () => {
  logger.info(`Education Management running on port ${PORT}`);
  console.log(`Education Management running on port ${PORT}`);
});

module.exports = app;
 
6. HEALTHCARE MANAGEMENT SYSTEM
 
Module Overview
Automated healthcare management, patient tracking, medical resource allocation, and health surveillance.
 
File: backend/healthcare-management/src/app.js
javascript
javascript
const express = require('express');
const { Pool } = require('pg');
const Redis = require('ioredis');
const { Kafka } = require('kafkajs');
const winston = require('winston');
const { v4: uuidv4 } = require('uuid');
const axios = require('axios');
const cron = require('node-cron');

const app = express();
app.use(express.json());

// Database connection
const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: process.env.DB_PORT
});

// Redis for caching
const redis = new Redis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD
});

// Kafka for event streaming
const kafka = new Kafka({
  clientId: 'healthcare-management',
  brokers: process.env.KAFKA_BROKERS?.split(',') || ['localhost:9092']
});

// Logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'healthcare-errors.log', level: 'error' }),
    new winston.transports.File({ filename: 'healthcare-combined.log' })
  ]
});

// Healthcare Management System
class HealthcareManagement {
  constructor() {
    this.healthFacilities = new Map();
    this.medicalConditions = new Map();
    this.treatmentProtocols = new Map();
    this.healthPrograms = new Map();
    this.initializeHealthFacilities();
    this.initializeMedicalConditions();
    this.initializeTreatmentProtocols();
    this.initializeHealthPrograms();
    this.startHealthMonitoring();
  }

  initializeHealthFacilities() {
    // Sudanese healthcare facilities
    this.healthFacilities.set('khartoum_hospital', {
      name: 'K      equipment: ['hartoum Teaching Hospital',
      type: 'teaching_hospital',
      location: { lat: 15.5007, lng: 32.5599 },
      stateCode: '01',
      capacity: {
        beds: 500,
        icu: 50,
        emergency: 100
      },
      staff: {
        doctors: 150,
        nurses: 300,
        specialists: 80
      },
      services: ['General medicine', 'Surgery', 'Pediatrics', 'Cardiology', 'Oncology', 'Emergency'],
MRI', 'CT Scan', 'X-Ray', 'Lab', 'Surgical'],
      performance: 85,
      resources: 'excellent',
      infrastructure: 'developed'
    });

    this.healthFacilities.set('gezira_medical', {
      name: 'Gezira Medical Center',
      type: 'regional_hospital',
      location: { lat: 14.4000, lng: 33.5167 },
      stateCode: '16',
      capacity: {
        beds: 200,
        icu: 20,
        emergency: 50
      },
      staff: {
        doctors: 60,
        nurses: 120,
        specialists: 30
      },
      services: ['General medicine', 'Surgery', 'Pediatrics', 'Maternity'],
      equipment: ['X-Ray', 'Lab', 'Ultrasound'],
      performance: 78,
      resources: 'good',
      infrastructure: 'developed'
    });

    this.healthFacilities.set('port_sudan_hospital', {
      name: 'Port Sudan General Hospital',
      type: 'general_hospital',
      location: { lat: 19.6175, lng: 37.2164 },
      stateCode: '02',
      capacity: {
        beds: 150,
        icu: 15,
        emergency: 40
      },
      staff: {
        doctors: 45,
        nurses: 90,
        specialists: 20
      },
      services: ['General medicine', 'Surgery', 'Emergency', 'Maternity'],
      equipment: ['X-Ray', 'Lab', 'Emergency'],
      performance: 72,
      resources: 'adequate',
      infrastructure: 'developing'
    });

    this.healthFacilities.set('kassala_clinic', {
      name: 'Kassala Primary Health Center',
      type: 'primary_health_center',
      location: { lat: 15.4500, lng: 36.4000 },
      stateCode: '14',
      capacity: {
        beds: 50,
        icu: 0,
        emergency: 20
      },
      staff: {
        doctors: 15,
        nurses: 30,
        specialists: 5
      },
      services: ['Primary care', 'Vaccinations', 'Maternal health', 'Child health'],
      equipment: ['Basic lab', 'Vaccination fridge', 'Basic emergency'],
      performance: 68,
      resources: 'limited',
      infrastructure: 'developing'
    });

    this.healthFacilities.set('rural_clinic', {
      name: 'Rural Health Clinic',
      type: 'rural_clinic',
      location: { lat: 13.5000, lng: 32.0000 },
      stateCode: '06',
      capacity: {
        beds: 10,
        icu: 0,
        emergency: 5
      },
      staff: {
        doctors: 2,
        nurses: 6,
        specialists: 0
      },
      services: ['Primary care', 'Vaccinations', 'Basic emergency'],
      equipment: ['Basic first aid', 'Vaccination fridge'],
      performance: 60,
      resources: 'very_limited',
      infrastructure: 'basic'
    });

    this.healthFacilities.set('mobile_unit', {
      name: 'Mobile Health Unit',
      type: 'mobile_unit',
      location: { lat: 0, lng: 0 }, // Mobile
      stateCode: 'multiple',
      capacity: {
        beds: 0,
        icu: 0,
        emergency: 5
      },
      staff: {
        doctors: 2,
        nurses: 4,
        specialists: 0
      },
      services: ['Vaccinations', 'Health education', 'Basic screening', 'Emergency response'],
      equipment: ['Mobile clinic kit', 'Vaccination fridge', 'Basic emergency'],
      performance: 75,
      resources: 'adequate',
      infrastructure: 'mobile'
    });
  }

  initializeMedicalConditions() {
    // Common medical conditions in Sudan
    this.medicalConditions.set('malaria', {
      name: 'Malaria',
      type: 'Infectious',
      prevalence: 'High',
      seasonality: 'Rainy season',
      riskFactors: ['Poor drainage', 'Mosquito breeding', 'Lack of bed nets'],
      symptoms: ['Fever', 'Chills', 'Headache', 'Muscle pain'],
      diagnosis: ['Blood test', 'Rapid diagnostic test'],
      treatment: ['ACT', 'Chloroquine'],
      prevention: ['Mosquito nets', 'Indoor spraying', 'Environmental management'],
      severity: 'Medium',
      mortalityRate: 2.5 // %
    });

    this.medicalConditions.set('schistosomiasis', {
      name: 'Schistosomiasis',
      type: 'Parasitic',
      prevalence: 'High',
      seasonality: 'Year-round',
      riskFactors: ['Contact with contaminated water', 'Poor sanitation'],
      symptoms: ['Abdominal pain', 'Blood in urine/stool', 'Fatigue'],
      diagnosis: ['Stool/urine examination', 'Serology'],
      treatment: ['Praziquantel'],
      prevention: ['Clean water', 'Sanitation', 'Health education'],
      severity: 'Medium',
      mortalityRate: 1.0
    });

    this.medicalConditions.set('malnutrition', {
      name: 'Malnutrition',
      type: 'Nutritional',
      prevalence: 'High',
      seasonality: 'Dry season',
      riskFactors: ['Food insecurity', 'Poverty', 'Poor feeding practices'],
      symptoms: ['Weight loss', 'Weakness', 'Swollen limbs', 'Development delay'],
      diagnosis: ['Anthropometric measurement', 'Blood tests'],
      treatment: ['Therapeutic feeding', 'Supplements', 'Diet counseling'],
      prevention: ['Food security programs', 'Breastfeeding support', 'Nutrition education'],
      severity: 'High',
      mortalityRate: 15.0
    });

    this.medicalConditions.set('respiratory_infections', {
      name: 'Respiratory Infections',
      type: 'Infectious',
      prevalence: 'High',
      seasonality: 'Cold season',
      riskFactors: ['Overcrowding', 'Poor ventilation', 'Malnutrition'],
      symptoms: ['Cough', 'Fever', 'Difficulty breathing', 'Chest pain'],
      diagnosis: ['Clinical examination', 'Chest X-ray'],
      treatment: ['Antibiotics', 'Oxygen therapy', 'Supportive care'],
      prevention: ['Vaccination', 'Ventilation', 'Hygiene'],
      severity: 'Medium',
      mortalityRate: 5.0
    });

    this.medicalConditions.set('diabetes', {
      name: 'Diabetes',
      type: 'Chronic',
      prevalence: 'Increasing',
      seasonality: 'None',
      riskFactors: ['Obesity', 'Genetics', 'Sedentary lifestyle'],
      symptoms: ['Increased thirst', 'Frequent urination', 'Fatigue', 'Weight loss'],
      diagnosis: ['Blood glucose test', 'HbA1c'],
      treatment: ['Insulin', 'Oral medications', 'Diet control', 'Exercise'],
      prevention: ['Healthy diet', 'Regular exercise', 'Weight management'],
      severity: 'High',
      mortalityRate: 8.0
    });

    this.medicalConditions.set('hypertension', {
      name: 'Hypertension',
      type: 'Chronic',
      prevalence: 'Increasing',
      seasonality: 'None',
      riskFactors: ['Stress', 'Obesity', 'High salt diet', 'Genetics'],
      symptoms: ['Headache', 'Dizziness', 'Vision problems', 'Chest pain'],
      diagnosis: ['Blood pressure measurement', 'ECG'],
      treatment: ['Lifestyle changes', 'Medications', 'Regular monitoring'],
      prevention: ['Low salt diet', 'Exercise', 'Stress management'],
      severity: 'High',
      mortalityRate: 12.0
    });
  }

  initializeTreatmentProtocols() {
    // Treatment protocols for common conditions
    this.treatmentProtocols.set('malaria_adult', {
      condition: 'malaria',
      ageGroup: 'adult',
      firstLine: 'ACT (Artemisinin-based Combination Therapy)',
      dosage: 'According to weight',
      duration: '3 days',
      followUp: 'Day 7 and 14',
      resistanceMonitoring: 'Required',
      referralCriteria: ['Severe malaria', 'Treatment failure', 'Complications']
    });

    this.treatmentProtocols.set('malaria_child', {
      condition: 'malaria',
      ageGroup: 'child',
      firstLine: 'ACT (child formulation)',
      dosage: 'According to weight',
      duration: '3 days',
      followUp: 'Day 7 and 14',
      resistanceMonitoring: 'Required',
      referralCriteria: ['Severe malaria', 'Treatment failure', 'Complications']
    });

    this.treatmentProtocols.set('schistosomiasis_adult', {
      condition: 'schistosomiasis',
      ageGroup: 'adult',
      firstLine: 'Praziquantel 40mg/kg',
      dosage: 'Single dose',
      duration: '1 day',
      followUp: '3 months',
      resistanceMonitoring: 'Not routine',
      referralCriteria: ['Severe disease', 'Treatment failure']
    });

    this.treatmentProtocols.set('malnutrition_child', {
      condition: 'malnutrition',
      ageGroup: 'child',
      firstLine: 'Therapeutic Ready-to-Use Therapeutic Food (RUTF)',
      dosage: 'According to weight',
      duration: '8-12 weeks',
      followUp: 'Weekly',
      resistanceMonitoring: 'Not applicable',
      referralCriteria: ['Severe acute malnutrition', 'Medical complications']
    });

    this.treatmentProtocols.set('pneumonia_adult', {
      condition: 'respiratory_infections',
      ageGroup: 'adult',
      firstLine: 'Amoxicillin',
      dosage: '500mg 3 times daily',
      duration: '7 days',
      followUp: 'Day 3 and 7',
      resistanceMonitoring: 'Required',
      referralCriteria: ['Severe pneumonia', 'Treatment failure', 'Complications']
    });
  }

  initializeHealthPrograms() {
    // National health programs
    this.healthPrograms.set('immunization', {
      name: 'National Immunization Program',
      target: 'Children under 5',
      vaccines: ['BCG', 'OPV', 'DTP', 'Hepatitis B', 'Measles', 'Pentavalent'],
      schedule: 'At birth, 6 weeks, 10 weeks, 14 weeks, 9 months',
      coverageTarget: 90, // %
      funding: 'Government + GAVI',
      implementation: 'National',
      monitoring: 'Monthly reporting'
    });

    this.healthPrograms.set('malaria_control', {
      name: 'Malaria Control Program',
      target: 'All population',
      interventions: ['LLIN distribution', 'IRS', 'ACT availability', 'RDT deployment'],
      coverageTarget: 80, // %
      funding: 'Global Fund + Government',
      implementation: 'National',
      monitoring: 'Quarterly surveillance'
    });

    this.healthPrograms.set('nutrition', {
      name: 'Nutrition Program',
      target: 'Children under 5, pregnant women',
      interventions: ['Supplementary feeding', 'Breastfeeding promotion', 'Nutrition education'],
      coverageTarget: 70, // %
      funding: 'WFP + Government',
      implementation: 'National',
      monitoring: 'Monthly surveys'
    });

    this.healthPrograms.set('maternal_health', {
      name: 'Maternal Health Program',
      target: 'Pregnant women',
      interventions: ['Antenatal care', 'Skilled birth attendance', 'Postnatal care'],
      coverageTarget: 85, // %
      funding: 'UNFPA + Government',
      implementation: 'National',
      monitoring: 'Monthly reporting'
    });

    this.healthPrograms.set('ncd_control', {
      name: 'NCD Control Program',
      target: 'Adult population',
      interventions: ['Screening', 'Treatment', 'Lifestyle education'],
      coverageTarget: 50, // %
      funding: 'WHO + Government',
      implementation: 'National',
      monitoring: 'Annual surveys'
    });
  }

  async getHealthRecommendations(patientOid, age, gender, stateCode, conditions = []) {
    const recommendations = [];

    // Get patient profile
    const patient = await this.getPatientProfile(patientOid);

    // Preventive care recommendations
    const preventive = await this.getPreventiveCareRecommendations(age, gender, stateCode);
    if (preventive.length > 0) {
      recommendations.push({
        type: 'preventive_care',
        recommendations: preventive,
        priority: 'high'
      });
    }

    // Disease-specific recommendations
    if (conditions.length > 0) {
      const diseaseRecs = await this.getDiseaseSpecificRecommendations(conditions);
      if (diseaseRecs.length > 0) {
        recommendations.push({
          type: 'disease_management',
          recommendations: diseaseRecs,
          priority: 'high'
        });
      }
    }

    // Facility recommendations based on location and needs
    const facilityRecs = await this.getFacilityRecommendations(stateCode, conditions);
    if (facilityRecs.length > 0) {
      recommendations.push({
        type: 'facility_recommendations',
        recommendations: facilityRecs,
        priority: 'medium'
      });
    }

    // Health program enrollment
    const programRecs = await this.getProgramRecommendations(age, gender, stateCode);
    if (programRecs.length > 0) {
      recommendations.push({
        type: 'health_programs',
        recommendations: programRecs,
        priority: 'medium'
      });
    }

    return {
      patientOid,
      age,
      gender,
      stateCode,
      currentConditions: conditions,
      recommendations,
      generatedAt: new Date().toISOString()
    };
  }

  async getPreventiveCareRecommendations(age, gender, stateCode) {
    const recommendations = [];

    // Age-based recommendations
    if (age < 5) {
      recommendations.push({
        service: 'Immunization',
        details: 'Ensure complete vaccination schedule',
        frequency: 'As per schedule',
        facility: 'Nearest health center',
        priority: 'Critical'
      });

      recommendations.push({
        service: 'Nutrition monitoring',
        details: 'Regular weight and height checks',
        frequency: 'Monthly',
        facility: 'Health center',
        priority: 'High'
      });
    } else if (age >= 5 && age < 15) {
      recommendations.push({
        service: 'School health screening',
        details: 'Vision, hearing, dental checks',
        frequency: 'Annually',
        facility: 'School health program',
        priority: 'Medium'
      });

      recommendations.push({
        service: 'Deworming',
        details: 'Regular deworming (every 6 months)',
        frequency: 'Every 6 months',
        facility: 'Health center',
        priority: 'Medium'
      });
    } else if (age >= 15 && age < 50) {
      if (gender === 'F') {
        recommendations.push({
          service: 'Reproductive health',
          details: 'Family planning, antenatal care if pregnant',
          frequency: 'As needed',
          facility: 'Health center',
          priority: 'High'
        });
      }

      recommendations.push({
        service: 'NCD screening',
        details: 'Blood pressure, blood sugar checks',
        frequency: 'Annually',
        facility: 'Health center',
        priority: 'Medium'
      });
    } else if (age >= 50) {
      recommendations.push({
        service: 'NCD management',
        details: 'Regular monitoring of chronic conditions',
        frequency: 'Quarterly',
        facility: 'Health center',
        priority: 'High'
      });

      recommendations.push({
        service: 'Cancer screening',
        details: 'Age-appropriate cancer screening',
        frequency: 'As per guidelines',
        facility: 'Hospital',
        priority: 'Medium'
      });
    }

    // State-specific recommendations
    const stateRecommendations = this.getStateSpecificPreventiveCare(stateCode);
    recommendations.push(...stateRecommendations);

    return recommendations;
  }

  getStateSpecificPreventiveCare(stateCode) {
    const recommendations = [];

    // Malaria-endemic states
    const malariaStates = ['06', '07', '08', '09', '10', '14', '15'];
    if (malariaStates.includes(stateCode)) {
      recommendations.push({
        service: 'Malaria prevention',
        details: 'Use mosquito nets, indoor spraying',
        frequency: 'Continuous',
        facility: 'Community health worker',
        priority: 'High'
      });
    }

    // Schistosomiasis-endemic states
    const schistoStates = ['11', '12', '13', '16', '17', '18'];
    if (schistoStates.includes(stateCode)) {
      recommendations.push({
        service: 'Schistosomiasis prevention',
        details: 'Avoid contact with contaminated water',
        frequency: 'Continuous',
        facility: 'Health education',
        priority: 'Medium'
      });
    }

    // Malnutrition-prone states
    const malnutritionStates = ['06', '07', '08', '09', '10', '14'];
    if (malnutritionStates.includes(stateCode)) {
      recommendations.push({
        service: 'Nutrition support',
        details: 'Supplementary feeding if underweight',
        frequency: 'As needed',
        facility: 'Nutrition program',
        priority: 'High'
      });
    }

    return recommendations;
  }

  async getDiseaseSpecificRecommendations(conditions) {
    const recommendations = [];

    for (const condition of conditions) {
      const protocol = this.treatmentProtocols.get(`${condition}_adult`) ||
                       this.treatmentProtocols.get(`${condition}_child`);

      if (protocol) {
        recommendations.push({
          condition,
          treatment: protocol.firstLine,
          duration: protocol.duration,
          followUp: protocol.followUp,
          referralCriteria: protocol.referralCriteria,
          priority: 'High'
        });
      }

      const conditionInfo = this.medicalConditions.get(condition);
      if (conditionInfo) {
        recommendations.push({
          condition,
          prevention: conditionInfo.prevention,
          riskFactors: conditionInfo.riskFactors,
          severity: conditionInfo.severity,
          priority: 'Medium'
        });
      }
    }

    return recommendations;
  }

  async getFacilityRecommendations(stateCode, conditions) {
    const facilities = [];

    for (const [facilityCode, facility] of this.healthFacilities) {
      if (facility.stateCode === stateCode || facility.stateCode === 'multiple') {
        // Check if facility can handle the conditions
        const canHandle = this.checkFacilityCapability(facility, conditions);

        if (canHandle && facility.capacity.beds > 0) {
          // Calculate suitability score
          let score = 100;

          // Performance factor
          score += facility.performance;

          // Resource factor
          if (facility.resources === 'excellent') score += 20;
          else if (facility.resources === 'good') score += 15;
          else if (facility.resources === 'adequate') score += 10;

          // Distance factor (simplified - in production, use actual distance)
          if (facility.type === 'rural_clinic' || facility.type === 'mobile_unit') {
            score += 10; // Closer for rural areas
          }

          facilities.push({
            facilityCode,
            name: facility.name,
            type: facility.type,
            capacity: facility.capacity,
            staff: facility.staff,
            services: facility.services,
            equipment: facility.equipment,
            performance: facility.performance,
            resources: facility.resources,
            score,
            recommendation: score > 80 ? 'Recommended' : score > 60 ? 'Consider' : 'Last resort'
          });
        }
      }
    }

    return facilities.sort((a, b) => b.score - a.score).slice(0, 3);
  }

  checkFacilityCapability(facility, conditions) {
    if (conditions.length === 0) return true;

    // Check if facility has required services
    const serviceMap = {
      'malaria': ['General medicine', 'Emergency'],
      'schistosomiasis': ['General medicine'],
      'malnutrition': ['Nutrition', 'Pediatrics'],
      'respiratory_infections': ['General medicine', 'Emergency'],
      'diabetes': ['General medicine', 'Chronic disease management'],
      'hypertension': ['General medicine', 'Chronic disease management']
    };

    for (const condition of conditions) {
      const requiredServices = serviceMap[condition];
      if (requiredServices) {
        const hasService = requiredServices.some(service =>
          facility.services.includes(service)
        );
        if (!hasService) return false;
      }
    }

    return true;
  }

  async getProgramRecommendations(age, gender, stateCode) {
    const programs = [];

    for (const [programCode, program] of this.healthPrograms) {
      let eligible = false;
      let reason = '';

      // Check eligibility
      if (programCode === 'immunization' && age < 5) {
        eligible = true;
        reason = 'Child under 5 years';
      } else if (programCode === 'malaria_control') {
        eligible = true;
        reason = 'All population in malaria-endemic areas';
      } else if (programCode === 'nutrition' && age < 5) {
        eligible = true;
        reason = 'Child under 5 years';
      } else if (programCode === 'maternal_health' && gender === 'F' && age >= 15 && age <= 49) {
        eligible = true;
        reason = 'Reproductive age woman';
      } else if (programCode === 'ncd_control' && age >= 30) {
        eligible = true;
        reason = 'Adult over 30 years';
      }

      if (eligible) {
        programs.push({
          programCode,
          name: program.name,
          target: program.target,
          interventions: program.interventions,
          coverageTarget: program.coverageTarget,
          funding: program.funding,
          reason,
          priority: 'Medium'
        });
      }
    }

    return programs;
  }

  async getPatientProfile(patientOid) {
    const cacheKey = `patient:${patientOid}`;
    const cached = await redis.get(cacheKey);

    if (cached) {
      return JSON.parse(cached);
    }

    const result = await pool.query(
      `SELECT
        c.oid,
        c.first_name,
        c.last_name,
        c.date_of_birth,
        c.gender,
        c.state_code,
        h.medical_history,
        h.allergies,
        h.current_medications,
        h.emergency_contact
       FROM citizens c
       LEFT JOIN health_profiles h ON c.oid = h.patient_oid
       WHERE c.oid = $1`,
      [patientOid]
    );

    if (result.rows.length === 0) {
      return null;
    }

    const patient = result.rows[0];
    await redis.setex(cacheKey, 3600, JSON.stringify(patient));

    return patient;
  }

  async generateHealthPlan(patientOid, age, gender, stateCode, conditions = []) {
    const patient = await this.getPatientProfile(patientOid);

    if (!patient) {
      throw new Error('Patient not found');
    }

    const plan = {
      patientOid,
      patientName: `${patient.first_name} ${patient.last_name}`,
      age,
      gender,
      stateCode,
      conditions,
      generatedAt: new Date().toISOString(),
      sections: []
    };

    // Section 1: Preventive Care Schedule
    const preventiveSchedule = await this.generatePreventiveSchedule(age, gender, stateCode);
    plan.sections.push({
      title: 'Preventive Care Schedule',
      data: preventiveSchedule,
      recommendations: preventiveSchedule.recommendations
    });

    // Section 2: Treatment Plan (if conditions present)
    if (conditions.length > 0) {
      const treatmentPlan = await this.generateTreatmentPlan(conditions, age);
      plan.sections.push({
        title: 'Treatment Plan',
        data: treatmentPlan,
        recommendations: treatmentPlan.recommendations
      });
    }

    // Section 3: Facility Access Plan
    const facilityPlan = await this.generateFacilityAccessPlan(stateCode, conditions);
    plan.sections.push({
      title: 'Facility Access Plan',
      data: facilityPlan,
      recommendations: facilityPlan.recommendations
    });

    // Section 4: Emergency Preparedness
    const emergencyPlan = await this.generateEmergencyPlan(stateCode, conditions);
    plan.sections.push({
      title: 'Emergency Preparedness',
      data: emergencyPlan,
      recommendations: emergencyPlan.recommendations
    });

    // Section 5: Health Education
    const educationPlan = await this.generateHealthEducationPlan(age, gender, stateCode, conditions);
    plan.sections.push({
      title: 'Health Education',
      data: educationPlan,
      recommendations: educationPlan.recommendations
    });

    // Store plan
    await pool.query(
      `INSERT INTO health_plans
       (patient_oid, plan_data, generated_at)
       VALUES ($1, $2, $3)`,
      [patientOid, JSON.stringify(plan), new Date().toISOString()]
    );

    // Send notifications
    await this.sendPlanNotifications(patientOid, plan);

    return plan;
  }

  async generatePreventiveSchedule(age, gender, stateCode) {
    const schedule = {
      age,
      gender,
      stateCode,
      preventiveServices: [],
      immunizationSchedule: [],
      screeningSchedule: []
    };

    // Age-based preventive services
    if (age < 5) {
      schedule.immunizationSchedule = [
        { vaccine: 'BCG', at: 'Birth', completed: false },
        { vaccine: 'OPV', at: 'At birth, 6 weeks, 10 weeks, 14 weeks', completed: false },
        { vaccine: 'Pentavalent', at: '6, 10, 14 weeks', completed: false },
        { vaccine: 'Measles', at: '9 months', completed: false }
      ];

      schedule.preventiveServices = [
        { service: 'Nutrition monitoring', frequency: 'Monthly', next: 'Next month' },
        { service: 'Deworming', frequency: 'Every 6 months', next: 'In 3 months' }
      ];
    } else if (age >= 5 && age < 15) {
      schedule.preventiveServices = [
        { service: 'School health screening', frequency: 'Annually', next: 'Next school year' },
        { service: 'Deworming', frequency: 'Every 6 months', next: 'In 3 months' },
        { service: 'Dental check', frequency: 'Annually', next: 'Next year' }
      ];

      schedule.screeningSchedule = [
        { test: 'Vision screening', frequency: 'Annually' },
        { test: 'Hearing screening', frequency: 'Annually' }
      ];
    } else if (age >= 15 && age < 50) {
      if (gender === 'F') {
        schedule.preventiveServices.push(
 'In 3 months' },
                 { service: 'Reproductive health consultation', frequency: 'As needed', next: 'When planning pregnancy' }
        );

        schedule.screeningSchedule.push(
          { test: 'Cervical cancer screening', frequency: 'Every 3 years after age 30' }
        );
      }

      schedule.preventiveServices.push(
        { service: 'NCD screening (BP, blood sugar)', frequency: 'Annually', next: 'Next year' }
      );
    } else if (age >= 50) {
      schedule.preventiveServices.push(
        { service: 'NCD management', frequency: 'Quarterly', next: { service: 'Cancer screening', frequency: 'As per guidelines', next: 'Consult physician' }
      );
    }

    // State-specific additions
    const stateAdditions = this.getStateSpecificPreventiveSchedule(stateCode);
    schedule.preventiveServices.push(...stateAdditions);

    const recommendations = [];

    if (schedule.immunizationSchedule.length > 0) {
      recommendations.push({
        type: 'immunization',
        message: 'Complete immunization schedule for child',
        priority: 'Critical'
      });
    }

    if (schedule.preventiveServices.length > 0) {
      recommendations.push({
        type: 'preventive',
        message: 'Follow preventive service schedule',
        priority: 'High'
      });
    }

    return {
      ...schedule,
      recommendations
    };
  }

  getStateSpecificPreventiveSchedule(stateCode) {
    const services = [];

    // Malaria-endemic states
    const malariaStates = ['06', '07', '08', '09', '10', '14', '15'];
    if (malariaStates.includes(stateCode)) {
      services.push(
        { service: 'Malaria prevention (nets/spraying)', frequency: 'Continuous', next: 'Ongoing' }
      );
    }

    // Schistosomiasis-endemic states
    const schistoStates = ['11', '12', '13', '16', '17', '18'];
    if (schistoStates.includes(stateCode)) {
      services.push(
        { service: 'Schistosomiasis prevention education', frequency: 'Continuous', next: 'Ongoing' }
      );
    }

    return services;
  }

  async generateTreatmentPlan(conditions, age) {
    const treatments = [];
    const recommendations = [];

    for (const condition of conditions) {
      const protocol = this.treatmentProtocols.get(`${condition}_adult`) ||
                       this.treatmentProtocols.get(`${condition}_child`);

      if (protocol) {
        treatments.push({
          condition,
          firstLineTreatment: protocol.firstLine,
          dosage: protocol.dosage,
          duration: protocol.duration,
          followUp: protocol.followUp,
          referralCriteria: protocol.referralCriteria
        });

        recommendations.push({
          type: 'treatment',
          message: `Start ${protocol.firstLine} for ${condition}`,
          priority: 'High'
        });
      }
    }

    return {
      conditions,
      treatments,
      recommendations
    };
  }

  async generateFacilityAccessPlan(stateCode, conditions)',
        priority: 'Medium'
      {
    const facilities = await this.getFacilityRecommendations(stateCode, conditions);

    const plan = {
      primaryFacility: facilities[0] || null,
      secondaryFacility: facilities[1] || null,
      emergencyFacility: facilities.find(f => f.type === 'general_hospital' || f.type === 'teaching_hospital'),
      mobileOption: facilities.find(f => f.type === 'mobile_unit'),
      distanceInfo: 'Within 30 minutes for emergency'
    };

    const recommendations = [];

    if (plan.primaryFacility) {
      recommendations.push({
        type: 'primary',
        message: `Register at ${plan.primaryFacility.name} for regular care`,
        priority: 'High'
      });
    }

    if (conditions.includes('malaria') || conditions.includes('schistosomiasis')) {
      recommendations.push({
        type: 'preventive',
        message: 'Use community health workers for preventive services });
    }

    return {
      ...plan,
      recommendations
    };
  }

  async generateEmergencyPlan(stateCode, conditions) {
    const emergencyInfo = {
      emergencyNumbers: {
        ambulance: '999',
        police: '999',
        fire: '999',
        health: '123'
      },
      nearestHospital: await this.getNearestHospital(stateCode),
      firstAid: this.getFirstAidProcedures(conditions),
      evacuationRoutes: this.getEvacuationRoutes(stateCode)
    };

    const recommendations = [
      {
        type: 'emergency',
        message: 'Save emergency numbers in phone',
        priority: 'High'
      },
      {
        type: 'first_aid',
        message: 'Learn basic first aid for your conditions',
        priority: 'Medium'
      }
    ];

    return {
      ...emergencyInfo,
      recommendations
    };
  }

  async getNearestHospital(stateCode) {
    // Find nearest hospital in state
    for (const [facilityCode, facility] of this.healthFacilities) {
      if (facility.stateCode === stateCode &&
          (facility.type === 'general_hospital' || facility.type === 'teaching_hospital')) {
        return {
          name: facility.name,
          location: facility.location,
          emergency: true
        };
      }
    }

    // Default to Khartoum if none in state
    return {
      name: 'Khartoum Teaching Hospital',
      location: { lat: 15.5007, lng: 32.5599 },
      emergency: true
    };
  }

  getFirstAidProcedures(conditions) {
    const procedures = [];

    if (conditions.includes('malaria')) {
      procedures.push({
        condition: 'Malaria fever',
        procedure: 'Keep patient cool, give fluids, seek medical help immediately'
      });
    }

    if (conditions.includes('respiratory_infections')) {
      procedures.push({
        condition: 'Difficulty breathing',
        procedure: 'Sit patient upright, gives to regional hospital', 'Mobile oxygen if available, call ambulance'
      });
    }

    if (conditions.includes('diabetes')) {
      procedures.push({
        condition: 'Low blood sugar',
        procedure: 'Give sugar/sweets, check blood sugar, call for help if not improving'
      });
    }

    if (conditions.length === 0) {
      procedures.push({
        condition: 'General emergency',
        procedure: 'Call ambulance, keep patient comfortable, do not move if injured'
      });
    }

    return procedures;
  }

  getEvacuationRoutes(stateCode) {
    const routes = {
      '01': ['Main roads to Khartoum Hospital', 'Emergency lanes'],
      '16': ['Roads to Gezira Medical Center', 'Secondary roads'],
      '02': ['Roads to Port Sudan Hospital', 'Coastal road'],
      '14': ['Roads to Kassala Hospital', 'Main highway'],
      '06': ['Road unit access']
    };

    return routes[stateCode] || ['Main roads to nearest hospital'];
  }

  async generateHealthEducationPlan(age, gender, stateCode, conditions) {
    const topics = [];

    // Age-based education
    if (age < 5) {
      topics.push({
        topic: 'Child nutrition',
        content: 'Breastfeeding, complementary feeding, hygiene',
        priority: 'High'
      });

      topics.push({
        topic: 'Immunization importance',
        content: 'Vaccine schedule, benefits, side effects',
        priority: 'High'
      });
    } else if (age >= 5 && age < 15) {
      topics.push({
        topic: 'Personal hygiene',
        content: 'Handwashing, dental care, sanitation',
        priority: 'Medium'
      });

      topics.push({
        topic: 'Disease prevention',
        content: 'Malaria prevention, schistosomiasis avoidance',
        priority: 'Medium'
      });
    } else if (age >= 15) {
      if (gender === 'F') {
        topics.push({
          topic: 'Reproductive health',
          content: 'Family planning, pregnancy care, STI prevention',
          priority: 'High'
        });
      }

      topics.push({
        topic: 'NCD prevention',
        content: 'Healthy diet, exercise, smoking cessation',
        priority: 'High'
      });
    }

    // Condition-specific education
    for (const condition of conditions) {
      const conditionInfo = this.medicalConditions.get(condition);
      if (conditionInfo) {
        topics.push({
          topic: `${condition} management`,
          content: `Symptoms: ${conditionInfo.symptoms.join(', ')}. Treatment: ${conditionInfo.treatment.join(', ')}. Prevention: ${conditionInfo.prevention.join(', ')}`,
          priority: 'High'
        });
      }
    }

    // State-specific education
    const stateTopics = this.getStateSpecificHealthEducation(stateCode);
    topics.push(...stateTopics);

    const recommendations = [
      {
        type: 'education',
        message: 'Attend health education sessions at local health center',
        priority: 'Medium'
      },
      {
        type: 'self_management',
        message: 'Learn self-management techniques for chronic conditions',
        priority: 'High'
      }
    ];

    return {
      topics,
      recommendations
    };
  }

  getStateSpecificHealthEducation(stateCode) {
    const topics = [];

    // Malaria-endemic states
    const malariaStates = ['06', '07', '08', '09', '10', '14', '15'];
    if (malariaStates.includes(stateCode)) {
      topics.push({
        topic: 'Malaria prevention',
        content: 'Use bed nets, indoor spraying, eliminate standing water',
        priority: 'High'
      });
    }

    // Schistosomiasis-endemic states
    const schistoStates = ['11', '12', '13', '16', '17', '18'];
    if (schistoStates.includes(stateCode)) {
      topics.push({
        topic: 'Schistosomiasis prevention',
        content: 'Avoid contact with contaminated water, use safe water sources',
        priority: 'High'
      });
    }

    // Malnutrition-prone states
    const malnutritionStates = ['06', '07', '08', '09', '10', '14'];
    if (malnutritionStates.includes(stateCode)) {
      topics.push({
        topic: 'Nutrition education',
        content: 'Balanced diet, food preparation, child feeding practices',
        priority: 'High'
      });
    }

    return topics;
  }

  async sendPlanNotifications(patientOid, plan) {
    const message = `Health plan generated for ${plan.patientName}. Includes preventive care, treatment, and emergency preparedness.`;

    // In production, this would send SMS/email
    logger.info(`Health plan notification to ${patientOid}`);

    await pool.query(
      `INSERT INTO health_notifications
       (patient_oid, message, type, sent_at)
       VALUES ($1, $2, $3, $4)`,
      [patientOid, message, 'PLAN_GENERATED', new Date().toISOString()]
    );
  }

  startHealthMonitoring() {
    // Schedule health monitoring
    cron.schedule('0 7 * * *', async () => { // 7 AM daily
      logger.info('Starting health monitoring');

      try {
        await this.updateFacilityStatus();
        await this.generateHealthAlerts();
      } catch (error) {
        logger.error('Health monitoring failed', { error: error.message });
      }
    });
  }

  async updateFacilityStatus() {
    // Update facility status metrics
    for (const [facilityCode, facility] of this.healthFacilities) {
      // Simulate status changes
      const performanceChange = (Math.random() - 0.5) * 3;
      const newPerformance = Math.max(50, Math.min(100, facility.performance + performanceChange));

      facility.performance = newPerformance;

      // Update bed occupancy
      const occupancyChange = (Math.random() - 0.5) * 10;
      const newOccupancy = Math.max(0, Math.min(100, (facility.capacity.beds * 0.7) + occupancyChange));

      // Store in database
      await pool.query(
        `INSERT INTO facility_status(*) as total_pat
         (facility_code, facility_name, performance, occupancy, updated_at)
         VALUES ($1, $2, $3, $4, $5)
         ON CONFLICT (facility_code)
         DO UPDATE SET performance = EXCLUDED.performance,
                       occupancy = EXCLUDED.occupancy,
                       updated_at = EXCLUDED.updated_at`,
        [facilityCode, facility.name, newPerformance, newOccupancy, new Date().toISOString()]
      );
    }

    logger.info('Facility status updated');
  }

  async generateHealthAlerts() {
    // Generate alerts for health emergencies
    const alertConditions = ['malaria_outbreak', 'cholera_risk', 'nutrition_emergency'];

    for (const condition of alertConditions) {
      // Simulate alert generation
      if (Math.random() > 0.9) { // 10% chance daily
        await this.sendHealthAlert(condition);
      }
    }
  }

  async sendHealthAlert(condition) {
    const alertMessages = {
      'malaria_outbreak': 'Malaria outbreak detected in region. Increase preventionients,
        AVG(age) as avg_age,
        COUNT(CASE WHEN gender = 'F' THEN 1 measures.',
      'cholera_risk': 'Cholera risk high. Ensure clean water and sanitation.',
      'nutrition_emergency': 'Nutrition emergency detected. Activate feeding programs.'
    };

    const message = alertMessages[condition] || 'Health alert detected';

    await pool.query(
      `INSERT INTO health_alerts
       (alert_type, message, severity, sent_at)
       VALUES ($1, $2, $3, $4)`,
      [condition, message, 'HIGH', new Date().toISOString()]
    );

    // Publish to Kafka for real-time alerting
    const producer = kafka.producer();
    await producer.connect();
    await producer.send({
      topic: 'health-alerts',
      messages: [{
        value: JSON.stringify({
          alertType: condition,
          message,
          timestamp: new Date().toISOString()
        })
      }]
    });
    await producer.disconnect();

    logger.info(`Health alert sent: ${condition}`);
  }

  async getHealthStatistics() {
    const patientStats = await pool.query(`
      SELECT
        state_code,
        COUNT END) as females,
        COUNT(CASE WHEN gender = 'M' THEN 1 END) as males
      FROM health_profiles
      WHERE created_at >= NOW() - INTERVAL '30 days'
      GROUP BY state_code
    `);

    const facilityStats = await pool.query(`
      SELECT
        type,
        COUNT(*) as total_facilities,
        AVG(performance) as avg_performance,
        AVG(occupancy) as avg_occupancy
      FROM facility_status
      WHERE updated_at >= NOW() - INTERVAL '7 days'
      GROUP BY type
    `);

    const planStats = await pool.query(`
      SELECT
        DATE(generated_at) as date,
        COUNT(*) as total_plans
      FROM health_plans
      WHERE generated_at >= NOW() - INTERVAL '30 days'
      GROUP BY DATE(generated_at)
      ORDER BY date DESC
      LIMIT 30
    `);

    const alertStats = await pool.query(`
      SELECT
        alert_type,
        COUNT(*) as alert_count,
        MIN(sent_at) as first_alert,
        MAX(sent_at) as last_alert
      FROM health_alerts
      WHERE sent_at >= NOW() - INTERVAL '30 days'
      GROUP BY alert_type
    `);

    return {
      patients: patientStats.rows,
      facilities: facilityStats.rows,
      plans: planStats.rows,
      alerts: alertStats.rows,
      timestamp: new Date().toISOString()
    };
  }
}

const healthcareManagement = new HealthcareManagement();

// API Endpoints

// Get health recommendations
app.post('/api/v1/healthcare/recommendations', async (req, res) => {
  try {
    const { patientOid, age, gender, stateCode, conditions } = req.body;

    if (!patientOid || !age || !gender || !stateCode) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const recommendations = await healthcareManagement.getHealthRecommendations(
      patientOid,
      age,
      gender,
      stateCode,
      conditions || []
    );

    res.json({
      success: true,
      recommendations,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger res.status(500).json({ error: error.message });
  }
});

// Health check
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    service: 'Healthcare Management',
    timestamp: new Date.error('Health recommendations error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Generate health plan
app.post('/api/v1/healthcare/generate-plan', async (req, res) => {
  try {
    const { patientOid, age, gender, stateCode, conditions } = req.body;

    if (!patientOid || !age || !gender || !stateCode) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const plan = await healthcareManagement.generateHealthPlan(
      patientOid,
      age,
      gender,
      stateCode,
      conditions || []
    );

    res.json({
      success: true,
      plan,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Plan generation error', { error: error.message });
    res.status(500).json({ error: error.message });
  }
});

// Get healthcare statistics
app.get('/api/v1/healthcare/statistics', async (req, res) => {
  try {
    const stats = await healthcareManagement.getHealthStatistics();

    res.json({
      success: true,
      stats,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    logger.error('Statistics error', { error: error.message });
   ().toISOString(),
    version: '1.0.0',
    facilities: healthcareManagement.healthFacilities.size,
    conditions: healthcareManagement.medicalConditions.size,
    protocols: healthcareManagement.treatmentProtocols.size,
    programs: healthcareManagement.healthPrograms.size
  });
});

const PORT = process.env.PORT || 3025;
app.listen(PORT, () => {
  logger.info(`Healthcare Management running on port ${PORT}`);
  console.log(`Healthcare Management running on port ${PORT}`);
});

module.exports = app;
 
INTEGRATION ARCHITECTURE
 
Service Mesh Configuration
 
File: infrastructure/kubernetes/service-mesh.yaml
yaml
yaml
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: sgdus-services(20),
    sent_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Farming & Agriculture Tables
CREATE TABLE farm_registry (
    id SERIAL PRIMARY KEY,
    owner_oid VARCHAR(255) NOT NULL,
    farm_area DECIMAL(10,2),

  namespace: sgdus
spec:
  hosts:
  - "api.sgdus.gov.sd"
  gateways:
  - sgdus-gateway
  http:
  - match:
    - uri:
        prefix: /api/v1/nile-water
    route:
    - destination:
        host: nile-water-service
        port:
          number: 3020
  - match:
    - uri:
        prefix: /api/v1/farming
    route:
    - destination:
        host: farming-service
        port:
          number: 3021
  - match:
    - uri:
        prefix: /api/v1/gold
    route:
    - destination:
        host: gold-service
        port:
          number: 3022
  - match:
    - uri:
        prefix: /api/v1/ports
    route:
    - destination:
        host: ports-service
        port:
          number: 3023
  - match:
    - uri:
        prefix: /api/v1/education
    route:
    - destination:
        host: education-service
        port:
          number: 3024
  - match:
    - uri:
        prefix: /api/v1/healthcare
    route:
    - destination:
        host: healthcare-service
        port:
          number: 3025
 
Database Schema Extensions
 
File: infrastructure/database/sudan-resources-schema.sql
sql
sql
-- Nile Water Management Tables
CREATE TABLE nile_monitoring (
    id SERIAL PRIMARY KEY,
    station_id VARCHAR(50) NOT NULL,
    station_name VARCHAR(100),
    river VARCHAR(50),
    water_level DECIMAL(10,2),
    status VARCHAR(20),
    alerts JSONB,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE water_allocations (
    id SERIAL PRIMARY KEY,
    farmer_oid VARCHAR(255) NOT NULL,
    state_code VARCHAR(2),
    crop_type VARCHAR(50),
    farm_area DECIMAL(10,2),
    allocation_data JSONB,
    calculated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE irrigation_alerts (
    id SERIAL PRIMARY KEY,
    farmer_oid VARCHAR(255) NOT NULL,
    alert_type VARCHAR(50),
    message TEXT,
    urgency VARCHAR crop_type VARCHAR(50),
    soil_type VARCHAR(50),
    location VARCHAR(200),
    last_irrigation_date DATE,
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE agricultural_plans (
    id SERIAL PRIMARY KEY,
    farmer_oid VARCHAR(255) NOT NULL,
    plan_data JSONB,
    generated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE market_prices (
    id SERIAL PRIMARY KEY,
    product VARCHAR(50),
    price DECIMAL(10,2),
    unit VARCHAR(20),
    state_code VARCHAR(2),
    recorded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE market_alerts (
    id SERIAL PRIMARY KEY,
    farmer_oid VARCHAR(255) NOT NULL,
    product VARCHAR(50),
    message TEXT,
    alert_type VARCHAR(50),
    sent_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Gold & Treasures Tables
CREATE TABLE mining_licenses (
    id SERIAL PRIMARY KEY,
    license_id VARCHAR(255) PRIMARY KEY,
    license_number VARCHAR(50) UNIQUE,
 VARCHAR(50),
    quantity DECIMAL(10,2),
    destination VARCHAR(100),
    valuation DECIMAL(15,2),
    exported_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE resource_prices (
    id SERIAL PRIMARY KEY,
    resource_type VARCHAR(50),
    price DECIMAL(15,2),
    unit VARCHAR(20),
    recorded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE price_alerts (
    id SERIAL PRIMARY KEY,
    resource_type VARCHAR(50),
    message TEXT,
    change_percent DECIMAL(5,2),
    trend VARCHAR(20),
    sent_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Red Sea & Ports Tables
CREATE TABLE vessel_schedules (
    id SERIAL PRIMARY KEY,
    schedule_id VARCHAR(255) PRIMARY KEY,
    schedule_number VARCHAR(50) UNIQUE,
    port_code VARCHAR(10),
    vessel_info JSONB,
    cargo_details JSONB,
    arrival_date DATE,
    schedule_data JSONB,
    status VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE customs_clearances (
    id SERIAL PRIMARY KEY,
    clearance_id VARCHAR(255) PRIMARY KEY,
    clearance_number VARCHAR(50) UNIQUE,
       resource_type VARCHAR(50),
    zone_code VARCHAR(50),
    company_info JSONB,
    license_data JSONB,
    issued_at TIMESTAMP,
    status VARCHAR(20)
);

CREATE TABLE compliance_certificates (
    id SERIAL PRIMARY KEY,
    certificate_id VARCHAR(255) PRIMARY KEY,
    certificate_number VARCHAR(50) UNIQUE,
    license_id VARCHAR(255),
    license_number VARCHAR(50),
    resource_type VARCHAR(50),
    certificate_data JSONB,
    issued_at TIMESTAMP
);

CREATE TABLE export_licenses (
    id SERIAL PRIMARY KEY,
    license_id VARCHAR(255) PRIMARY KEY,
    license_number VARCHAR(50) UNIQUE,
    resource_type VARCHAR(50),
    quantity DECIMAL(10,2),
    quality DECIMAL(5,2),
    destination VARCHAR(100),
    company_license VARCHAR(50),
    valuation DECIMAL(15,2),
    total_cost DECIMAL(15,2),
    validity_data JSONB,
    issued_at TIMESTAMP,
    status VARCHAR(20)
);

CREATE TABLE export_logs (
    id SERIAL PRIMARY KEY,
    resource_type schedule_id VARCHAR(255),
    schedule_number VARCHAR(50),
    cargo_type VARCHAR(50),
    cargo_value DECIMAL(15,2),
    duties JSONB,
    clearance_data JSONB,
    status VARCHAR(20),
    issued_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE port_status (
    id SERIAL PRIMARY KEY,
    port_code VARCHAR(10) PRIMARY KEY,
    port_name VARCHAR(100),
    efficiency DECIMAL(5,2),
    congestion VARCHAR(20),
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE port_alerts (
    id SERIAL PRIMARY KEY,
    port_code VARCHAR(10),
    alert_type VARCHAR(50),
    message TEXT,
    severity VARCHAR(20),
    sent_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE arrival_notifications (
    id SERIAL PRIMARY KEY,
    schedule_id VARCHAR(255),
    recipient VARCHAR(100),
    message TEXT,
    sent_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Education Tables
CREATE TABLE student_profiles (
    id SERIAL PRIMARY KEY,
    student_oid VARCHAR(255) PRIMARY KEY,
    academic_performance DECIMAL(5,2),
    grade_level VARCHAR(50),
    school_name VARCHAR(100),
    attendance_rate DECIMAL(5,2),
    updated_at(resource_type);
CREATE INDEX idx_export_logs_resource ON export_logs(resource_type, exported_at);
CREATE INDEX idx_vessel_schedules_port ON vessel_schedules(port_code, arrival_date);
CREATE INDEX idx_customs_clearances_schedule ON customs_clearances(schedule_id);
CREATE INDEX idx_student_profiles_student ON student_profiles(student_oid);
CREATE INDEX idx_educational_plans_student ON educational_plans(student_oid);
CREATE INDEX idx_health_profiles_patient ON health_profiles(patient_oid);
CREATE INDEX idx_health_plans_patient ON health_plans(patient_oid);
 TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE school_performance (
    id SERIAL PRIMARY KEY,
    school_code VARCHAR(50) PRIMARY KEY,
    school_name VARCHAR(100),
    performance DECIMAL(5,2),
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE educational_plans (
    id SERIAL PRIMARY KEY,
    student_oid VARCHAR(255) NOT NULL,
    plan_data JSONB,
    generated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE educational_notifications (
    id SERIAL PRIMARY KEY,
    student_oid VARCHAR(255) NOT NULL,
    message TEXT,
    type VARCHAR(50),
    sent_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE performance_alerts (
    id SERIAL PRIMARY KEY,
    school_code VARCHAR(50),
    alert_type VARCHAR(50),
    message TEXT,
    severity VARCHAR(20),
    sent_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Healthcare Tables
CREATE TABLE health_profiles (
    id SERIAL PRIMARY KEY,
    patient_oid VARCHAR(255) PRIMARY KEY,
    medical_history JSONB,
    allergies JSONB,
    current_medications JSONB,
    emergency_contact JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE facility_status (
    id SERIAL PRIMARY KEY,
    facility_code VARCHAR(50) PRIMARY KEY,
    facility_name VARCHAR(100),
    performance DECIMAL(5,2),
    occupancy DECIMAL(5,2),
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE health_plans (
    id SERIAL PRIMARY KEY,
    patient_oid VARCHAR(255) NOT NULL,
    plan_data JSONB,
    generated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE health_notifications (
    id SERIAL PRIMARY KEY,
    patient_oid VARCHAR(255) NOT NULL,
    message TEXT,
    type VARCHAR(50),
    sent_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE health_alerts (
    id SERIAL PRIMARY KEY,
    alert_type VARCHAR(50),
    message TEXT,
    severity VARCHAR(20),
    sent_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Indexes for performance
CREATE INDEX idx_nile_monitoring_timestamp ON nile_monitoring(timestamp);
CREATE INDEX idx_water_allocations_farmer ON water_allocations(farmer_oid);
CREATE INDEX idx_farm_registry_owner ON farm_registry(owner_oid);
CREATE INDEX idx_mining_licenses_resource ON mining_licenses```

### **Docker Compose for All Modules**

**File: `infrastructure/docker/docker-compose-sudan-resources.yml`**
```yaml
version: '3.8'

services:
  # Nile Water Management
  nile-water-service:
    build:
      context: ../../backend/nile-water-management
      dockerfile: Dockerfile
    ports:
      - "3020:3020"
    environment:
      DB_HOST: postgres
      DB_USER: sgdus
      DB_PASSWORD: ${DB_PASSWORD:-sgdus1:9092
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - sgdus-network

  # Red Sea & Ports
  ports-service:
    build:
      context: ../../backend/red-sea-ports-management
      dockerfile: Dockerfile
    ports:
      - "3023:3023"
    environment:
      DB_HOST: postgres
      DB_USER: sgdus
      DB_PASSWORD: ${DB_PASSWORD:-sgdus123}
      DB_NAME: sgdus
      REDIS_HOST: redis
      REDIS_PASSWORD: ${REDIS_PASSWORD:-redis123}
      KAFKA_BROKERS: kafka:9092
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - sgdus-network

  # Education Management
  education-service:
    build:
      context: ../../backend/education-management
      dockerfile: Dockerfile
    ports:
      - "3024:3024"
    environment:
      DB_HOST: postgres
      DB_USER: sgdus
      DB_PASSWORD: ${DB_PASSWORD:-sgdus123}
      DB_NAME: sgdus
      REDIS_HOST: redis
      REDIS_PASSWORD: ${REDIS_PASSWORD:-redis123}
      KAFKA_BROKERS: kafka:9092
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - sgd23}
      DB_NAME: sgdus
      REDIS_HOST: redis
      REDIS_PASSWORD: ${REDIS_PASSWORD:-redis123}
      KAFKA_BROKERS: kafka:9092
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - sgdus-network

  # Farming & Agriculture
  farming-service:
    build:
      context: ../../backend/farming-agriculture-system
      dockerfile: Dockerfile
    ports:
      - "3021:3021"
    environment:
      DB_HOST: postgres
      DB_USER: sgdus
      DB_PASSWORD: ${DB_PASSWORD:-sgdus123}
      DB_NAME: sgdus
      REDIS_HOST: redis
      REDIS_PASSWORD: ${REDIS_PASSWORD:-redis123}
      KAFKA_BROKERS: kafka:9092
      NILE_WATER_SERVICE_URL: http://nile-water-service:3020
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      nile-water-service:
        condition: service_started
    networks:
      - sgdus-network

  # Gold & Treasures
  gold-service:
    build:
      context: ../../backend/gold-treasures-management
      dockerfile: Dockerfile
    ports:
      - "3022:3022"
    environment:
      DB_HOST: postgres
      DB_USER: sgdus
      DB_PASSWORD: ${DB_PASSWORD:-sgdus123}
      DB_NAME: sgdus
      REDIS_HOST: redis
      REDIS_PASSWORD: ${REDIS_PASSWORD:-redis123}
      KAFKA_BROKERS: kafka
    networks:
      - sgdus-network

  # Existing SGDUS services (from previous implementation)
  oid-service:
    build:
      context: ../../backend/oid-service
      dockerfile: Dockerfile
    ports:
      - "3002:3002"
    environment:
      DB_HOST: postgres
      DB_USER: sgdus
      DB_PASSWORD: ${DB_PASSWORD:-sgdus123}
      DB_NAME: sgdus
      REDIS_HOST: redis
      REDIS_PASSWORD: ${REDIS_PASSWORD:-redis123}
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - sgdus-network

  identity-service:
    build:
      context: ../../backend/identity-service
      dockerfile: Dockerfile
    ports:
      - "3001:3001"
    environment:
      DB_HOST: postgres
      DB_USER: sgdus
      DB_PASSWORD: ${DB_PASSWORD:-sgdus123}
      DB_NAME: sgdus
      OID_SERVICE_URL: http://oid-service:3002
      AUDIT_SERVICE_URL: http://audit-service:3006
      JWT_SECRET: ${JWT_SECRET:-your-jwt-secret-key}
    depends_on:
      postgres:
        condition: service_healthy
      oid-service:
        condition: service_started
    networks:
      - sgdus-network

  # Infrastructure services (from previous implementation)
  postgres:
    image: postgres:14-alpine
    environment:
      POSTGRES_USER: sgdus
      POSTGRES_PASSWORD: ${DB_PASSWORD:-sgdus123}
      POSTGRES_DB: sgdus
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - sgdus-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U sgdus"]
      interval: 10s
      timeout: 5s
     us-network

  # Healthcare Management
  healthcare-service:
    build:
      context: ../../backend/healthcare-management
      dockerfile: Dockerfile
    ports:
      - "3025:3025"
    environment:
      DB_HOST: postgres
      DB_USER: sgdus
      DB_PASSWORD: ${DB_PASSWORD:-sgdus123}
      DB_NAME: sgdus
      REDIS_HOST: redis
      REDIS_PASSWORD: ${REDIS_PASSWORD:-redis123}
      KAFKA_BROKERS: kafka:9092
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy retries: 5

  redis:
    image: redis:7-alpine
    command: redis-server --requirepass ${REDIS_PASSWORD:-redis123}
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - sgdus-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  kafka:
    image: confluentinc/cp-kafka:7.3.0
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
    ports:
      - "9092:9092"
    depends_on:
      - zookeeper
    networks:
      - sgdus-network

  zookeeper:
    image: confluentinc/cp-zookeeper:7.3.0
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000
    ports:
      - "2181:2181"
    networks:
      - sgdus-network

  # Monitoring
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--storage.tsdb.retention.time=200h'
      - '--web.enable-lifecycle'
    networks:
      - sgdus-network

  grafana:
    image: grafana/grafana:latest
    ports:
      - "3003:3000"
    environment:
      GF_SECURITY_ADMIN_PASSWORD: ${GRAFANA_PASSWORD:-admin123}
    volumes:
      - grafana_data:/var/lib/grafana
      - ./grafana/provisioning:/etc/grafana/provisioning
    depends_on:
      - prometheus
    networks:
      - sgdus-network

volumes:
  postgres_data:
  redis_data:
  prometheus_data:
  grafana_data:

networks:
  sgdus-network:
    driver: bridge
 
Monitoring Dashboard Configuration
 
File: infrastructure/monitoring/sudan-resources-dashboard.json
json
json
{
  "dashboard": {
    "title": "Sudan Resources Management Dashboard",
    "panels": [
      {
        "title": "Nile Water Levels",
        "type": "graph",
        "targets": [{
          "expr": "nile_water_level{station=~\".*\"}",
          "legendFormat": "{{station}}"
        }],
        "thresholds": [
          {"value": 30, "color": "red", "op": "gt"},
          {"value": 5, "color": "yellow", "op": "lt"}
        ]
      },
      {
        "title": "Agricultural Production",
        "type": "stat",
        "targets": [{
          "expr": "sum(agricultural_output{state=~\".*\"})",
          "legendFormat": "Total Output"
        }],
        "unit": "tons"
      },
      {
        "title": "Gold Production",
        "type": "stat",
        "targets": [{
          "expr": "gold_production{resource=\"gold\"}",
          "legendFormat": "Production"
        }],
        "unit": "kg"
      },
      {
        "title": "Port Activity",
        "type": "graph",
        "targets": [{
          "expr": "port_vessels{port=~\".*\"}",
          "legendFormat": "{{port}}"
        }]
      },
      {
        "title": "Education Enrollment",
        "type": "stat",
        "targets": [{
          "expr": "education_enrollment{level=\"primary\"}",
          "legendFormat": "Primary"
        }],
        "unit": "students"
      },
      {
        "title": "Healthcare Access",
        "type": "stat",
        "targets": [{
          "expr": "healthcare_access{facility=\"hospital\"}",
          "legendFormat": "Hospital Access"
        }],
        "unit": "percent"
      },
      {
        "title": "System Health",
        "type": "heatmap",
        "targets": [{
          "expr": "system_health{service=~\".*\"}",
          "legendFormat": "{{service}}"
        }]
      }
    ],
    "refresh": "30s",
    "time": {
      "from": "now-1h",
      "to": "now"
    }
  }
}
 
Implementation Roadmap
 
Phase 1: Core Integration (Months 1-3)
1.Database Schema Extension - Add Sudanese resource tables
2.Service Discovery - Register all new modules in service mesh
3.OID Integration - Link all resources to existing OID system
4.Basic APIs - Implement core endpoints for each module
 
Phase 2: Module Development (Months 4-6)
1.Nile Water Management - Complete water allocation algorithms
2.Farming System - Implement crop and livestock recommendations
3.Gold Management - Complete licensing and export systems
4.Port Management - Implement vessel scheduling and customs
 
Phase 3: Advanced Features (Months 7-9)
1.Education Management - Complete student tracking and planning
2.Healthcare Management - Implement health monitoring and alerts
3.Cross-Module Integration - Connect all modules for unified services
4.Mobile Apps - Develop mobile interfaces for farmers, miners, etc.
 
Phase 4: Optimization & Scale (Months 10-12)
1.Performance Optimization - Scale all services for production load
2.AI/ML Integration - Add predictive analytics and recommendations
3.International Integration - Connect to international systems
4.Full Production Rollout - Deploy to all regions of Sudan
 
Success Metrics
 
Nile Water Management
90% of farmers receive irrigation recommendations
20% reduction in water waste
15% increase in agricultural yield
 
Farming & Agriculture
50,000 farmers using the system
25% increase in crop yields
30% reduction in crop losses
 
Gold & Treasures
100% of mining licenses digitized
95% compliance with export regulations
20% increase in legal exports
 
Red Sea & Ports
50% reduction in customs clearance time
30% increase in port efficiency
100% vessel tracking
 
Education Management
1 million students using the system
15% improvement in educational outcomes
100% school performance monitoring
 
Healthcare Management
2 million patients using the system
20% reduction in disease outbreak response time
100% health facility monitoring
 
This comprehensive integration creates a truly unified Sudanese digital ecosystem that manages all critical resources and services through intelligent automation, predictive analytics, and seamless integration with existing SGDUS infrastructure.

Citation sources (0)
